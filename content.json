{"meta":{"title":"MoStone's Base","subtitle":"我们，依旧在路上。","description":null,"author":"Mo_Stone","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-01-31T03:09:53.290Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[MoStone] 与&nbsp; MoStone&nbsp; （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"arknights","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-17T04:12:23.513Z","comments":false,"path":"arknights/index.html","permalink":"/arknights/index.html","excerpt":"","text":"","keywords":"明日方舟编年史"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-01-28T13:27:29.579Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-04-19T11:31:36.138Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"acg相关 常听 收藏","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"other","date":"2019-02-10T13:32:48.000Z","updated":"2020-04-23T13:20:04.289Z","comments":false,"path":"other/index.html","permalink":"/other/index.html","excerpt":"","text":"","keywords":null},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-04-19T02:10:34.157Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-01-28T13:14:31.136Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"本主题基于Hexo主题Sakura修改,感谢作者hojun。Hexo版修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"","date":"2020-01-14T12:56:52.901Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/package.json","permalink":"/lib/reading_progress/package.json","excerpt":"","text":"{\"name\":\"theme-next-reading-progress\",\"version\":\"1.2.0\",\"description\":\"Reading Progress for NexT\",\"main\":\"reading_progress.js\",\"scripts\":{\"uglify\":\"uglifyjs --compress --mangle -o reading_progress.min.js -- reading_progress.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-reading-progress.git\"},\"author\":\"theme-next\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-reading-progress/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-reading-progress#readme\",\"dependencies\":{\"uglify-js\":\"^3.3.9\"}}"},{"title":"","date":"2020-01-14T12:56:52.903Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.js","permalink":"/lib/reading_progress/reading_progress.js","excerpt":"","text":";(function() { var $bar = $('.reading-progress-bar') if (!$bar.length) return //no progress bar found var supportsPassive = false try { var opts = Object.defineProperty({}, 'passive', { get: function() { supportsPassive = true } }) window.addEventListener('test', $.noop, opts) window.removeEventListener('test', $.noop) } catch (e) {} var $w = $(window) var $d = $(document) $d.ready(function() { window.addEventListener( 'scroll', function() { var wh = $w.height() var dh = $d.height() var st = $w.scrollTop() var percent = (st / (dh - wh)) * 100 percent = percent > 100 ? 100 : percent < 0 ? 0 : percent $bar.css('width', percent + '%') }, supportsPassive ? { passive: true } : false ) }) })()"},{"title":"","date":"2020-01-14T12:56:52.907Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/README.html","permalink":"/lib/reading_progress/README.html","excerpt":"","text":"Reading Progress for NexT Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: $ cd themes/next $ ls bower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: $ git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress Step 3 &rarr; Set it up Enable module in NexT _config.yml file: reading_progress: enable: true color: &quot;#37c6c0&quot; height: 2px And, if you wants to use the CDN, then need to set: vendors: ... reading_progress: //cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js Update $ cd themes/next/source/lib/reading_progress $ git pull"},{"title":"","date":"2020-01-14T12:56:52.905Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.min.js","permalink":"/lib/reading_progress/reading_progress.min.js","excerpt":"","text":"!function(){var e=$(\".reading-progress-bar\");if(e.length){var n=!1;try{var t=Object.defineProperty({},\"passive\",{get:function(){n=!0}});window.addEventListener(\"test\",$.noop,t),window.removeEventListener(\"test\",$.noop)}catch(e){}var i=$(window),o=$(document);o.ready(function(){window.addEventListener(\"scroll\",function(){var n=i.height(),t=o.height(),r=i.scrollTop()/(t-n)*100;r=r>100?100:r"},{"title":"","date":"2020-01-14T12:56:52.910Z","updated":"2019-12-13T04:47:50.084Z","comments":true,"path":"lib/reading_progress/renovate.json","permalink":"/lib/reading_progress/renovate.json","excerpt":"","text":"{\"extends\":[\"config:base\"]}"}],"posts":[{"title":"《数据结构》笔记（8.3）——二叉树的非递归遍历算法","slug":"数据结构笔记8.3","date":"2020-04-21T01:45:00.000Z","updated":"2020-04-23T10:14:16.096Z","comments":true,"path":"2020/04/21/数据结构笔记8.3/","link":"","permalink":"/2020/04/21/数据结构笔记8.3/","excerpt":"","text":"二叉树遍历递归算法 整合下载：提取码: axjn 只有10k，不需要担心限速的问题。 导入的包，树、队列的构建其实完全可以不用导入动态数组ArrayList包的，这只是我比较倾向于用而已。 import java.util.ArrayList; import java.util.Stack; `` 栈在先序、中序、后序遍历中使用。队列在层次遍历中使用。（其实这是直接搬用的前面用数组构建循环队列的方法，懒得再写一遍而已） /** * 创建结点，包含数据，左右子结点地址 */ static class Node&lt;E&gt;{ E data; Node&lt;E&gt; right; Node&lt;E&gt; left; //相关数据的添加 public Node(E data , Node&lt;E&gt; right , Node&lt;E&gt; left){ this.left = left; this.right = right; this.data = data; } //初始化 public Node(E data){ this(data,null,null); } } /** * 创建树 */ public static class LinkedTree&lt;E&gt;{ //根结点 Node&lt;E&gt; root; //初始化树 public LinkedTree(E data){ root = new Node&lt;&gt;(data); } /** * 添加结点 * @param data 添加的数据 * @param father 父级结点地址 * @param isLeft 是否为父级结点的左子结点 * @return 添加的结点 */ public Node&lt;E&gt; add(E data , Node&lt;E&gt; father , boolean isLeft){ if(father == null) throw new RuntimeException(&quot;无父级，拒绝添加&quot;); Node&lt;E&gt; theNode = new Node&lt;&gt;(data); if(isLeft){ father.left = theNode; }else{ father.right = theNode; } return theNode; } } /** * 循环队列 */ static class QueueArray&lt;E&gt;{ //设定队列，队的容量，前端和后端，元素数量。 //前端为队头元素位置，后端下标为队尾元素后一个位置。 private int size = 20 ; private Object[] que_arr ; private int front ; private int rear ; private int count ; //初始化队列 public QueueArray(){ que_arr =new Object [size] ; this.front = 0 ; this.rear = 0 ; this.count = 0; } /** * 入队 * @param data */ public void In(E data){ //判断是否队满 if (count == size){ throw new RuntimeException(&quot;队满&quot;); } //添加数据，元素总数+1 que_arr[rear] = data ; ++count; //队尾标号的增加 if (rear+1 &gt;= size){ rear = 0; }else{ ++rear; } } /** * 出队 * @return 队头元素 */ public Object Out(){ if (count == 0){ throw new RuntimeException(&quot;队空&quot;); } Object data = que_arr[front]; que_arr[front] = null ; --count; if (front+1 &gt;= size){ front = 0; }else{ ++front; } return data; } } /** * 输出 * @param list 需输出的数组 */ public static void print(ArrayList&lt;Object&gt; list){ for (int i = 0 ; i&lt;list.size() ; i++) System.out.print(list.get(i)+&quot; &quot;); System.out.println(); } ` 先序遍历思想1循环控制： 1、入栈前，指向本结点；2、先左子树一次入栈并输出（入栈前先指向该结点），直到没有左子树的结点为止；3、出栈顶元素，然后找到右子树，继续1、2操作，直到栈为空且结点为空。 举例 指针指向根结点，将左子树结点1、2、3循环依次入栈并输出，直至没有左子树结点，指针为null。 栈中元素：1 2 3 输出元素：1 2 3 栈顶结点3出栈，无右子结点，之后栈顶结点2出栈，指针指向结点2的右子结点5，继续重复一步骤：将结点5的左子树结点循环入栈并输出，当然此处5为叶子结点，无左子节点。 栈中元素：1 5 输出元素：1 2 3 5 结点5出栈，无右子结点，之后栈顶结点1出栈，指针指向结点1的右子结点4，同上。 栈中元素：4 输出元素：1 2 3 5 4 结点4出栈，无右子结点，此时栈为空，指针指向结点4的左子结点null，遍历结束。 栈中元素： 输出元素：1 2 3 5 4 参考代码/** * 先序1 * @param root 树的根结点 * @return 先序遍历序列数组 */ public static ArrayList&lt;Object&gt; preOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建暂时存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建先序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向root Node&lt;Object&gt; p = root; //循环至栈空 while(p!=null || !stack.isEmpty() ){ /* * 循环将p结点和左子结点入栈入组，直至p为null */ while(p!=null){ stack.add(p); list.add(p.data); p = p.left; } /* * 如果p为null，栈为空，表明遍历结束 * 如果栈不为空，弹出栈顶结点，p指针指向该节点的右子节点（有可能为null） * 继续循环将p的左子节点入栈入组 */ if(!stack.isEmpty()){ p = stack.pop(); p = p.right; } } //返回后序遍历序列数组 return list; } 思想2使用一个栈，首先将根结点入栈，开始循环： 从栈中退出当前结点p，先访问它，然后将其右孩子入栈，再将其左孩子入栈，如此直到栈为空。（因为对左孩子的访问先序遍历先于右孩子，后入栈的先访问） 举例 结点1入栈。 栈中元素：1 输出元素： 栈顶结点1出栈，输出结点1，并将结点1的右子结点4先入栈，左子结点2后入栈。 栈中元素：4 2 输出元素：1 栈顶结点2出栈，输出结点2，同样将结点2的右子结点5先入栈，左子结点3后入栈。 栈中元素：4 5 3 输出元素：1 2 栈顶结点3出栈，输出结点3，因结点3为叶子结点，无入栈。栈顶结点5出栈，输出结点5 栈中元素：4 输出元素：1 2 3 5 栈顶结点4出栈，输出结点4，栈空，遍历结束。 栈中元素： 输出元素：1 2 3 5 4 参考代码/** * 先序2 * @param root 树的根结点 * @return 先序遍历序列数组 */ public static ArrayList&lt;Object&gt; preOrder2(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建先序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p; //将根结点入栈 stack.push(root); //循环至栈空 while(!stack.isEmpty()){ /* * 依据先序遍历的特点：p结点→左子节点→右子结点 */ //p指针指向弹出栈顶的结点 p = stack.pop(); //p结点的数据入组 list.add(p.data); //如果有右结点，入栈 if( p.right != null) stack.push(p.right); //如果有左节点，入栈并p指针指向左子节点 if( p.left != null) { stack.push(p.left); p=p.left; } } //返回先序遍历序列数组 return list; } ` 中序遍历思想与先序的循环控制类似： 1、入栈前，先指向本结点；2、先左子树一次入栈（入栈前先指向该结点），直到没有左子树的结点为止；3、出栈顶元素并输出，若有右子树，找到右子树，继续1、2操作，直到栈为空且结点为空。 举例 指针指向根结点，将左子树结点1、2、3循环依次入栈，直至没有左子树结点，指针为null。 栈中元素：1 2 3 输出元素： 栈顶结点3出栈并输出，无右子结点，之后栈顶结点2出栈并输出，指针指向结点2的右子结点5，继续重复一步骤：将结点5的左子树结点循环入栈，当然此处5为叶子结点，无左子节点。 栈中元素：1 5 输出元素：3 2 结点5出栈并输出，无右子结点，之后栈顶结点1出栈并输出，指针指向结点1的右子结点4，同上。 栈中元素：4 输出元素：3 2 5 1 结点4出栈并输出，无右子结点，此时栈为空，指针指向结点4的左子结点null，遍历结束。 栈中元素： 输出元素：3 2 5 1 4 参考代码/** * 中序 * @param root 树的根结点 * @return 中序遍历序列数组 */ public static ArrayList&lt;Object&gt; inOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建中序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向根结点 Node&lt;Object&gt; p = root; //循环至p指针为null，以及栈为空。 while(p!=null || !stack.isEmpty() ){ //依次将左子树结点入栈，直至为null while(p!=null){ stack.add(p); p = p.left; } /* * 如果指针p和栈均为空，则遍历完成 * 如果栈不为空，弹出的栈顶结点，数据入组，p指针指向该节点右子节点 */ if(!stack.isEmpty()){ p = stack.pop(); list.add(p.data); p = p.right; } } //返回中序遍历序列数组 return list; } ` 后序遍历思想1——双栈实际上我觉得这个方法很神奇。实际上它做的是一个反向的预排序遍历。 由于后序序列的顺序是：左子结点→右子结点→根结点，所以入栈1的顺序是正常顺序，入栈2的顺序是：根结点→右子结点→左子结点，之后再将栈2的结点依次出栈输出。 举例 先将根结点入栈1，在循环中将栈1的栈顶结点1出栈，指针指向结点1，并将其入栈2，将指针所指的结点1的左、右子结点2、4按顺序依次入栈1. 栈1元素：2 4 栈2元素：1 栈1的栈顶结点4出栈，指针指向结点4，并入栈2，由于结点4为叶子结点，跳过。 栈1元素：2 栈2元素：1 4 同循环里的步骤1，栈1的栈顶结点2出栈，指针指向结点2，并入栈2，将指针所指的结点2的左、右子结点3、5依次入栈1。 同步骤2栈1的栈顶结点5出栈入栈2，由于结点5是叶子节点，跳过。结点3同理。 栈1元素：3 5 栈2元素：1 4 2 ↓ 栈1元素： 栈2元素：1 4 2 5 3 ` 栈1空，遍历完毕，将栈2元素依次出栈输出即可。 输出元素：3 5 2 4 1 参考代码/** * 后序 双栈 * @param root 树的根结点 * @return 后序遍历序列数组 */ public static ArrayList&lt;Object&gt; postOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建暂时存储结点的栈1，以及存储结点倒序的栈2 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); Stack&lt;Object&gt; stack2 = new Stack&lt;&gt;(); //创建后序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p; //将根结点入栈1 stack.push(root); //循环至栈1为空，即栈1结点数据均入栈2 while(!stack.isEmpty()){ /* * 始终依据后序遍历的特点：左子节点→右子结点→p结点 * 由于栈是先入后出，入栈顺序，p结点→右子结点→左子节点 */ //弹出栈1顶端结点 p = stack.pop(); //根据是否存在左右子节点，按照p→右→左的顺序入栈2 stack2.push(p.data); if( p.left != null) stack.push(p.left); if( p.right != null) stack.push(p.right); } //将栈2里的元素依次输入至数组 while (!stack2.isEmpty()){ list.add(stack2.pop()); } //返回后序遍历序列数组 return list; } `` 思想2——标记因后序遍历：左子树→后右子树→根结点，则需要判断上次访问的结点是位于左子树，还是右子树。 若是位于左子树，则需跳过根结点，先进入右子树；若是位于右子树，则直接输出根结点。 因此，可通过设置标志位，标明上次访问的结点是位于左子树，还是右子树。 举例 指针指向根结点，将左子树结点1、2、3循环依次入结点栈，标记栈中入“左”的标记，直至没有左子树结点，指针为null。 结点栈元素：1 2 3 标记栈元素：左 左 左 输出元素： 查看结点栈的栈顶结点3，查看栈栈顶标记，标记为“左”，指针指向结点3的右子结点（为null），标记栈入“右”标记。 结点栈元素：1 2 3 标记栈元素：左 左 右 输出元素： 由于指针为null，跳过循环，查看标记栈栈顶标记，标记为“右”，结点栈栈顶结点3出栈并输出，标记栈栈顶标记出栈。 结点栈元素：1 2 标记栈元素：左 左 输出元素：3 查看结点栈的栈顶结点2，查看栈栈顶标记，标记为“左”，指针指向结点2的右子结点5，标记栈入“右”标记。 结点栈元素：1 2 标记栈元素：左 右 输出元素：3 指针不为null，将结点5入结点栈，“左”标记入标记栈。 结点栈元素：1 2 5 标记栈元素：左 右 左 输出元素：3 同理，查看结点栈的栈顶结点5，查看栈栈顶标记，标记为“左”，指针指向结点3的右子结点（为null），标记栈入“右”标记。 结点栈元素：1 2 5 标记栈元素：左 右 右 输出元素：3 同理，由于指针为null，跳过循环，查看标记栈栈顶标记，标记为“右”，结点栈栈顶结点5出栈并输出，标记栈栈顶标记出栈。之后同上 结点栈元素：1 2 标记栈元素：左 右 输出元素：3 5 ↓ 结点栈元素：1 标记栈元素：左 输出元素：3 5 2 ↓ 结点栈元素：1 4 标记栈元素：右 左 输出元素：3 5 2 ↓ 结点栈元素：1 4 标记栈元素：右 右 输出元素：3 5 2 ↓ 结点栈元素：1 标记栈元素：右 输出元素：3 5 2 4 ↓ 结点栈元素： 标记栈元素： 输出元素：3 5 2 4 1 参考代码/** * 后序 标记 * @param root 树的根结点 * @return 后序遍历序列数组 */ public static ArrayList&lt;Object&gt; postOrder2(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建储存结点和左右子树的标记的栈，此处左子树记为-1，右为1. Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); //创建后序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p = root; //循环直至结点栈为空和指针为null while( p != null || !stack.isEmpty()){ //若指针不为null，将结点入栈，并标记为左子树（-1），循环至p指向null while (p!=null){ stack.push(p); stack2.push(-1); p = p.left; } //若p指针为null,栈中为空，则已遍历完成，跳出循环。 if(stack.isEmpty()) break; /* * 指针上一个指向的结点，即结点栈顶端的结点若在右子树， * 则该节点左右结点结点均已遍历（当然也有可能为空），弹出右标记，并将该结点入表 */ if(stack2.peek() == 1){ stack2.pop(); list.add(stack.pop().data); } /* * 指针上一个指向的结点，即结点栈顶端的结点若在左子树， * 则弹出左标记，指针指向该节点的右结点，并标记为右子树（1）。 * * 这里需要注意，指向右结点后有可能该节点存在左子树， * 所以需要再次利用前方添加左节点的循环， * 所以需要在循环最后。 */ else if(stack2.peek() == -1){ stack2.pop(); p = stack.peek().right; stack2.push(1); } } //循环结束，返回后序遍历序列数组 return list; } ` 层次遍历（从上向下）思路层次遍历：从上往下，从左往右。 先将根结点入队，指针指向队首，将根结点的左、右子结点依次入队，如果没有就跳过。之后指针向后移动，队首结点出队输出，再次重复将指针所指结点的左、右子结点依次入队。直至队空。 举例 先将根结点入队，指针指向根结点，之后将指针所指结点1的左、右子结点2、4依次入队。 队列元素：1 2 4 输出元素： 指针向后移动，队首结点出队输出，再将指针所指结点2的左、右子结点3、5依次入队。 队列元素：2 4 3 5 输出元素：1 指针向后移动，队首结点出队输出，指针所指结点4为叶子结点，跳过。 队列元素：4 3 5 输出元素：1 2 之后同理，直至队列元素为空。 队列元素： 输出元素：1 2 4 3 5 ` 参考代码/** * 层次 */ @SuppressWarnings(&quot;unchecked&quot;) public static ArrayList&lt;Object&gt; levelOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建储存结点的队列 QueueArray&lt;Node&lt;Object&gt;&gt; quearr = new QueueArray&lt;&gt;(); //创建后序遍历序列储存的数组 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //将根结点入队 quearr.In(root); //创建当前结点和指针,指针指向队首结点 int flag = 0; Node&lt;Object&gt; p = (Node&lt;Object&gt;) quearr.que_arr[flag]; //循环至队列为空 while (quearr.count != 0){ /* * 指针从队首依次向后移动，依次将该节点的左右子节点入队 * 若指针向后移动，之前的结点出队 */ if(p.left!=null) quearr.In(p.left); if(p.right!=null) quearr.In(p.right); //出队入组 list.add(((Node&lt;Object&gt;)quearr.Out()).data); //flag标号的增加 if (flag+1 &gt;= quearr.size){ flag = 0; }else{ ++flag; } //指针向后移动 p = (Node&lt;Object&gt;) quearr.que_arr[flag]; } //返回层次遍历序列数组 return list; } ` 所有方法的主函数测试 public static void main(String[] args){ LinkedTree&lt;Object&gt; tree = new LinkedTree&lt;&gt;(&quot;A&quot;); Node&lt;Object&gt; A = tree.root; Node&lt;Object&gt; B = tree.add(&#39;B&#39;, A, true); Node&lt;Object&gt; C = tree.add(&#39;C&#39;, A, false); Node&lt;Object&gt; D = tree.add(&#39;D&#39;, B, true); Node&lt;Object&gt; E = tree.add(&#39;E&#39;, B, false); Node&lt;Object&gt; F = tree.add(&#39;F&#39;, C, false); Node&lt;Object&gt; G = tree.add(&#39;G&#39;, D, true); Node&lt;Object&gt; H = tree.add(&#39;H&#39;, E, true); Node&lt;Object&gt; I = tree.add(&#39;I&#39;, E, false); Node&lt;Object&gt; J = tree.add(&#39;J&#39;, I, false); System.out.print(&quot;先序遍历序列，法一：&quot;); print(preOrder(A)); System.out.print(&quot;先序遍历序列，法二：&quot;); print(preOrder2(A)); System.out.print(&quot;中序遍历序列：&quot;); print(inOrder(A)); System.out.print(&quot;后序遍历序列，双栈：&quot;); print(postOrder(A)); System.out.print(&quot;后序遍历序列，标记：&quot;); print(postOrder2(A)); System.out.print(&quot;层次遍历序列：&quot;); print(levelOrder(A)); } 结果先序遍历序列，法一：A B D G E H I J C F 先序遍历序列，法二：A B D G E H I J C F 中序遍历序列 ：G D B H E I J A C F 后序遍历序列，双栈：G D H J I E B F C A 后序遍历序列，标记：G D H J I E B F C A 层次遍历序列：A B C D E F G H I J `","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.2）——二叉树的遍历","slug":"数据结构笔记8.2","date":"2020-04-14T01:45:00.000Z","updated":"2020-04-23T00:47:05.515Z","comments":true,"path":"2020/04/14/数据结构笔记8.2/","link":"","permalink":"/2020/04/14/数据结构笔记8.2/","excerpt":"","text":"二叉树的遍历遍历（Traversing）是树形结构的一种重要运算，即按一定的次序系统地访问结构中的所有结点，使每个结点只被访问一次。 常用方法：先序法；中序法；后序法；层次法。 先序法（PreOrder）从根结点a开始访问，接着访问左子结点b，最后访问右子结点c。即：根结点 → 左子树 → 右子树 中序法（InOrder）从左子结点b开始访问，接着访问根结点a，最后访问右子结点c。即：左子树 → 根结点 → 右子树 偷懒的简单转换方法： 后序法（PostOrder）从左子结点b开始访问，接着访问右子结点c，最后访问根结点a。即：左子树 → 右子树 → 根结点 层次法从上往下，从左往右依次读出结点。 依据序列构建二叉树若仅已知先序序列、中序序列、后序序列其中任意一个，无法唯一确定二叉树。 若已知先序和后序序列，同样无法唯一确定二叉树。 先序、中序序列例：若已知某二叉树的先序序列 [ ABHFDECKG ] 和中序序列 [ HBDFAEKCG ] ，构建该二叉树。 对于先序序列，根结点在第一个位置。对于中序序列，根结点大多数情况在中序序列的中间某一位置（也可能存在位于首尾的情况），左边部分是根结点的左子树的中序遍历序列，右边部分是根结点的右子树的中序遍历序列。 先序：A BHFD ECKG 中序：HBDF A EKCG 结论：A是根结点，HBDF结点在左侧，ECKG结点在右侧。 先序：B H FD 中序：H B DF 结论：B是左子树根结点，H结点在左侧，FD结点在右侧。 根据先序和中序的特点，F位于D的上一层，且D在以F为根结点的子树的左子树中，F无右子树。 先序：E CKG 中序：E KCG 结论：E是右子树根结点，左侧无结点，CKG结点在右侧。 先序：C KG 中序：K C G 同样的，根据先序和中序的特点，C位于KG的上一层，且K在以C为根结点的子树的左子树中，G在右子树中。 中序、后序序列实际上，已知中序、后序序列来构建二叉树与已知先序、中序来构建方法类似，均是利用遍历序列特性。 例：若已知某二叉树的后序序列 [ DGEBFCA ] 和中序序列 [ DBGEACF ] ，构建该二叉树。 对于后序序列，根结点在最后一个位置。中序序列同上 后序：DGEB FC A 中序：DBGE A CF 结论：A是根结点，DBGE结点在左侧，CF结点在右侧。 后序：D GE B 中序：D B GE 结论：B是左子树根结点，D结点在左侧，GE结点在右侧。 根据后序和中序的特点，E位于G的上一层，且G在以E为根结点的子树的左子树中，E无右子树。 同理，右子树中，C位于F的上一层，且F在以C为根结点的子树的右子树中，C无左子树。 二叉树递归遍历算法二叉树以用链表构建的为例，每个结点中包含：该节点的数据，左、右子结点的地址。 实际上个人觉得二叉树遍历的递归算法虽容易理解，但写出来对于我来说可能会有点困难，因为找到进入和跳出的点可能对于我来说有些困难，所以个人的倾向还是使用非递归的算法。 树的创建/** * 创建结点，包含数据，左右子结点地址 */ public static class Node&lt;E&gt;{ E data; Node&lt;E&gt; right; Node&lt;E&gt; left; //相关数据的添加 public Node(E data , Node&lt;E&gt; right , Node&lt;E&gt; left){ this.left = left; this.right = right; this.data = data; } //初始化 public Node(E data){ this(data,null,null); } } /** * 创建树 */ public static class LinkedTree&lt;E&gt;{ //根结点 Node&lt;E&gt; root; //初始化树 public LinkedTree(E data){ root = new Node&lt;&gt;(data); } /** * 添加结点 * @param data 添加的数据 * @param father 父级结点地址 * @param isLeft 是否为父级结点的左子结点 * @return 添加的结点 */ public Node&lt;E&gt; add(E data , Node&lt;E&gt; father , boolean isLeft){ if(father == null) throw new RuntimeException(&quot;无父级，拒绝添加&quot;); Node&lt;E&gt; theNode = new Node&lt;&gt;(data); if(isLeft){ father.left = theNode; }else{ father.right = theNode; } return theNode; } } ` 递归遍历的方法 /** * 二叉树的遍历 * 均依靠各自遍历方法的特点 */ public static class TreeTraver{ //先序 static ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void preOrder(Node&lt;Object&gt; root){ if(root == null) return; list.add(root.data); //System.out.print(root.data + &quot; &quot;); preOrder(root.left); preOrder(root.right); } //中序 private static void inOrder(Node&lt;Object&gt; root){ if (root == null) return; inOrder(root.left); list.add(root.data); //System.out.print(root.data + &quot; &quot;); inOrder(root.right); } //后序 private static void postOrder(Node&lt;Object&gt; root){ if (root == null) return; postOrder(root.left); postOrder(root.right); list.add(root.data); //System.out.print(root.data + &quot; &quot;); } private static void print(){ for (int i = 0 ; i&lt;list.size() ; i++) System.out.print(list.get(i)+&quot; &quot;); list.removeAll(list); } } 主函数测试public static void main(String[] args){ LinkedTree&lt;Object&gt; tree = new LinkedTree&lt;&gt;(&quot;A&quot;); Node&lt;Object&gt; A = tree.root; Node&lt;Object&gt; B = tree.add(&#39;B&#39;, A, true); Node&lt;Object&gt; C = tree.add(&#39;C&#39;, A, false); Node&lt;Object&gt; D = tree.add(&#39;D&#39;, B, true); Node&lt;Object&gt; F = tree.add(&#39;F&#39;, C, true); Node&lt;Object&gt; G = tree.add(&#39;G&#39;, C, false); System.out.print(&quot;先序遍历序列：&quot;); TreeTraver.preOrder(A); TreeTraver.print(); System.out.println(); System.out.print(&quot;中序遍历序列：&quot;); TreeTraver.inOrder(A); TreeTraver.print(); System.out.println(); System.out.print(&quot;后序遍历序列：&quot;); TreeTraver.postOrder(A); TreeTraver.print(); System.out.println(); } 结果先序遍历序列：A B D C F G 中序遍历序列：D B A F C G 后序遍历序列：D B F G C A `","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.1）——树的定义和存储结构","slug":"数据结构笔记8.1","date":"2020-04-10T01:45:00.000Z","updated":"2020-04-14T09:19:01.638Z","comments":true,"path":"2020/04/10/数据结构笔记8.1/","link":"","permalink":"/2020/04/10/数据结构笔记8.1/","excerpt":"","text":"定义由零个、一个或多个结点组成的有限集合。仅有一个根结点，结点间有明显的层次结构关系。 从逻辑结构看：1）树中只有根结点没有前趋；2）除根外，其余结点都有且仅一个前趋；3）树的结点，可以有零个或多个后继；4）除根外的其他结点，都存在唯一条从根到该结点的路径；树是一种分枝结构（除了一个称为根的结点外）每个元素都有且仅有一个直接前趋，有且仅有零个或多个直接后继。 表示方法树形表示、图形表示、凹入表表示、嵌套集合表示 二叉树定义：二叉树是n(n≥0)个结点的有限集。它或为空树(n=0)，或由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树构成。 特点：1、每个结点至多有二棵子树(即不存在度大于2的结点)。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、二叉树的子树有左、右之分，且其次序不能任意颠倒。 基本形态：空二叉树，只有根结点，右子树为空，左子树为空，左、右子树均非空。 性质： 在二叉树的第 i 层上至多有 2^(i-1) 个结点 ( i ≥ 1 ) 。 高度为 k 的二叉树至多有 2^k -1 个结点 (k ≥ 1) 。 对任何一棵二叉树T，如果其叶结点数为n0 ，度为2的结点数为n2 ，则n0 = n2 + 1 。 具有 n 个结点的完全二叉树的高度为 (log2 n) + 1 。 如果对一棵有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i(1≤i≤n)，有： 如果 i=1 ，则结点 i 是二叉树的根，无双亲。 如果 i&gt;1 ，则其双亲是 i/2 。 如果 2i&gt;n ，则结点 i 无左孩子；如果 2i≤n ，则其左孩子是 2i 。 如果 2i+1&gt;n ，则结点 i 无右孩子；如果 2i+1≤n ，则其右孩子是 2i+1 。 特殊形式的二叉树满二叉树定义：一棵高度为 k 且有 2^k - 1 个结点的二叉树称为满二叉树。 特点，每一层上的结点数都是最大结点数。 完全二叉树定义：高度为 k ，有 n 个结点的二叉树，当且仅当其每一个结点都与高度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时，称为完全二叉树。 特点：1、叶子结点只可能在层次最大的两层上出现。2、对任一结点，若其右分支下子孙的最大层次为 L，则其左分支下子孙的最大层次必为 L 或 L+1 。 判断方法：1、根据特点2，若存在一个 k 层的完全二叉树，那么从 1 到 k-1 层必为满二叉树。2、根据定义，在完全二叉树第 k 层，从左往右必定依次与满二叉树的第 k 层一一对应，允许 k 层右端连续空缺，但不允许左端中途空缺。 二叉树的储存方法顺序存储思路：若存在两个数据，分别为树的父级和子级，位置为 i 和 j ，若子级位于左侧，其位置关系为：j = i × 2 ；若位于右侧，为： j = i × 2 + 1 方法参考代码public static class ArrayTree&lt;E&gt;{ //初始化数组 private final int totall = 3 * 3 - 1 ; //(height^2-1) private Object[] arraytree ; public ArrayTree(){ this.arraytree = new Object[totall]; } /** * 向树里添加第一个数据 * @param data 添加的数据 */ public void add(E data){ arraytree[1] = data ; } /** * 向树里添加数据 * @param data 添加的数据 * @param index 添加数据的父级的位置 * @param isLeft 是否在左侧 */ public void add(E data , int index , boolean isLeft){ //判断插入位置是否合法 if ( arraytree[index] == null ){ throw new RuntimeException(&quot;插入位置没有父级，不合法。&quot;); } //根据isLeft值赋予x值 int x ; if ( isLeft ){ x = 0; } else { x = 1 ; } //判断是否超出数组范围 if(2 * index + x &gt;= totall){ throw new RuntimeException(&quot;插入位置超出数组范围&quot;); } //在相应位置添加数据 arraytree[ 2 * index + x ] = data ; } /** * 输出 */ public void print(){ System.out.print(&quot;[&quot;); for ( int i = 0 ; i &lt; totall ; i++ ){ if ( i == totall - 1){ System.out.print(arraytree[i]+&quot;]&quot;); }else{ System.out.print(arraytree[i]+&quot;,&quot;); } } System.out.println(); } } ` 主函数测试public static void main(String[] args){ ArrayTree&lt;Integer&gt; arrtr = new ArrayTree&lt;&gt;(); arrtr.add(1); //arrtr.add(4, 2, true); arrtr.add(2, 1, true); arrtr.add(3, 1, false); arrtr.print(); arrtr.add(4, 2, true); arrtr.add(5, 2, false); arrtr.add(6, 3, true); arrtr.add(7, 3, false); arrtr.print(); //arrtr.add(8, 4, true); } 结果[null,1,2,3,null,null,null,null] [null,1,2,3,4,5,6,7] ` 优缺点优点:1、找双亲结点、子结点和兄弟结点容易。2、每个结点的存储空间不大。 缺点：当二叉树的高度和结点比例偏高时，内存利用率偏低，即可能存在大量空内存。 适用于静态数组，并且结点个数已知的完全二叉树或接近完全二叉树的二叉树。 链式存储个人最初的想法结点拥有三个部分：数据域，三个指向父级和左右子级的地址域。 参考方法代码//定义结点 public static class Node&lt;E&gt;{ private E data; private Node&lt;E&gt; fath; private Node&lt;E&gt; sonLeft ; private Node&lt;E&gt; sonRight ; //创建结点 public Node(E data , Node&lt;E&gt; fath , Node&lt;E&gt; sonLeft , Node&lt;E&gt; sonRight){ this.data = data ; this.fath = fath ; this.sonLeft = sonLeft ; this.sonRight = sonRight ; } //初始化结点 public Node(E data){ this(data,null,null,null); } } //用链表创建二叉树 public static class LinkedTree2&lt;E&gt;{ //创建并初始化头结点 private class Header{ private Node&lt;E&gt; next; public Header(Node&lt;E&gt; next){ this.next = next ; } } //创建二叉树 private Header header ; public LinkedTree2(){ header = new Header(null); } /** * 新增或更改第一个结点 * @param firNode 结点 */ public void addfir(Node&lt;E&gt; firNode){ //新增第一个结点 if(header.next == null){ header.next = firNode; //更改第一个结点 }else{ header.next.data = firNode.data ; } } /** * 添加结点 * @param node 添加的结点 * @param fath 父级结点 * @param isLeft 是否在左侧 */ public void add(Node&lt;E&gt; node , Node&lt;E&gt; fath , boolean isLeft){ node.fath = fath ; if(isLeft){ fath.sonLeft = node ; }else{ fath.sonRight = node ; } } } /** * 输出结点 * @param Node 需输出的结点 */ public static void printNode(Node&lt;Integer&gt; Node){ System.out.print(&quot;结点数据&quot;+Node.data); if (Node.fath != null) System.out.print(&quot;,父级为&quot;+Node.fath.data); if (Node.sonLeft != null) System.out.print(&quot;,左子级为&quot;+Node.sonLeft.data); if (Node.sonRight != null) System.out.print(&quot;,右子级为&quot;+Node.sonRight.data); System.out.println(); } ` 主函数测试public static void main(String[] args){ LinkedTree2&lt;Integer&gt; litree = new LinkedTree2&lt;&gt;(); Node&lt;Integer&gt; A = new Node&lt;&gt;(1); litree.addfir(A); printNode(A); Node&lt;Integer&gt; A1 = new Node&lt;&gt;(10); litree.addfir(A1); printNode(A1); Node&lt;Integer&gt; B = new Node&lt;&gt;(2); litree.add(B, A, true); Node&lt;Integer&gt; C = new Node&lt;&gt;(3); litree.add(C, A, false); printNode(A); printNode(B); printNode(C); Node&lt;Integer&gt; D = new Node&lt;&gt;(4); litree.add(D, B, true); Node&lt;Integer&gt; E = new Node&lt;&gt;(5); litree.add(E, B, false); printNode(D); Node&lt;Integer&gt; G = new Node&lt;&gt;(7); litree.add(G, C, false); printNode(C); } 结果结点数据1 结点数据10 结点数据10,左子级为2,右子级为3 结点数据2,父级为10 结点数据3,父级为10 结点数据4,父级为2 结点数据3,父级为10,右子级为7 参考方法代码//定义结点 public static class BTNode&lt;E&gt;{ private E data; private BTNode&lt;E&gt; sonLeft ; private BTNode&lt;E&gt; sonRight ; //创建结点 public BTNode(E data , BTNode&lt;E&gt; sonLeft , BTNode&lt;E&gt; sonRight){ this.data = data ; this.sonLeft = sonLeft ; this.sonRight = sonRight ; } //初始化结点 public BTNode(E data){ this(data,null,null); } } //二叉树的链表实现 public static class LinkedBTree&lt;E&gt; { //根结点 BTNode&lt;E&gt; root; public LinkedBTree(E data) { root = new BTNode&lt;E&gt;(data); } /** * 为指定结点添加子结点 * @param parent 需要添加节点的双亲结点的索引值 * @param data 新结点数据 * @param isLeft 是否添加左孩子 * @return 新增结点 */ public BTNode&lt;E&gt; add(BTNode&lt;E&gt; parent, E data, boolean isLeft) { if(parent == null) throw new RuntimeException(parent+&quot;结点为空，不能添加子结点!&quot;); BTNode&lt;E&gt; newNode = new BTNode&lt;&gt;(data); if (isLeft) { parent.sonLeft = newNode; } else { parent.sonRight = newNode; } return newNode; } public void printChild(BTNode&lt;E&gt; parent) { System.out.println(&quot;结点&quot; + getString(parent) + &quot;的孩子结点为：&quot; + getString(parent.sonLeft) + &quot;和&quot; + getString(parent.sonRight)); } private Object getString(BTNode&lt;E&gt; node) { if (node == null) { return &quot;空&quot;; } else { return node.data; } } } ` 主函数测试public static void main(String[] args){ LinkedBTree&lt;Character&gt; linkedBTree = new LinkedBTree&lt;&gt;(&#39;A&#39;); BTNode&lt;Character&gt; nodeB = linkedBTree.add(linkedBTree.root, &#39;B&#39;,true); BTNode&lt;Character&gt; nodeC = linkedBTree.add(linkedBTree.root, &#39;C&#39;,false); BTNode&lt;Character&gt; nodeD = linkedBTree.add(nodeB, &#39;D&#39;, true); BTNode&lt;Character&gt; nodeE = linkedBTree.add(nodeB, &#39;E&#39;, false); BTNode&lt;Character&gt; nodeF = linkedBTree.add(nodeC, &#39;F&#39;, false); BTNode&lt;Character&gt; nodeG = linkedBTree.add(nodeE, &#39;G&#39;, true); // 测试，输出某个结点的孩子结点 linkedBTree.printChild(nodeF); } ` 结果结点F的孩子结点为：空和空 特点找儿子容易,找双亲结点难。（可用三叉列表） 一般来说，适用于任何的二叉树。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（7）——数组","slug":"数据结构笔记7","date":"2020-04-03T01:45:00.000Z","updated":"2020-04-07T09:21:14.863Z","comments":true,"path":"2020/04/03/数据结构笔记7/","link":"","permalink":"/2020/04/03/数据结构笔记7/","excerpt":"","text":"定义数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 特点数组是相同类型数据元素的有限集合。数组中的各个分量称为数组元素。每个数组元素值可以用数组名和一个下标值唯一的确定。 由于数组中各元素具有统一的类型，并且数组元素的下标一般具有固定的上界和下界，因此，数组的处理比其它复杂的结构更为简单。多维数组是向量的推广。 数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。 数组的顺序存储结构数组元素是连续存放的，因此采用顺序存储结构。无论几维数组,在计算机中都是按一维数组来存放。 假定存在一个二维数组A m×n （m行n列） ，L是每个元素所占的存储单元。按行优先顺序存储结构：LOC(a ij)=LOC(a 00)+(i×n+j)×L按列优先顺序存储结构：LOC(a ij)=LOC(a 00)+(j×m+i)×L 假定存在一个三维数组A m×n×p （m页n行p列），L是每个元素所占的存储单元。 数组的压缩存储相同值的多个元素占用一个存储单元，零元素不分配存储单元。以下例子的每个元素存储大小为1。 对称矩阵按行优先顺序存放对称矩阵的存储 示例矩阵 在计算机中存储形式 每个元素存储位置 三角矩阵以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵的下三角(不包括主对角线)中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。大多数情况下，常数为0。 下三角矩阵按行优先顺序存放下三角矩阵的存储。 示例矩阵 在计算机中存储形式 每个元素存储位置 上三角矩阵按行优先顺序存放上三角矩阵的存储 示例矩阵 在计算机中存储形式 每个元素存储位置 带状矩阵对角矩阵中，所有的非零元素集中在以主对角线为中心的带状区域中，即除了主对角线和主对角线相邻两侧的若干条对角线上的元素之外，其余元素皆为零。 按行优先顺序存放带状矩阵的存储。 示例矩阵 在 a ij 之前有 i 行，共有 （3×i-1）个非零元素，在第 i 行，有（j-i+1）个非零元素。这样，非零元素 a ij 的地址为： k=3×i-1+(j-i+1)=2i+j 稀疏矩阵稀疏矩阵中有s个非零元素，且s远远小于矩阵元素的总数（即s≦m×n）。 示例矩阵 在计算机中存储形式","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（6）——队列","slug":"数据结构笔记6","date":"2020-03-31T01:45:00.000Z","updated":"2020-04-02T02:08:51.384Z","comments":true,"path":"2020/03/31/数据结构笔记6/","link":"","permalink":"/2020/03/31/数据结构笔记6/","excerpt":"","text":"概念、特性队列是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。 允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。 特性：先进先出。 关于队列满、空的三种判断方法由于用数组创建的非循环队列会出现“假溢出”的问题——即一方面队列为空，另一方面出现溢出，所以之后以循环队列为例。 判断空和满的举例仅作参考。毕竟参考代码用的是最简单的计数。 使用计数器记录队列中的元素个数。 判断满：count&gt;0 &amp;&amp; rear==front 判断空：count==0 假设标志，出队时置为0，入队时置为1，则可识别当前front=rear属于何种情况 判断满：tag==1 &amp;&amp; rear==front 判断空：tag==0 &amp;&amp; rear==front 少用一个存储单元 判断满：front==(rear+1)%size 判断空：rear==front 用数组创建队列参考代码以循环队列为例。 方法参考代码//用数组创建队列 public static class QueueArray&lt;E&gt;{ //设定队列，队的容量，前端和后端，元素数量。 //前端为队头元素位置，后端下标为队尾元素后一个位置。 private int size = 5 ; private Object[] que_arr ; private int front ; private int rear ; private int count ; //初始化队列 public QueueArray(){ que_arr =new Object [size] ; this.front = 0 ; this.rear = 0 ; this.count = 0; } /** * 入队 * @param data */ public void In(E data){ //判断是否队满 if (count == size){ throw new RuntimeException(&quot;队满&quot;); } //添加数据，元素总数+1 que_arr[rear] = data ; ++count; //队尾标号的后移 if (rear+1 &gt;= size){ rear = 0; }else{ ++rear; } } /** * 出队 * @return 队头的元素 */ public Object Out(){ //判断是否队空 if (count == 0){ throw new RuntimeException(&quot;队空&quot;); } //数据的输出和清空 Object data = que_arr[front]; que_arr[front] = null ; //元素总数-1 --count; //队首标号的后移 if (front+1 &gt;= size){ front = 0; }else{ ++front; } return data; } /** * 打印 */ public void print(){ System.out.print(&quot;[&quot;); for (int i = 0 ; i&lt;size ; i++){ if (i == size-1){ System.out.print(que_arr[size-1]+&quot;]&quot;); }else{ System.out.print(que_arr[i]+&quot;,&quot;); } } System.out.println(&quot;count:&quot;+count+&quot; front:&quot;+front+&quot; rear:&quot;+rear); } } 主函数测试 //主函数测试 public static void main(String[] args){ QueueArray&lt;Object&gt; queue = new QueueArray&lt;&gt;(); //queue.Out(); queue.In(1); queue.In(2); queue.In(3); queue.print(); queue.Out(); queue.print(); queue.In(4); queue.In(5); queue.In(6); //queue.In(7); queue.print(); queue.Out(); queue.Out(); queue.Out(); queue.print(); queue.In(7); queue.Out(); queue.Out(); queue.print(); } ` 输出结果 用链表创建队列参考代码以循环队列为例。 但目前还没有感觉到循环和不循环各有什么优势。 方法参考代码//用链表创建队列 public static class QueueLinked&lt;E&gt;{ private int size; private Node header; //创建指向链表末端结点的指针 Node p; //初始化链表 public QueueLinked(){ header = new Node(); size = 0 ; p = header; } //创建结点 public class Node{ //创建数据域和地址域 private E data; private Node next; //构建方法使结点元素的改变 public Node(E data,Node next){ this.data = data; this.next = next; } //初始化结点 public Node(){ this(null,null); } } /** * 入队 * @param data 需要入队的数据 */ public void In(E data){ //创建结点 Node newnode = new Node(); //赋予数据 newnode.data = data; //将结点添加到当前链表末端之后 p.next = newnode; //p指向新结点，其地址域指向队首 p = newnode; newnode.next = header.next; //结点数+1 ++size; } public E Out(){ //判断队列是否为空 if (size == 0){ throw new RuntimeException(&quot;队空&quot;); } //创建指针指向删除的结点 Node del = header.next; //队首数据输出 E data = del.data; //删除队首结点 //如果队列中只有一个结点，头结点地址域null if (size == 1){ header.next = null ; //否则头结点地址域指向第二个结点 }else{ header.next = del.next; } //队尾地址域指向新队首 p.next = header.next; //将删除的结点清空 del.data = null ; del.next = null ; //总数-1 --size; //返回队首数据 return data; } /** * 打印 */ public void print(){ Node q = header.next; for (int i = 0 ; i&lt;size ; i++){ if (i == size-1){ System.out.print(q.data); }else{ System.out.print(q.data+&quot;,&quot;); q = q.next; } } System.out.println(&quot;——size:&quot;+size+&quot; ; p.next:&quot;+p.next.data); } } 主函数测试//主函数测试 public static void main(String[] args){ QueueLinked&lt;Object&gt; queue2 = new QueueLinked&lt;&gt;(); //queue2.Out(); queue2.In(1); queue2.In(2); queue2.In(3); queue2.print(); queue2.Out(); queue2.Out(); queue2.print(); } ` 输出结果","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（5）——栈应用","slug":"数据结构笔记5","date":"2020-03-24T01:45:00.000Z","updated":"2020-03-31T13:57:57.263Z","comments":true,"path":"2020/03/24/数据结构笔记5/","link":"","permalink":"/2020/03/24/数据结构笔记5/","excerpt":"","text":"表达式括号匹配利用栈判断表达式中括号是否匹配，但这只能判断括号的数目正确，像是“1+(2+3(4/)5)”这类就无法判断。 其实这类问题可以不用栈，直接通过数左括号和右括号的数目来判断。 表达式求值这里有三种表达式：前缀表达式（波兰表达式）、中缀表达式、后缀表达式（逆波兰表达式）。 中缀表达式就是生活中常见的表达式，如：1+2*3 由于中缀表达式对于人能较好理解，但对于计算机来讲难以处理，而后缀表达式则容易处理。后缀表达式如：123*+ 前缀表达式相较于后缀来说，用得就少了些，如：+1*23 部分参考思路关于中缀转后缀表达式，以及后缀表达式的计算，这位大神的文章已经讲得很详细了。 链接在此 中缀转后缀表达式这里就只列出中缀转后缀的代码的参考，首先是因为似乎用的比较多，其次其他的转换可以根据此推出，毕竟转换的思路前辈们都已帮我们确定了下来。 关于java.util.Stack之前找到java有关于栈的类，所以参考代码就直接引用。 实际上这个类存在许多问题，毕竟这是Vector动态数组的子类，但用在这里是没什么大问题。 Stack类是Vector的一个子类，它实现了一个标准的后进先出的栈。 以下为参考函数中使用的类中带有的方法。 boolean empty()检测堆栈是否为空。 Object peek()查看堆栈顶部的对象，但不从堆栈中移除它。 Object pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 Object push(Object element)把项压入堆栈顶部。 参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 导入的类 import java.util.Stack; import java.util.ArrayList; //输入 import java.util.Arrays; import java.util.Scanner; ` 中缀转后缀表达式代码 /** * 中缀表达式转化为后缀表达式 * @param infix 中缀表达式列表 * @return 后缀表达式列表 */ public static ArrayList&lt;String&gt; InfixToSuffix(ArrayList&lt;String&gt; infix){ //创建后缀表达式表 ArrayList&lt;String&gt; suffix = new ArrayList&lt;String&gt;(); //创建符号栈 Stack&lt;String&gt; operator = new Stack&lt;&gt;(); //对原中缀表达式进行循环 for (int i = 0 ; i &lt; infix.size() ; i++){ String item = infix.get(i); //如果是数字，直接入表 if (isNum(item)){ suffix.add(item); //如果是括号 }else if (&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item)){ //如果为（，直接入栈 if (&quot;(&quot;.equals(item)){ operator.push(item); //如果是），从栈顶依次向下出栈入表，直到遇到（ }else{ while (true){ //遇到（，只出栈，并跳出循环 if(&quot;(&quot;.equals(operator.peek())){ operator.pop(); break; //遇到其他符号，出栈入表 }else{ suffix.add(operator.pop()); } } } //如果遇到操作符 }else{ //如果栈为空栈，或当前符号权重大于前一个，入栈 if(operator.isEmpty() || heavy(item) &gt; heavy(operator.peek())){ operator.push(item); //若当前符号权重小于前一个，循环元素出栈入表，直至空栈，或遇到权重更小的操作符或（ }else{ while (!operator.isEmpty() &amp;&amp; !&quot;(&quot;.equals(operator.peek())){ if(heavy(item) &lt;= heavy(operator.peek())){ suffix.add(operator.pop()); } } //当前操作符压栈 operator.push(item); } } } //如果最后一个是括号，会导致输出结果多出空的字符串 for (int i = 0 ; i&lt;suffix.size() ; i++){ if (&quot;&quot;.equals(suffix.get(i))){ suffix.remove(i); } } //循环完毕，若栈不为空，依次出栈入表。 while (!operator.isEmpty()){ suffix.add(operator.pop()); } return suffix; } /** * 符号权重 * @param item 符号 * @return 权重int */ private static int heavy(String item) { int heavy; if (&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item) ){ heavy = 0 ; }else if(&quot;+&quot;.equals(item) || &quot;-&quot;.equals(item)){ heavy = 1 ; }else if(&quot;*&quot;.equals(item) || &quot;/&quot;.equals(item)){ heavy = 2; }else{ throw new IndexOutOfBoundsException (&quot;存在没有设置权重的字符&quot;); } return heavy; } /** * 判断字符串是否为数字 * @param str 需判断的字符串 * @return true/false */ public static boolean isNum(String str){ for (int i = 0 ; i&lt;str.length() ; i++){ if (!Character.isDigit(str.charAt(0))){ return false; } } return true; } /** * 字符串转化为ArrayList * @param str 需转换的字符串 * @return ArrayList */ public static ArrayList&lt;String&gt; StringToList(String str){ //创建列表 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); String digit = &quot;&quot;; //对字符串进行循环 for (int i = 0 ; i &lt; str.length() ; i++){ //储存当前循环的字符 String item = String.valueOf(str.charAt(i)); //如果是数字或小数点，储存到digit中 if (isNum(item) || &quot;.&quot;.equals(item)){ digit+=String.valueOf(item); //如果是符号 }else if(&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item) || &quot;+&quot;.equals(item) || &quot;-&quot;.equals(item) || &quot;*&quot;.equals(item) || &quot;/&quot;.equals(item)) { //如果是第一个，即（，直接入表 if (i==0){ list.add(String.valueOf(item)); //否则将前一个数字入表，随后符号入表 }else{ if (!&quot;&quot;.equals(digit)){ list.add(digit); digit = &quot;&quot;; } list.add(String.valueOf(item)); } }else{ throw new IndexOutOfBoundsException (&quot;非法字符&quot;); } } //循环完毕，若还有储存的数字，入表。 list.add(String.valueOf(digit)); return list; } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); ArrayList&lt;String&gt; suffix = InfixToSuffix(infix); System.out.print(&quot;中缀转化后缀为：&quot;); for (int i = 0 ; i &lt; suffix.size() ; i++){ if (i == suffix.size()-1){ System.out.print(suffix.get(i)); continue; } System.out.print(suffix.get(i)+&quot;,&quot;); } System.out.println(); } 后缀表达式计算参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 /** * 根据后缀表达式suffix计算结果 * @param suffix 后缀表达式列表 * @return 结果 */ private static Double calculate(ArrayList&lt;String&gt; suffix) { //创建数字栈 Stack&lt;String&gt; number = new Stack&lt;&gt;(); //对列表中元素进行循环 for(int i=0; i&lt;suffix.size(); i++){ String item = suffix.get(i); //如果是数字，入栈 if(isNum(item)){ number.push(item); //如果是符号，取栈顶两个元素，运算后入栈 }else { //String → double double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); double result = 0; if(item.equals(&quot;+&quot;)){ result = num1 + num2; }else if(item.equals(&quot;-&quot;)){ result = num1 - num2; }else if(item.equals(&quot;*&quot;)){ result = num1 * num2; }else if(item.equals(&quot;/&quot;)){ result = num1 / num2; }else { throw new RuntimeException(&quot;非法符号&quot;); } //double → String number.push(String.valueOf(result)); } } //返回计算结果 return Double.parseDouble(number.pop()); } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); ArrayList&lt;String&gt; suffix = InfixToSuffix(infix); System.out.print(&quot;最终结果：&quot;+orgexp+&quot;=&quot;+calculate(suffix)); } 中缀表达式计算参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 /** * 两个数字之间的运算 * @param x1 数字1 * @param x2 数字2 * @param item 运算符号 * @return 结果 */ private static double calculate(double x1,double x2,String item){ //定义结果 double result ; //根据运算符对两个数字进行运算 if (item.equals(&quot;+&quot;)){ result = x1+x2; }else if (item.equals(&quot;-&quot;)){ result = x1-x2; }else if (item.equals(&quot;*&quot;)){ result = x1*x2; }else if (item.equals(&quot;/&quot;)){ result = x1/x2; }else{ throw new IndexOutOfBoundsException (&quot;表达式非法&quot;); } //返回 return result; } /** * 中缀表达式的运算 * @param infix 中缀表达式的列表 * @return 结果 */ public static double InFixOperation(ArrayList&lt;String&gt; infix){ //定义数字和操作符的栈 Stack&lt;String&gt; number = new Stack&lt;&gt;(); Stack&lt;String&gt; operator = new Stack&lt;&gt;(); //对中缀表达式进行循环 for (int i = 0 ; i&lt;infix.size() ; i++){ //当前循环的符号 String item = infix.get(i); //如果是数字，直接入数字栈 if (isNum(item)){ number.push(item); //否则就是操作符 }else{ //如果是），将前面的数字和符号依次从后往前运算，直至（，并将结果入数字栈 if (&quot;)&quot;.equals(item)){ while (!operator.peek().equals(&quot;(&quot;)){ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); } operator.pop(); //如果是（，或操作栈为空，或当前运算符权重大于前者，直接入操作符栈 }else if (&quot;(&quot;.equals(item) || operator.isEmpty() || heavy(item)&gt;heavy(operator.peek()) ){ operator.push(item); //否则，将前两个数字进行符号运算，结果入数字栈，操作符入操作栈 }else{ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); operator.push(item); } } } //循环完毕，若符号栈不为空，则从后往前运算，并将结果入数字栈 if (!operator.isEmpty()){ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); } //返回结果 return Double.parseDouble(number.pop()); } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); System.out.print(&quot;最终结果：&quot;+orgexp+&quot;=&quot;+InFixOperation(infix)); }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（3.5）——双向链表","slug":"数据结构笔记3.5","date":"2020-03-20T01:45:00.000Z","updated":"2020-04-12T03:32:59.358Z","comments":true,"path":"2020/03/20/数据结构笔记3.5/","link":"","permalink":"/2020/03/20/数据结构笔记3.5/","excerpt":"","text":"总体思路与单向链表类似，直接给出参考代码。 注：参考代码中各个算法均包含在类中. 单链表部分算法 链表定义//创建链表 public static class DouLinkedList&lt;E&gt; { //链表结点数据类型定义 public class Node{ //数据域，保存数据元素 public E data; //地址域，保存前后结点地址 public Node next; public Node pre; //构造结点，指定数据元素和后继结点 public Node(E data, Node next , Node pre){ this.data = data; this.next = next; this.pre = pre; } //初始化结点 public Node() { this(null,null,null); } } //链表大小 private int num = 0; //链表头结点 Node header; public DouLinkedList() { header = new Node(); } /**查找指定位置结点 * * @param n 位置 * @return 结点 */ private Node findNode(int n) { Node p = header; for (int i = 1; i &lt;= n; ++i) { p = p.next; } return p; } /** 代码6：打印顺序表 * **/ public void print() { System.out.print(&quot;顺序表长度为:&quot;+num+&quot;,内部元素为:&quot;); Node p = header; for (int i = 0; i &lt; num; i++){ p = p.next; System.out.print(p.data + &quot; &quot;); } System.out.println(); } } 插入算法 /**判断插入位置是否合法 * * @param n 插入位置 */ private void Check(int n) { if (n &lt;= 0 || n &gt; num+1) { throw new IndexOutOfBoundsException (&quot;插入位置不合法！&quot;); } } /**在链表头部插入 * * @param data 插入数据 */ public void addFirst(E data) { //如果是空表 if (num == 0){ addLast(data); return; } //创建一个新结点 Node newNode = new Node(); //将新结点和原结点的next和pre域指向相应结点 newNode.next = header.next; header.next.pre = newNode; header.next = newNode; //输入数据 newNode.data = data; //长度+1 ++num; } /**在链表尾部插入 * * @param data 插入数据 */ public void addLast(E data) { //创建一个新结点 Node newNode = new Node(); //找到最后一个结点p Node p = findNode(num); //各地址域指向相应结点 p.next = newNode; newNode.pre = p; //输入数据 newNode.data = data; //链表长度+1 ++num; } /** 在链表指定 n位置前插入结点 * * @param n 插入位置，从1计数 * @param data 插入元素 **/ public void add(int n, E data) { //判断插入位置是否合法 Check(n); if (n == 1) { addFirst(data); return; } if (n == num+1) { addLast(data); return; } //创建一个新结点 Node newNode = new Node(); //找到插入位置n前后的结点p,q Node p = findNode(n-1); Node q = findNode(n); //地址域指向相应 p.next = newNode; newNode.pre = p; newNode.next = q; q.pre = newNode; //输入数据 newNode.data = data; //链表长度+1 ++num; } 删除算法/** 删除链表第一个结点 * */ public void removeFirst() { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } //如果只有一个结点 if (num==1){ removeLast(); return; } //取得第一个结点p Node p = header.next; //相应地址域的改变 p.next.pre = null; header.next = p.next; p.next = null; p.pre = null; //链表长度-1 --num; } /**删除链表尾元素 * */ public void removeLast() { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空!&quot;); } //取得倒数第二个结点p,以及最后一个结点q Node p = findNode(num - 1); Node q = p.next; //相应地址域的改变 p.next = null; q.pre = null; //长度-1 --num; } /** 删除链表指定位置的结点 * * @param n 删除位置 **/ public void remove(int n) { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } //判断删除位置是否合法 CheckForRemove(n); if (n == 0) { removeFirst(); return; } if (n == num) { removeLast(); return; } //找到删除位置n前后的结点p、r，以及删除位置index的结点q Node p = findNode(n-1); Node q = p.next; Node r = q.next; //相应地址域改变 p.next = r; r.pre = p; q.next = null; q.pre = null; //链表长度-1 --num; } /** 判断删除位置是否合法 * * @param n 删除位置 **/ private void CheckForRemove(int n) { if (n &lt;= 0 || n &gt; num) { throw new IndexOutOfBoundsException(&quot;删除位置不合法！&quot;); } } 主函数测试public static void main(String[] args) { DouLinkedList&lt;Integer&gt; linkedList = new DouLinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); // 删除第一个元素 linkedList.removeFirst(); linkedList.print(); // 在链表中间删除元素 linkedList.remove(3); linkedList.print(); // 删除最后一个元素 linkedList.removeLast(); linkedList.print(); }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（4）——栈","slug":"数据结构笔记4","date":"2020-03-17T01:45:00.000Z","updated":"2020-03-31T13:55:57.093Z","comments":true,"path":"2020/03/17/数据结构笔记4/","link":"","permalink":"/2020/03/17/数据结构笔记4/","excerpt":"","text":"栈的相关概念➢栈：限定仅在表尾进行插入或删除操作的线性表。 ➢栈的特点：先进后出（FILO）或后进先出（LIFO）。 ➢栈的举例：子程序的嵌套、阶乘问题（递归问题）。 栈的操作注：参考代码中各个算法均包含在类中. 利用数组创建栈定义栈/**用数组创建栈 */ public static class Stack&lt;E&gt; { //初始化栈的最大容量为100 private static final int totall = 100; private Object[] datas; //n记录目前堆栈数据数量的变量 private int n; //初始化堆栈 public Stack() { this.n = 0; this.datas = new Object[totall]; } //打印链表 public void print(){ System.out.print(&quot;n=&quot;+n+&quot; 元素依次为：&quot;); for (int i = 0; i &lt;= n-1; i++){ System.out.print(datas[i]+&quot; &quot;); } System.out.println(); } } 入栈 /** 入栈 * @param data 入栈元素 **/ public void In(E data) { // 判断栈是否满 if (n == totall) { throw new RuntimeException(&quot;栈满，无法插入新元素!&quot;); } datas[n] = data; n++; } /**在栈底部增加 * * @param data 增加的数据 */ public void ButtonIn(E data){ //判断是否为空栈 if(this.n==0){ this.In(data); return; } // 判断栈是否满 if (this.n == totall) { throw new RuntimeException(&quot;栈满，无法插入新元素!&quot;); } //创建一个新过渡栈和过渡数据 Stack&lt;E&gt; stack1 =new Stack&lt;&gt;(); E data1; //取得增加前栈的数据数量 int n = this.n; //依次将原始栈中元素增加到过渡栈中 for(int i=0;i&lt;n;i++){ data1 = this.Out(); stack1.In(data1); } //此时原始栈为空，在原始栈增加data this.In(data); //将过渡栈中的数据增加到原始栈中 for(int i = 0; i&lt;n; i++){ data1 =(E) stack1.Out(); this.In(data1); } } ` 出栈/** 出栈 * * @return 返回栈顶元素 * **/ public E Out() { // 判断栈是否为空 if (n==0) { throw new RuntimeException(&quot;出栈顶失败，因为此时栈中没有元素！&quot;); } E topdata = (E) datas[n-1]; n--; return topdata; } /** 删除栈的底部元素 * */ public void ButtonOut(){ //判断是否为空栈 if(this.n==0){ throw new RuntimeException(&quot;出栈顶失败，因为此时栈中没有元素！&quot;); } // 判断栈是否只有一个元素 if (n == 1) { this.Out(); return; } //创建一个新过渡栈和过渡数据 Stack&lt;E&gt; stack1 =new Stack&lt;&gt;(); E data1; //取得减少前栈的数据数量 int n = this.n-1; //依次将原始栈中元素增加到过渡栈中 for(int i=0;i&lt;n;i++){ data1 = this.Out(); stack1.In(data1); } //此时原始栈只有一个元素，删除 this.Out(); //将过渡栈中的数据增加到原始栈中 for(int i = 0; i&lt;n; i++){ data1 =(E) stack1.Out(); this.In(data1); } } 主函数测试public static void main(String[] args){ Stack&lt;Integer&gt; stack =new Stack&lt;&gt;(); stack.In(4); stack.In(5); stack.In(6); stack.In(7); stack.In(8); stack.In(7); stack.In(6); stack.print(); Object x=stack.Out(); stack.print(); stack.ButtonIn(9); stack.print(); stack.ButtonOut(); stack.print(); } 利用链表创建栈定义栈//用链表创建栈 public static class Stuck&lt;E&gt;{ //创建结点 public class Node{ //创建结点的数据域和地址域 public E data; public E next; //添加方法修改结点 public Node(E data,E next){ this.data = data; this.next = next; } //初始化结点 public Node(){ this(null,null); } } //初始栈的大小 private final int totall = 100; //初始化当前栈占用的大小 private int num = 0; //创建头结点 Node header; //创建新栈 public Stuck(){ header = new Node(); } /** 查找指定位置的结点 * * @param n 查找位置 * @return 该位置结点 */ public Node FindNode(int n){ //创建新结点 Node thenode = header; //循环查找 for (int i = 0 ; i&lt;n ; i++){ thenode = (Stuck&lt;E&gt;.Node) thenode.next; } //返回 return thenode; } //打印 public void print(){ System.out.print(&quot;栈中数据数目num=&quot;+num+&quot; 分别为：&quot;); Node p = (Stuck&lt;E&gt;.Node) header.next; for (int i = 1 ; i &lt;= num ; i++){ System.out.print(p.data+&quot; &quot;); p = (Stuck&lt;E&gt;.Node) p.next; } System.out.println(); } } 入栈/** 在栈顶部添加数据 * * @param data 添加的数据 */ public void In(E data){ //检查是否栈满 if (num == totall-1){ throw new IndexOutOfBoundsException (&quot;栈满。&quot;); } //创建一个新结点 Node node = new Node(); //输入数据 node.data = data; //找到当前顶部结点 Node topnode = FindNode(num); //将顶部结点的next指向新结点 topnode.next = (E) node; //数目+1 ++num; } /** 在栈底部添加数据 * * @param data 添加的数据 */ public void InButtom(E data){ //检查是否栈满 if (num == totall-1){ throw new IndexOutOfBoundsException (&quot;栈满。&quot;); } //检查是否空栈 if (num == 0){ this.In(data); return; } //创建一个新结点 Node node = new Node(); //输入数据 node.data = data; //创建一个过渡栈 Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); //用循环将当前栈里元素移动到过渡栈中 int n = num; for (int i = 1 ; i&lt;=n ; i++){ stuck.In((Integer) this.Out()); } //此时原栈为空，增加新数据 this.In(data); //用循环将过渡栈里数据返回 for (int i = 1 ; i&lt;=n ; i++){ this.In((E) stuck.Out());; } } 出栈/**删除顶部数据 * * @return 顶部数据 */ public E Out(){ //判断是否为空 if (num == 0){ throw new IndexOutOfBoundsException (&quot;栈空。&quot;); } //找到顶端的两个结点 Node p = FindNode(num); Node q = FindNode(num-1); //将顶部的结点数据赋给其他变量，并删除 E data = p.data; p.data = null; //将第二顶端的结点地址域指向null q.next = null; //数目-1 --num; //返回删除数据 return data; } /** 在栈底部删除数据 * * @return 删除的数据 */ public E OutButtom(){ //检查是否空栈 if (num == 0){ throw new IndexOutOfBoundsException (&quot;栈空。&quot;); } //检查是否只有一个数据 if (num == 1){ return this.Out(); } //创建一个过渡栈 Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); //用循环将当前栈里元素移动到过渡栈中 int n = num-1; for (int i = 1 ; i&lt;=n ; i++){ stuck.In((Integer) this.Out()); } //此时原栈只有一个数据，删除数据 E data = this.Out(); //用循环将过渡栈里数据返回 for (int i = 1 ; i&lt;=n ; i++){ this.In((E) stuck.Out());; } //返回 return data; } 主函数测试public static void main(String[] args){ Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); stuck.In(1); stuck.In(2); stuck.In(3); stuck.In(4); stuck.print(); stuck.Out(); stuck.print(); stuck.InButtom(0); stuck.print(); Object x = stuck.OutButtom(); System.out.println(x); stuck.print(); } 两栈共享对两栈共享情况来说，将两个栈底分别设在两端， 两个栈顶指针 top1 和 top2 相对中间位置动态移动，两个栈之间的分界线是不定的。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（3）——线性表链式储存结构","slug":"数据结构笔记3","date":"2020-03-10T01:45:00.000Z","updated":"2020-04-12T03:30:20.330Z","comments":true,"path":"2020/03/10/数据结构笔记3/","link":"","permalink":"/2020/03/10/数据结构笔记3/","excerpt":"","text":"相关概念结点：数据元素的存储映像。由数据域和地址域两部分组成。➢ 数据域：元素本身信息➢ 地址域：指示直接后继的存储位置 链表：n个结点由地址域组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。➢ 链表种类：单链表、双链表、多链表、循环链表。 有关头结点的作用：为了对链表进行操作时，可以对空表、非空表的情况以及对首元素节点进行统一处理，编程更方便。 特点1、用一组任意的存储单元存储线性表的数据元素，易插入和删除。2、利用指针实现了用不相邻的存储单元存放逻辑上相邻的元素。3、存储结构较复杂，每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息结点。4、不需要预先分配空间。 适用于：频繁需要插入、删除数据的线性表。 单链表算法注：参考代码中各个算法均包含在类中. 插入算法总体参考思路首先定义一个单链表，在单链表中定义结点，结点包括两个属性：数据和地址，再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义六个函数。 判断插入位置是否合法 rangeCheckForAdd(int index) 头部增加元素 addFirst(E data) 在指定位置增加元素 add(int index, E data) 尾部增加元素 addLast(E data) 查找指定位置前的元素 findNode(int index) 打印链表 print() 代码参考 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node header; public LinkedList() { header = new Node(); } //单链表结点数据类型定义 public class Node{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node next; //构造结点，指定数据元素和后继结点 public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(null,null); } } /** 代码3： 在链表中间指定 index 位置前插入结点 * @param index 插入位置，从0计数 * @param data 插入元素 **/ public void add(int index, E data) { // 1. 判断插入位置是否合法 rangeCheckForAdd(index); if (index == 0) { addFirst(data); return; } if (index == size) { addLast(data); return; } // 2. 创建一个新结点 Node newNode = new Node(); // 3. 找到插入位置index前的结点p Node p = findNode(index); // 4. 将新结点的next域指向p结点的next域 newNode.next = p.next; // 5. 将p结点的next域指向新结点 p.next = newNode; // 6. 输入数据 newNode.data = data; // 7. 链表长度+1 ++size; } /** 代码2： 在链表头部插入结点 * @param data 插入元素 **/ public void addFirst(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 将新结点的next域指向为header结点的next域 newNode.next = header.next; // 3. 将header结点指向新结点 header.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码4 在链表尾部插入结点 * @param data 插入元素 **/ public void addLast(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 找到最后一个结点q Node q = findNode(size); // 3. 将q结点的next域指向新结点 q.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码1：判断插入位置是否合法 * @param index 插入位置 **/ private void rangeCheckForAdd(int index) { if (index &lt; 0 || index &gt; size) { throw new IndexOutOfBoundsException (&quot;插入位置不合法！&quot;); } } /** 代码5：找到指定位置index前的结点P * @param index 插入位置，从0计数 * @return 指定位置结点 **/ private Node findNode(int index) { Node p = header; for (int i = 0; i &lt; index; ++i) { p = p.next; } return p; } /** 代码6：打印顺序表 * @param index 插入位置，从0计数 * @return 指定位置结点 **/ public void print() { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); Node p = header; for (int i = 0; i &lt; size; i++){ p = p.next; System.out.print(p.data + &quot; &quot;); } System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); } 其他思路同样定义一个单链表，在单链表中定义结点，结点在存储数据的空间中专门拿出一部分储存地址信息，再在单链表类中定义与插入有关的各种方法。 以下给出创建类和内部类的方法，其他方法视情况修改。 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node&lt;E&gt; header; public LinkedList() { header = new Node&lt;&gt;(); } //单链表结点数据类型定义 public class Node&lt;E&gt;{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node&lt;E&gt; next; //构造结点，指定数据元素和后继结点 public Node(E data, Node&lt;E&gt; next){ this.data = data; this.next = next; } public Node() { this(null,null); } } } 删除算法总体参考思路与上文插入算法类似，只是再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义五个函数。 删除头部元素 removeFirst() 删除尾部元素 removeLast() 删除指定位置的元素 remove(int index) 判断删除位置是否合法 rangeCheckForRemove(int index) 打印链表 print() 代码参考 //定义类与上文相同 public class LinkedList&lt;E&gt; { private int size = 0; Node header; public LinkedList() { header = new Node(); } public class Node{ public E data; public Node next; public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(0,null); } } /** 代码1 删除链表第一个结点 **/ public void removeFirst() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 取得第一个结点p Node p = header.next; // 3. 将 header 的 next 域指向p结点的 next域 header.next = p.next; // 4. 将p结点的 next 域设为 null ，回收p内存 p.next = null; // 5. 链表长度- -1 1 --size; } /** 代码2 ：删除链表尾元素 **/ public void removeLast() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空!&quot;); } // 2. 取得倒数第二个结点p,以及最后一个结点q Node p = findNode(size - 1); Node q = p.next; // 3. 将p的next域指向q的next域 p.next = q.next; // 4. 链表长度-1 --size; } /** 代码3：删除链表指定位置的结点 * @param index 删除位置 **/ public void remove(int index) { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 判断删除位置是否合法 rangeCheckForRemove(index); // 3.判断特殊情况 if (index == 0) { removeFirst(); return; } if (index == size - 1) { removeLast(); return; } // 4. 找到删除位置index前的结点p，以及删除位置index的结点q Node p = findNode(index); Node q = p.next; // 5. 将p结点的next域指向q结点的next域 p.next = q.next; // 6. 将q结点的next域设为null，回收q内存 q.next = null; // 7. 链表长度-1 --size; } /** 代码4： 判断删除位置是否合法 * @param index 删除位置 **/ private void rangeCheckForRemove(int index) { if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;删除位置不合法！&quot;); } } /** 代码5：打印顺序表。（同上，略）*/ } 主代码测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); // 删除第一个元素 linkedList.removeFirst(); linkedList.print(); // 在链表中间删除元素 linkedList.remove(3); linkedList.print(); // 删除最后一个元素 linkedList.removeLast(); linkedList.print(); } 插入删除算法的时间复杂度单链表的插入删除算法由两部分构成，第一是查找到第index个结点，第二是插入和删除结点。所以，如果我们不知道第index个结点的具体位置，链式存储与顺序存储的插入、删除算法都是O（n）。 连接算法若现已存在两个链表，需将这两个链表连起来。其中一个算法是直接将其中一个链表的末端接到另一个的首段，不再赘述。 另一个算法为：若已知链表的数据元素按值非递减有序排列，将两表归并为一个新的线性表, 且其中的数据元素仍按值非递减排列。 整体参考思路搜索：需要两个指针搜索两个链表；比较：比较结点数据域中数据的大小；插入：将两个结点中数据，小的结点插入新链表。 参考代码//创建方法Connection public static LinkedList&lt;Integer&gt; Connection(LinkedList&lt;Integer&gt; a, LinkedList&lt;Integer&gt; b){ LinkedList&lt;Integer&gt; c = new LinkedList&lt;&gt;(); //创建指针，并指向第一个结点 LinkedList&lt;Integer&gt;.Node pa=a.header.next; LinkedList&lt;Integer&gt;.Node pb=b.header.next; //比较指针指向结点大小，依次填入单链表c中，直至其中一个单链表全部录完 while (pa != null &amp;&amp; pb != null){ if (pa.data &gt;= pb.data){ c.addLast(pb.data); pb = pb.next; }else { c.addLast(pa.data); pa = pa.next; } } //将录完单链表的另一个依次录入 if (pa==null){ while(pb!=null){ c.addLast(pb.data); pb=pb.next; } }else if(pb==null){ while(pa!=null){ c.addLast(pa.data); pa=pa.next; } } //返回 return c; } 主函数测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedListA =new LinkedList&lt;&gt;(); linkedListA.addLast(3); linkedListA.addLast(5); linkedListA.addLast(8); linkedListA.addLast(11); linkedListA.print(); LinkedList&lt;Integer&gt; linkedListB =new LinkedList&lt;&gt;(); linkedListB.addLast(2); linkedListB.addLast(6); linkedListB.addLast(8); linkedListB.addLast(9); linkedListB.addLast(11); linkedListB.print(); LinkedList&lt;Integer&gt; linkedListC = new LinkedList&lt;&gt;(); linkedListC=Connection(linkedListA,linkedListB); linkedListC.print(); } 单链表应用一元多项式运算 关于其他链表双链表部分算法 其他的链表与单链表类似，地址域有一定改变，其方法也同样有一定改变，这里不再赘述。（其实就是我懒。）","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（2）——线性表及其顺序储存结构","slug":"数据结构笔记2","date":"2020-03-03T01:45:00.000Z","updated":"2020-04-12T03:30:18.851Z","comments":true,"path":"2020/03/03/数据结构笔记2/","link":"","permalink":"/2020/03/03/数据结构笔记2/","excerpt":"","text":"线性表的逻辑结构定义：数据元素之间的关系为一一对应的n个数据元素。 （a0，a1，…，ai-1，ai，ai+1，…，an-1）a0：线性起点ai-1：前趋ai+1：后继an-1：线性终点 均匀性：数据类型相同。有序性：不可交换次序。 内存地址：Loc(i)+L0+i×m（m：每个元素所占用的存储单元个数） 线性表的顺序存储结构及算法特点、优缺点 特点 数据连续存放、随机存取设备。 逻辑上和物理上相邻。 存储结构简单、易实现。 插入、删除操作不便。 存储密度大，空间利用率高。 优点 无需为表示表中元素之间的逻辑关系而增加存储空间。 可以快速取出表中的任一元素。 缺点 插入删除操作需要移动大量元素。 当线性表长度变化较大时难以确定空间容量。 ，需要预先分配空间，且容易造成存储空间的“碎片”。 适用：表中元素变动较少的情况，且拥有连续的存储空间。 插入算法注：参考代码中各个算法均包含在类中. 思路1、判断插入位置是否合法。2、将第n-1至第i个元素后移一个存储位置。3、将要插入的x元素插入到ai-1之后。4、表长度+1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ public static class SequenceList&lt;E&gt;{ //用数组存储顺序表 private Object[] seqList; //顺序表的元素个数 private int size =0; //初始化顺序表 public SequenceList(){ seqList= new Object[1000]; } /** 定义：在顺序表中末尾添加元素函数 add(E element) * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(E element) { seqList[size] = element; ++size; return true; } /** 定义在顺序表某位置插入函数add(int index, E element) * @param index 插入位置 * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(int index, E element) { // 1. 判断插入是否合法 rangeCheckForAdd(index); // 2. 将存储在size-1位置至index位置的元素依次后移一个位置 for (int i = size; i &gt; index; --i) { seqList[i] = seqList[i - 1]; } // 3. 将x插入到index位置 seqList[index] = element; // 4. 表的长度+1 ++size; return true; } /** 定义插入位置是否合法函数 rangeCheckForAdd(int index) * @param index 插入位置*/ private void rangeCheckForAdd (int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(&quot;插入位置不合法！&quot;); } /** 定义打印顺序表函数 print ( ) * 打印顺序表*/ public void print( ) { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); for (int i = 0; i &lt; size; ++i) System.out.print(seqList[i] + &quot; &quot;); System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList=new SequenceList&lt;Integer&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.add(2); seqList.print( ); // 在1位置插入元素7 seqList.add(1, 7); seqList.print( ); } 时间复杂度在有n个元素的顺序表中，插入的位置有n+1个，并且是等可能的。O(n) 删除算法注：参考代码中各个算法均包含在类中. 思路1、判别指定的位置是否合法2、若合法，则将位置i+1至n上的元素前移一个存储位置3、表的长度 -1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ /** 同上 **/ public static class SequenceList&lt;E&gt;{ private Object[] seqList; private int size =0; public SequenceList(){ seqList= new Object[1000]; } /** 定义删除指定位置的元素函数 remove(int index) * @param index 删除位置 */ public void remove(int index) { // 1. 判别指定的位置是否合法 rangeCheckForRemove(index); // 2. 将位置index+1 至 size-1 位置上的元素前移一个位置 for (int i = index+1; i &lt;= size - 1; ++i) { seqList[i-1] = seqList[i]; } // 3. 表的长度-1 --size; } /** 定义删除位置是否合法函数 rangeCheckForRemove(int index) * @param index 删除位置 */ private void rangeCheckForRemove (int index) { if (index &gt;= size || index &lt; 0) throw new IndexOutOfBoundsException (&quot;删除位置不合法！&quot;); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList = new SequenceList&lt;&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.print(); // 在1位置插入元素7 seqList.add(1, 7); seqList.print(); // 删除1位置元素 seqList.remove(1); seqList.print(); } 时间复杂度在有n个元素的顺序表中，可以删除的元素有n个，并且是等可能的。O(n)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"我和碧蓝航线","slug":"碧蓝航线1000天纪念","date":"2020-02-27T08:00:00.000Z","updated":"2020-03-18T12:06:30.174Z","comments":true,"path":"2020/02/27/碧蓝航线1000天纪念/","link":"","permalink":"/2020/02/27/碧蓝航线1000天纪念/","excerpt":"","text":"关于1000天当天那天相当震憾，有必要提一下。 不知道是疫情影响，还是因为正值毛子活动维护，当天就创了上线人数新高，所以这群在群里嘴上说冲的人一开服就把这游戏的服务器冲爆了，本来是下午3点开服，结果拖到了8点才基本解决问题，相当震憾。（人多可以理解，而且炸服补偿到位也就不说什么了） 一些想法其实如果不是这次惊喜和小加加在官博发文，都不知道这游戏已经1000天了，现在碧蓝航线在我taptap上的在线时间是最多的，1200多个小时，虽然大部分也只是在看后勤，打日常，但确实这游戏是我不舍得弃坑的游戏。 其实我实在舰b开服后两三天里在b站上的广告得知的，当时我对这游戏知之甚少，但是对于一名wows玩家，对二战的海军还是挺感兴趣的，并且看到游戏宣传里企业、拉菲和欧根的立绘，尤其是欧根亲王，就感觉这游戏的游戏资源有点东西胸有大痣，就想着下载来玩一下，就玩到今天了。 当时不知道为什么会对这三个角色有特别的偏好，直到现在业界有科学理论来证实这一现象了：“All Chinese love white hair” 因为我对于手游的态度一向是比较佛系的，而且当时我已步入准高三，所以当时并没有花太多时间在碧蓝航线上，即使我经历过第一次夏活，也对舰b并没有太多感受。所以即使游戏当时的口碑爆炸，我也没有什么亲身体会。 我当时脑子抽了，把装备回收箱和情人节礼物给用了，f**k（简洁有力的维多利亚方言） 开始认真对待这游戏的时候已经是高三寒假和下学期了（高三有什么寒假，别问为什么高三还有时间玩游戏），然后才意识到舰b在当时的手游范围内算是比较良心的了，而且碧蓝航线对自己的定位相当准确，高质量的皮肤，较低的抽卡成本，容易获得的高强度角色让人欲罢不能。她就像一个精打细算的商人，让自己赚钱的同时，让我们花钱的同时获得尽可能大的回报。 这live2d皮肤不香吗 碧蓝航线把“All Chinese love white hair”这一（伪）科学理论表现得淋漓尽致，从每年的人气投票就可以看出，这个梗在圈里过于有名，以至于传到了国外，这也可以看出碧蓝航线确实很懂得自己的定位。其实我对哪种立绘的偏爱是在碧蓝航线中才逐渐了解的，也让我真正对“画师”有了浅显的理解。就是喜欢黑兔的立绘 这游戏愿意肝也可以肝，愿意养老也可以，氪金和不氪金的玩家、肝帝和咸鱼玩家、研究党和娱乐党都可以玩的很高兴。 这游戏到后期本质就是一个聊天软件，一群人大多数时间在公屏里讨论除了碧蓝航线的各种话题，据说通过公屏还成了几对。每个人都可以在碧蓝航线里找到自己的老婆。（雾） 个人感觉，在碧蓝圈子里大多数人都是很和谐的，大家在群里吹吹水也十分和谐，这是我这些年来一直在玩碧蓝的原因之一，也让我认识到对海军感兴趣的大多数人是一群精苏玩家。除了第一次夏活难度的不合理，饺子的开火限制解除，某些皮肤过于xx而被举报外并没有什么大的节奏问题，也许这也正是成就碧蓝航线的原因之一。 对于皮肤，我觉得大多数的玩家反而希望这种皮肤越多与好，你还能对一个曾经适龄年龄13岁，之后提到了18+岁的游戏说什么吗。 结尾转眼间，这游戏已经1000天了，再过几个月就要三周年了，虽然因为各种原因国服难以与日服在本子那边的热度难以相比，但依然希望碧蓝在国内能够继续运营下去，毕竟这游戏确实不错。 最后，大舰队什么的。。。 国服玩家只能看本子的生放送获取最新消息，看美服玩家1周年在衣阿华战列舰上开127mm高平炮。 某些图不方便发，p站上搜一大堆。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"《数据结构》笔记（1）——绪论","slug":"数据结构笔记1","date":"2020-02-25T01:45:00.000Z","updated":"2020-03-18T12:06:01.679Z","comments":true,"path":"2020/02/25/数据结构笔记1/","link":"","permalink":"/2020/02/25/数据结构笔记1/","excerpt":"","text":"认识数据结构数值计算：利用数学方程。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;步骤：具体问题→数学模型→算法→编程、调试→得到答案 非数值计算：利用数据结构。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;步骤：问题→抽象出问题的模型→求模型的解&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;类型：线性结构（一对一）；非线性结构【树形结构（一对多）、图形结构（多对多）】&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（注：判断是否为线性结构优先画图，更直观。） 基本概念数据：对信息的一种符号表示。数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。数据项是数据的不可分割的最小单位。数据类型：性质相同的数据元素的组合。（注：数据由数据元素构成，数据元素由数据项构成。数据＞数据元素＞数据项） 数据结构：1、数学概念：S=（D，R）数据和关系的集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、内容概念：逻辑结构+存储结构+算法。（数据逻辑结构独立于计算机，存储结构依赖于计算机，运算定义依赖于逻辑结构，实现依赖于存储结构。） ADT——抽象数据类型，数据↔操作，ADT=（R,S,T）&ensp;&ensp;&ensp;&ensp;定义：1、使用视图：逻辑结构+操作集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、设计视图：存储结构+算法设计&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3、实现视图：成员变量+成员函数 逻辑结构 集合 线性结构 线性表 栈 队列 串级数组 非线性结构 树形结构 图形结构 存储结构 顺序存储方式：存储空间连续。 链式储存方式：存储空间不连续。 索引存储方式：索引表。 散列存储方式：哈希函数。 算法程序=算法+数据结构 定义：有穷规则的集合，规则确定一个解决某一特定类型问题的操作序列。 特征：输入、输出、确定性、有穷性、可行性。 原则：正确性、可读性、健壮性（容错处理）、效率与存储量的需求。 方式：自然语言、流程图、伪代码。 算法评价：时间复杂度——定性描述该算法的运行时间。常用大O符号表述，不包括这个函数的低阶项和首项系数。 程序设计实质：数据的表示和处理。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《决战中途岛》观后感","slug":"决战中途岛观后感","date":"2020-02-20T05:33:00.000Z","updated":"2020-04-14T01:53:21.822Z","comments":true,"path":"2020/02/20/决战中途岛观后感/","link":"","permalink":"/2020/02/20/决战中途岛观后感/","excerpt":"","text":"作为一个稍微对二战历史感兴趣的，并且入坑了舰c、舰b、wows、舰r（虽然在入坑舰c后退坑了）的人，有一部以二战时期的太平洋战场为背景的电影，无论电影好坏都是要看的，现在二战题材的电影又少之又少（毕竟市场小，不赚钱）。之前上映的时候找不到同圈子的人去看，趁着b站上映就去看了。对于自己来说，这是一部不错的电影。 剧情简介《决战中途岛》是由罗兰·艾默里奇执导由伍迪·哈里森、卢克·伊万斯、帕特里克·威尔森、曼迪·摩尔、艾德·斯克林、浅野忠信等主演的电影。 该片于2019年11月8日北美、中国内地同步上映。中途岛战役于1942年——日本偷袭美国珍珠港事件半年之后在南太平洋爆发，美国海军在中途岛环礁成功击退日本帝国海军舰队的攻击，获得了太平洋战区的主动权，这场战役被历史学家视为战争的转折点。 影片改编自1942年6月的中途岛战役，是整个太平洋战争的关键转折点，扭转了自珍珠港事件之后反法西斯盟军节节败退的局面。同时，这也是世界历史上著名“以小搏大”的战役之一，在海空军力大幅弱于日本的情况下，美军以沉没一艘航空母舰为代价，一举击沉日本主力航空母舰四艘、巡洋舰一艘。此次战役的胜利，彻底改变了反法西斯战争的格局，为二战胜利打下坚实的基础。 （摘自“百度百科”） 观后感这部分观后感极具主观色彩，且偏向肯定方向，在此说明。 bug作为一个有点了解那个时期历史的人，最喜欢的就是找bug。印象最深的就是联合舰队有5条大和。。 灭 国 舰 队 / 未 曾 设 想 的 道 路 / 震 撼 美 帝 / wows 10 级 房 现 状 其实还有其他的bug，比如珊瑚海代替太太（列克星敦）沉的是约克城。 约克城你好惨啊，在一部剧里沉了两次。 又或是主炮是鱼雷的驱逐舰。 但印象最深的还是麦克拉斯基发现本子舰队的名场面，这个梗估计这一年我都忘不了。 5艘大和你能把我秒了？ 毕竟经费有限可以理解，而且无伤大雅，所以就在这里调侃一番为止。 优点1、与《珍珠港》相比，这部电影里面没有谈恋爱！没有谈恋爱！没有谈恋爱！所有角色为剧情服务。 男人要看就看大舰巨炮，辣鸡三角恋。 2、难得的全景式、多方位记录一场二战的战争的电影，剧情流水账，主要场景在企业上，偏向于战争纪录片，估计没个5、6年是看不到下一部了，且看且珍惜。 3、国外二战电影中难得有中国内容的电影——空袭东京后，中国军民协助撤离杜立特编队成员，并且当时也因为掩护他们而牺牲了许多人。也可能是因为中国投资方投资比例最大。 不要在意那个微软字体的牌坊。 4、电影中有些情节能使得对历史有一定了解的人感到亲切，比如美帝的铁棍雷，以及本子海军传统艺能——最大的敌人是陆军，还有企业上的牛排，等。 全剧唯二笑的地方就是美帝的铁棍雷，另一个就是五艘大和。 5、演员基本贴合史实，没有强加政治正确元素。 看到剧中的飞龙舰长山口多闻总感觉他们在打外星人。 6、作为中心的中途岛战役该表现的情节基本上表现到了，看得既惊险又刺激，比如vt8鱼雷编队的惨烈，贝斯特俯冲轰炸一发入魂赤诚的情节。 缺点1、由于主要讲述的是中途岛战役，要在两个小时左右既要展现主题，又要讲清前因后果是比较困难的，尤其在经费不足的情况下从珍珠港开始，所以在中途岛之前剧情跳转迅速，比如珊瑚海中列克星敦转眼就沉了，如果不是对历史有点认识的话可能会一脸懵b。好在中途岛之中表现不错。 2、同样是因为经费有限，在中途岛之前的特效有明显的不自然的情况，无法与其他大多数知名战争片相比。 3、由于是全景式、多方位的电影，部分角色的人物形象不太深刻。有些本（感觉）应该是重要的剧情和人物也没有体现出来，比如中途岛一战成名的美方指挥官斯普鲁恩斯，在电影中只有过场；“AF可能缺乏淡水”在中途岛战役中的著名电报，在电影中并未着墨太多。 其他1、剧中在企业上爬上飞机打偏本子神风的猛男——布鲁诺·盖多，在一天干翻两艘航母的俯冲轰炸的猛男——理查德·迪克·贝斯特，在中途岛拍纪录片，后来得了奥斯卡的的导演——约翰·福特，等，都是史实，比抗日神剧的剧情好的太多。 2、电影否定了“命运五分钟”的说法，还进行了调侃。 现在不是昭和，大人，时代变了。 3、由于要增加观众的观看体验，电影中加强了本子的防空火力，历史中本子拉不出那样的防空火力网。 轮射的96神炮，昭和防空。 4、电影的剧本其实很早就基本完成，结果在美国没有投资人感兴趣，直到中方进行投资。（那可是你们父辈的荣光啊） 5、这部电影注定不会有高票房，资方亏钱情理之中，谁叫这个市场小呢。 总结对于对历史感兴趣的人来说，个人建议必看，其他的话也许需要稍微了解一下珍珠港、珊瑚海的相关情况，不然开始的一个小时可能会有点懵。不过对于想了解那一段历史，或者是因为感兴趣，或者单纯是要看“Lucky E”的人来说，都是一部个人推荐的，值得去看的电影。 顺便剧透一下：美帝赢了，本子输了。 大海铭记不朽。为电影的工作人员点赞。 电影之外的东西1、我想起初中的时候自己还年少不懂事，认为本子当年就很傻，没事就偷袭美帝，既把德国拉下水，又给自己找了个爹。现在想起来真是惭愧不如。 2、中途岛都安排了，什么时候安排一下莱特湾？ （但莱特湾估计不太可能，毕竟美帝方面指挥有失误。那以塔菲三号为中心也行。） 3、还有，美帝战后把企业拆了，果然敌在国会山。（和“老女士”厌战一样，工党误国） 企业：我为国家流过血！我要见总统！ 之后企业当核航妈去了，厌战当死库水（潜艇）去了","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"电影","slug":"电影","permalink":"/tags/电影/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"关于方舟近况的看法","slug":"关于方舟近况的看法","date":"2020-01-22T11:42:00.000Z","updated":"2020-03-18T12:05:51.291Z","comments":true,"path":"2020/01/22/关于方舟近况的看法/","link":"","permalink":"/2020/01/22/关于方舟近况的看法/","excerpt":"","text":"新年池里我90发年和阿我都没出，稍微缓和情绪并且在看到网上的一些情况后，有感而发。比较严肃，所以没有图。 正文月卡党；是大学生，属于有点闲钱，也有点时间，真想要什么东西的时候也愿意氪金的开服玩家，属于氪金量少于一万的“白嫖玩家”。 其实对于大多数手游，我一向不会报以太大的期望，一是主要玩的还是pc，手游填补不方便玩pc的空档。二是环境如此，有多少创作者愿意以及能够与当前市面上的一些寡头厂商竞争呢，而那些在市面上的厂商所做的那些游戏质量有多好呢，毕竟手游精品化嘛。 不得不说，方舟出现在了一个十分好的时间点上。开服之前的周边和同人为游戏积攒了不小数量的玩家，为其他游戏的上线验证了一条新路，即使经过三测的经历，大多数玩家也愿意在一个月后继续玩，因为玩家看到了一个愿意听取玩家意见，并对游戏进行优化的yj。这对于不愿意再受到某些厂商“割韭菜”式的行为的我来说这个游戏是值得尝试的，更别提我还喜欢这游戏的玩法和立绘、ui的（毕竟塔防游戏我玩过的只有王城保卫战觉得还可以），三测后我也“失忆”了。而开服后游戏的口碑也可以证明大多数玩家对游戏是充满了期待的。 但yj毕竟不是其他的某些厂商，生产力的不足始终是一个缺陷，也是其他大多数问题的根源，如果不解决的话，随着刚开服时的热情的递减，是必定会在某一个时间点爆发的，尤其是对于一个唯一一款游戏就能拿下许多成就的新公司来说。树大招风，不知有多少其他厂商眼红和嫉妒。 诚然，游戏一开始存在许多问题，但之后的发展让玩家看到了改进的趋势，包括危机合约让玩家看到了新机制的可能，文案的改善也让玩家愿意耐心下来看剧情（如只出来两章的霜星的牺牲对玩家的震撼之大，当然方舟剧情挖坑多填坑少也是一个问题）。但生产力依然是个问题，长草期过长（都被调侃成植树节了），正逐渐消磨玩家的耐心。就像2019年手游收入一样，方舟的国内收入逐月下降，当然，对于一个氪金量曾超过农药的手游来说，这是正常现象，即使收入下降，但基本的依然很多。 “文案抄袭”（我觉得有人故意扩大问题），“立绘抄袭”（虽然感觉不算），“只过洋节”（这帽子扣的有点大）并没有对游戏整体口碑造成什么影响，这一方面是玩家整体对游戏是有好感的，二是对大多数玩家利益可能有损害（虽然有些现实，但大多数人毕竟不愿意自己喜爱玩的游戏厂商受到这些影响，进而影响到自己的游戏体验），即使是碎石上限开放，也只有一部分玩家抱怨。但一旦遇到影响大多数玩家利益的问题，就没有人愿意站出来维护游戏了（一部分人除外，那不是维护游戏声誉，那是给游戏招黑）。这次限定up就存在这个问题，排除跟风的大多数没抽到的人除了怪自己的运气不好之外，更愿意保持中立，吃瓜看戏，毕竟自己身上也有损失，抽到的人许多也不愿意出来发声，海豹的下场在任何游戏中都已体现，而且现在已经形成对立。所以和之前的问题爆发比起来，这次尤为严重，一旦有任何一个问题爆发，许多其他没有摆在明面上的问题同样也会爆发，游戏口碑也会受到影响。 我不清楚是不是要冲业绩；不知道也不想知道某些厂商是否有水军暗中操作；不知道策划是不是经验不足；不清楚是不是在试探玩家底线（个人更愿意相信最后一种，毕竟我还是挺喜欢这游戏的）。对于yj这种新兴公司来说，玩家口碑更为重要，而从玩家整体口碑来看，去年似乎运行的还不错，即使说不上很好，但也比大多数其他的好。（这就是个比烂的时代） 这次的问题也许有对现实妥协的因素，其实更让我关注的是之后的发展趋势，产能不足的问题看起来还得持续一段时间（毕竟春节活动就这样看着是有点凄凉，但是我还是乐观的相信是因为一些不可抗力），是否还会出这一类操作不得而知，玩家的好感经不起消磨，之后只能希望少一些操作，拿了个最佳游戏不算什么，国内游戏环境如此。 嘴臭部分我90发限定池子出的两了六星，一个小火龙一个陈晖洁，就出了一次新的五星，你说我六星9％的概率撞上了我也没的说，但我已经碎了石头和充了钱抽这池子，抽成这样我还敢再继续充钱吗 。我可没有太多的钱砸在这游戏里面，我也不只玩这游戏，有这钱我还不如去舰b买皮肤，人可不能在一棵树上吊死。三个新的皮肤也买了，之前很想要陈晖洁我也充了98买礼包，除此以外每个月买月卡的石头也存着买皮肤了，之前没抽到反正在池子里面不会跑。出限定的我也没有意见，要吃饭的可以理解，但具体体现在这样的池子上就有问题了，这也不能怪玩家有怨言。 无论是有多么正当的原因，也许是因为之前送的石头比较多影响了氪金量，即使本意不是“割韭菜”，这种池子给人感觉就是在“割韭菜”，为什么要把限定和非限定放在一起。其他游戏也许也有这样的，但别人要么抽卡成本低，要么是有资本，要么脸厚。刚开始我看到消息还以为自己看错了，如果方舟走最后一条路的话，开服时玩家越有好感，越有期待，之后黑起来越狠，尤其对于方舟有这么大的玩家数量。你说我脸黑我也认，抽不到自己想要的玩家或多或少都有怨言，但为何这次大多数人表示不满。 我之前也玩过千年战争，要不是那游戏太肝了我也不会弃坑。方舟只是国内市场缺乏塔防游戏，版号寒冬之后，世界观和立绘讨喜的情况下，非常适宜地推出的，拿个最佳游戏正常，毕竟TapTap上其他某些游戏玩家就是看不惯，而有的游戏也没有方舟这样被大多数玩家所知道，收入榜第一也没有什么，只是这游戏玩家觉得确实不错，也愿意氪金守护喜爱的游戏，这些还不算什么。国内环境就是这样，有什么办法，这就是所谓的游戏精品化。 林子大了什么鸟都有，有的玩家就是这样，有就赞美，没有就喷，这次的问题不正中了那些为黑而黑的人的下怀吗。也不能怪更多吃瓜看戏的人，毕竟这些人也有没抽到的，同样也有损失，只是在键盘上敲一敲是不可能改变与自己观点相背的人的观点的。之前还希望评分上9，现在只能期望不下8。 所以说有些人不知道哪出了点问题，什么“白嫖玩家是养活游戏厂商的关键人群”这种话也说得出来。在？脑子是个好东西，你也应该有一个。 还有些人不知道是生下来只玩过这一款游戏，还是集体有一个群，一起恰烂钱，不知道这是给游戏招黑吗。我也不知道为什么能在少前冬活前的直播的弹幕中看到吹方舟的，也不知道为什么舰b出个红色婚纱就说抄袭陈晖洁的旗袍的。你们就喜欢看方舟与其他游戏对立是吗。对于这些人我说一个在网上看到的比喻。 消费的人在商场里讨价还价很常见，也可以理解。有的商家愿意卖给他们，但经常让他们不要和其他人说，显而易见，其他人一听说了这件事也想搭顺风车，商家亏本卖东西还不如不卖。但有一天突然有一个对着讨价还价的人说:“你怎么能这样呢，人家商家不吃饭的？” 这种人要么精神不正常，要么他是店家的孙子（各种意义上的）。 算了，玩个游戏这么累干嘛，你们线下pvp高兴就好，我在里面找乐子不也挺好。 其他一点小小的建议，我并不像那些微博上的那些人要求的那样指望官方道歉，毕竟“承认的错误才是错误”，而且我更愿意相信有一些不可抗力的。希望根据玩家的一些反馈进行总结，不管是公司内部，又或是发展方向上进行一下调整，解决主要问题（我记着不是赚得挺多的吗，我知道流水和收入不是一个东西，但收入依然不小吧，找不到人，生产力提不上去？还是忙着弄国际服的事情，那也不能忘了国服吧），并在游戏内容及其之后的活动中让玩家感受到类似于剧情文案方面的比较明显的改善，又或者是危机合约gkd，我要让红刀哥、红锤哥和我比看谁死在切城废墟。我认为大多数玩家还是愿意继续玩下去的，但玩家的耐心是有限的。（也许根本轮不到我提建议） 感谢你能看到这里，无论是支持的，想喷我的，又或是找乐子，无所谓的，这只是一个还比较喜欢玩方舟的玩家的个人极其片面想法，只是提供一个角度而已。如果想法和意见与你的不同，并且觉得我说的话没有道理，请务必坚持自己的看法，我算什么，我还没有本事让你必须接受我的观点。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"谨此纪念霜星","slug":"谨此纪念霜星","date":"2019-12-25T01:58:00.000Z","updated":"2020-03-18T12:06:35.531Z","comments":true,"path":"2019/12/25/谨此纪念霜星/","link":"","permalink":"/2019/12/25/谨此纪念霜星/","excerpt":"","text":"“…等我们自由了，我们会放声大哭，在荒野里在雪地里，在堆得满满的麦垛里放声大哭” 圣诞节的礼物？？想起其他的牺牲的干员（Ace、Scout）。。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"Hello World","slug":"Hello World","date":"2019-12-09T09:50:00.000Z","updated":"2020-03-18T12:05:44.949Z","comments":true,"path":"2019/12/09/Hello World/","link":"","permalink":"/2019/12/09/Hello World/","excerpt":"","text":"某种意义上的“First Post”，总结了建站时hexo自带的《Hello World》和主题Sakura的使用文档。 关于hexo关于hexo更多的信息可以查看官网的使用文档，使用中存在的问题可以在troubleshooting查找，或者在GitHub上提问。 创建$ hexo new &quot;My New Post&quot; More info: Writing 启动服务器$ hexo server More info: Server 生成文件$ hexo generate More info: Generating 发布$ hexo deploy More info: Deployment 清理清理本地文件，防止修改部分文件后出现错误。 $ hexo clean 本地调试$ hexo clean &amp;&amp; hexo s 上传服务器$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 关于Sakura主题hexo-theme-sakura主题基于WordPress主题Sakura修改成Hexo的主题。 详细使用方法查看使用文档。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}