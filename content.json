{"meta":{"title":"MoStone","subtitle":"我们，依旧在路上。","description":null,"author":"Mo_Stone","url":""},"pages":[{"title":"2nd_comment_arknights","date":"2021-08-18T07:55:36.000Z","updated":"2021-09-07T15:05:46.142Z","comments":false,"path":"2nd_comment_arknights/index.html","permalink":"/2nd_comment_arknights/index.html","excerpt":"","text":"方舟评价和建议总览写成于7.10作为方舟的开服月卡党，对游戏已经有两年的经历，应该算是对这游戏有点了解了。 一. 游戏类型核心玩法为塔防+养成，对于长线运营的游戏“养成”某种程度上是最简单且“必不可缺”的系统，而对于“塔防”，市面上比较知名的有：皇家守卫军（kingdom rush）、植物大战僵尸（Plants vs. Zombies）、保卫萝卜等，还有国外的千年战争 、御城 project 等。 塔防是从 RTS 中独立出来的一个分支，其玩法总的来说，就是“用有限的资源，构筑有针对性的防御体系，抵挡一波又一波进攻”，每一关卡和波次也就是“玩家总火力”与“敌方总血量”的对抗。目前大多数的塔防游戏都是围绕在这个对抗上面做文章，比如描述“玩家总火力”的物理伤害、魔法伤害、攻击数量、攻击速度、攻击范围等，描述“敌方总血量”的物抗法抗、移动速度、移动方式等。 但与许多 rpg 这类注重角色数值成长的游戏不同，因为有攻击范围和敌方移动速度这类模糊的要素，“玩家总火力”与“敌方总血量”这两个数值是难以用具体公式描述的，而正因为这两个数值的模糊，给了能影响塔防核心的关卡设计师较大的设计空间，“是否能让不同水平的玩家从同一关卡内获得乐趣”，这就十分依靠设计师的经验和实力。 千年战争作为一个13年的页游，在游戏内容的设计上与植物大战僵尸坏人皇家守卫军这两款经典的塔防游戏最明显的区别，就是融入了 rpg 的角色元素。千年战争将数值的对抗转变成了拥有各种职业和属性的角色对抗，并且千年战争将塔防里的“组合”发挥了出来，做出了类似于 mmorpg 的感觉，最简单的比如重装后面加奶加远程输出的组合。而角色的养成又为游戏的长线运营提供了一个良好的平台。 明日方舟在千年战争角色设计和战斗系统的基础上进行了部分的借鉴和简化，对其 ui 和卡面的画风进行了更适合大众的改进，在地图设计上使用了趣味性和策略性更强的格子地图，并基于此增加了“地形杀”和“干员朝向”，基建借鉴了避难所的设计。 作为限制级和锁区的千年战争本身难以大火，国内版号寒冬造成的市场空白，在经过市场考验的游戏系统基础上进行优化，并对立绘和剧情上做了更适应大众改善的明日方舟，再加上开服时作为开发商的鹰角对待玩家的态度，共同促成了这款游戏的爆火。 二. 玩法方舟简单来说就是“塔防+养成”，并且在此基础上与诸如强调策略的塔防玩法（危机合约）、 roguelike（集成战略）、匹配联机（多维合作）等玩法结合起来作为尝试，每次较为大型的活动基本都有新机制的引入，并且在随后的危机合约和剿灭作战将机制展现到更为广阔的范围或是将机制发挥到极致，保持玩家对游戏的新鲜感。 尤其是作为 roguelike 的集成战略在20年与夏活一同推出时，虽有各种不成熟的地方（比如关卡和事件还不够丰富，简单难度并不合理的设置等），但至今为止依然是最受方舟的各类玩家广受好评的玩法。 1、塔防塔防玩法本身，就是为追求有限资源下最为有效的解法，其学习过程可谓是无底洞，而这为方舟另一类的二创作者：攻略和追求极限的玩家提供了平台，这类作者与关卡设计师斗智斗勇的过程，成为又一部分为方舟提供热度的二创作者。 方舟在每次大型活动中，又会在塔防的基础上增加新的游戏机制，比如“画中人”的“晦明”，以及“覆巢之下”的“理智”。不仅维持了玩家对塔防玩法的兴趣，也体现出了塔防的策略性。 但这些活动的机制受制于活动频率并不能长期保持玩家的热度，并且这些新机制似乎也只是“昙花一现”，方舟需要能够长期保证玩家热度的，涉及范围更广的全新体制，比如“集成战略”。 2、养成大多数长线运营的游戏都有养成这一要素，而在有一定策略性的游戏中，如何找到角色强度和游戏策略性之间的平衡点成为影响游戏体验的重点。 方舟为了突出作为核心的塔防玩法，削弱了养成机制。方舟的养成并不复杂，作为玩家能直接影响角色强度的只有潜能、信赖度、角色等级和技能等级四个要素，潜能作为重复角色的补偿属于聊胜于无，对强度影响不大；信赖度能随着游戏流程逐渐提升；角色和技能等级与各种各样的素材有关，而这些素材都能通过基建生产和合成，又或是通关概率掉落获得。简单的角色养成过程让玩家更加容易理解和简单，并没有像部分游戏里随机程度非常高的，可能需要玩家重复刷取不可预见次数的复杂机制。 影响养成体验的另一基础的问题：“是否有这个角色”与运气有一定的关联，但”角色抽取”的问题几乎是现在所有免费内购游戏的问题，并且这方面也是游戏内的吸引玩家付费的主要方式之一，所以方舟在这方面设置得并不亲民。 3、基建基建在设计上可能是参考了“避难所”的设计，是游戏内提供抽卡资源（合成玉）和角色升级素材（作战记录）的来源之一，也是提供资金、提升信赖、合成角色突破和技能升级素材的场所。但从整体上看来，目前基建所起的作用并不重要，对于后期基建已经成型的玩家基建提供的只有定时收集资源，更换入驻角色，访问好友。 方舟从开始应该就已经意识到了这个问题，所以在主界面“基建”按钮下方一直有一个Beta字样，但更为重要的是“如何改”。 集成战略 + “情报室” 之前广受好评的 roguelike 集成战略，在以后需要途径加入罗德岛作为常驻玩法，在此基础上可以在基建里引入类似于“情报室”的区域。 当初引出集成战略玩法时，是借刻俄柏乱吃东西导致昏迷的剧情引出的，而作为常驻玩法时肯定需要其他剧情引入。这里借用了罗德岛背景下大概率存在的负责收集情报的团队，引入类似于“情报处理中心”的房间，机制与已有的负责线索收集的“会客室”类似，每隔一定时间出现不同的支援效果来提供选择，有一定时效并且可以为常驻的集成战略提供一定支援，而集成战略将亲身经历干员的一次次的外派任务，比如“天灾预测”，为集成战略的探索过程提供类似于“坏家伙号”的空中或其他地面支援，又或是“路线规划”，在关卡的某些位置地点固定出现补给点。 而在基建技能方面，一是可以在现有的部分干员上直接增加，二是在已有干员的“会客室”基建技能做调整，三是直接在新干员上新增基建技能的分支，在效果上与“会客室”类似，缩短刷新时长或是增加某一倾向。 “外派中心” 目前来说，玩家主要获得精英化和专精材料的途径来自于反复刷图，为了丰富获取途径，借用了罗德岛内负责管理干员外派的团队，而机制类似常见的“跑委托”，这只是把罗德岛日常的一部分在基建里具象化了而已。 “委托中心” 游走于泰拉大陆各个政治实体之间的罗德岛，在许多方面免不了与各地企业和政府展开有限的合作，在背地里也与某些黑市有所交易（当然这部分可能难以过“价值观”的门槛）。机制类似于“贸易站”+“会客室”，委托收集与贸易站的的订单类似，干员入驻与会客室类似，可完成各种团体的委托并获得各类素材，比如“以物换物”，通关某些特定关卡完成“科研或收集委托”等。 当然这部分可以直接在贸易站的基础上增加内容，但个人感觉为了简单和直观依旧是两者分开较好。 “自由活动区” 目前方舟剧情的空缺非常大，除主线支线剧情之外，还需要各种完善角色形象，目前的干员密录和故事集完全不够，而“酒吧”、“娱乐区”这类供干员自由活动的区域便是这些剧情良好的发生地，可以像《少女前线》基地里的酒吧那样为部分干员提供额外的剧情。 以上均不需要像制造站和贸易站需要经常大范围的轮换，并且这部分也只是增强玩家体验的内容，根据预想，给玩家造成的负担是较小的。 三、体验1、画面虽然有偏爱“简洁+科技”的主观因素，但方舟的 ui 设计应该属于手游中的前沿梯队，低饱和+简约+科技感的组合让玩家看着舒服且眼前一亮。 角色立绘尽可能做到统一画风，不会出现明显的违和感和割裂感，在符合大众审美的基础上尽可能体现出角色的美感，许多立绘乍一看角色裹得严严实实的，但仔细看的话各种细节又吸引着倾向于立绘或考据的玩家注意和兴趣。 2、音乐能到著名的阿比路录制音乐可见方舟对音乐的上心程度。即使方舟其他方面有各种各样的问题，但在音乐方面，迄今为止除了一首涉嫌抄袭的音乐外其他的风评均不错，并且方舟的音乐风格跨度之大，让许多人都能在塞壬唱片中找到至少一两首喜欢的音乐，比如《春弦》《夏浪》《秋绪》《冬涤》四首风格截然不同的曲子，高考应援的传统：《Everything’s Allright》《Heart Forest》让玩家能感受到这个游戏的亲切感。 但对于这些音乐和 ep ，方舟似乎还没有充足地利用好这些资源，现在只作为一种类似于宣传片的作用，而如果直接加入游戏中，风格多变的音乐可能会造成游戏整体“末世”风格的割裂。 最近个人比较喜欢的 keep the torch 鉴于方舟的许多音乐有一股“音游”风格，所以直接推出内置的“音游”娱乐玩法不免是其中的一种方法，但这个玩法会显得与方舟风格格格不入；而由于方舟大多数音乐 ep 与角色挂钩，还有一种方法是作为类似于角色收藏品的形式推出；除此以外，方舟的音乐与“塞壬唱片”这个虚拟公司挂钩，增加这个位于泰拉大陆虚拟公司的剧情，并借罗德岛与塞壬唱片的合作剧情，以一种类似于图鉴的形式引入罗德岛也不失为一种方法，还可以借“塞壬唱片”这个在游戏和现实里同时存在的公司，增加玩家对游戏剧情的代入感。 3、剧情/世界观说到方舟的剧情，个人应该算是对其有一定了解的了，而这也是方舟的一大吸引点。 对于个人来说，一是自己对历史本身就有一定兴趣和了解，而泰拉大陆上的各个国家里的人和事又给我一种“似曾相识”的感觉，泰拉发生的故事离现实并不遥远，比如对于个人来说感触最深的沃伦姆德，二是方舟的剧情建立在庞大的“泰拉”大陆上，各种各样的人和事在各国各地存在着，它们因某些机缘交织在一起，共同构成了这片“泰拉”。 方舟的文案里一定有人对历史文学有深刻的认识，但现在方舟最大的问题之一也就在这里：泰拉太大了。目前方舟的剧情是建立在巨大的泰拉大陆上，而方舟构建了一个巨大的世界观，但似乎还没有对细节有一定详细的描述，也就是方舟没有用“故事搭建世界观”这样更容易让人接受的叙事方法，而是采用了“在世界观里找故事”的方法，这使得方舟的剧情显得有些空和碎。 比如最近一年半的8章主线剧情讲述了博士苏醒后在罗德岛的经历，但另外的比如罗德岛前身“巴别塔”，作为罗德岛高层管理的阿米娅、凯尔希、博士的身世依然是一团迷雾，至今近两年的各种各样的支线（sidestory）、故事集、干员档案和密录，甚至是各种物品描述在各处一点一点地填补着这个剧情，更不用说目前与主线无关的人和事了。 又比如“哥伦比亚联邦”这个国家，目前只知道这个国家科技、经济、军事发达，“大拓荒”吸引着各地的移民，在发达的背后也有各种各样的阴暗面，在军事上蠢蠢欲动，国内以“莱茵生命”为代表的科技公司的研究上有越界行为，曾和另一国家“维多利亚”打过独立战争，与西边邻居“玻利瓦尔”发动过战争，积极插手南边“萨尔贡”的内政事务。在“地区”层面上这些内容非常少，更不用说方舟在“泰拉”“源石”这些更为广阔且核心的背景上有着未知的设计，各种活动剧情针对人和事就像是“提到了，但没有完全提到”的感觉。 所以目前方舟在剧情上需要减少未来剧情挖坑的情况，更多的剧情填补空白，但需求庞大产能却跟不上。如果想要吸引更多玩家欣赏剧情，游戏中需要转移支线剧情的重心，不能只依靠二创作者对剧情的考据。 但这样的剧情背景设计给了二创作者巨大的空间，再加上方舟在各处埋藏的细节，除去数量庞大的偏向于绘画的画师和手书作者，也有偏向于剧情的“剧情党”和“考据党”，这些玩家为方舟提供了大量热度，而对于“剧情党”和“考据党”来说，他们对剧情的关注使得方舟在剧情上必须投入更多的精力，许多手书作者也是基于方舟的剧情来创作的，出现诸如“联锁竞赛”中 ooc 或“吃书”现象的这类剧情将会是对这类玩家热情的严重打击。 目前猜测方舟的各种剧情文案是由不同组负责，这会使剧情水平显得参差不齐，并且作为基础的世界观上没有对某一人物或事件有一定程度的描述，在这方面某种程度上也印证了方舟剧情显得“大而空”的问题。并且从春活的“画中人”至今已有差不多半年的时间，目前为止还没有能像去年的周年活动“生于黑夜”，又或是春活“画中人”类似的能让关注剧情的玩家普遍“兴奋”的剧情。 另外，方舟“谜语人”式的文案也经常被人吐槽，虽然有些放在剧情中是能够理解的，比如作为博士的同事凯尔希，在设定上她是活了很久的角色，“世间冷暖皆已看淡”，她是完全有资本“装深沉”的，但对于许多玩家凯尔希的话就像是“一天到晚在你耳边，依仗着自己的经验，用各种方式念叨自己的长辈”，明明能直接说清楚的事一定要绕个弯，讲得事情也让玩家感觉一团迷雾，或多或少与“这片大地”联系起来，所以玩家会感觉到与凯尔希的距离十分遥远，多数玩家对凯尔希的感情是靠同人作者弥补的，并且其风评与玩家对游戏剧情的理解是有一定关系的，受制于当前剧情的文案和展现形式，关注剧情的玩家虽然有一定数量但并不是多数，凯尔希作为“人”的那一面在目前的剧情里体现得并不多。 作为对比，另一位有些“神神叨叨”的帕拉斯就能带给玩家不同的感受，除去她本身就是祭祀的原因，她与那为萨卡兹护卫的互动展现出她虽然讲事情也经常绕弯，但玩家可以感觉到她依然是能够讲清楚事情的，再加上“英雄从人民中来，又回到人民中去”的亲民形象，虽然帕拉斯并非主要人物，但她的风评就与凯尔希相比就并没有两极分化。 四、氪金方舟的流水来源主要是两者：卡池和皮肤，而方舟的卡池因此设计得并不亲民，虽然卡池经过计算大概是37抽出六星，但这并没有包括轮换池六星的50% up，更不用说是双 up 池，虽然限定六星为70%，但却采用了限定和非限定混搭的组合。而300的保底，与其说是保底，不如说是补偿，大部分玩家享受不到这个补偿机制。 这是方舟从“年”池以来一直都悬而未决的问题，从目前来看，解决方法可以参照与育碧“彩虹六号”的方案：降井+单up，并且增加皮肤的价值，比如新语音，有些语音在皮肤下非常出戏。 对于已有干员的强度增强可以在未来推出一个类似于“装备”的机制，获取方式类似于精英化，通过装备的属性或特性对部分干员进行加强。 五、总结方舟诞生在了一个良好的环境下，玩家对方舟有了一定的期待，也对方舟的容忍程度较高。但方舟的问题在二周年后逐渐突出：内容匮乏，无论是游戏玩法还是游戏剧情，良好的游戏素材没有得到很好的利用，比如 cg 和 ep 。 方舟有较为独特的二创环境，并且玩家对游戏的喜爱建立在对游戏的期待上，不能依靠二创弥补游戏内容的缺失，因为玩家完全可以抛开游戏建立同人世界观。 方舟虽然已经到了二周年，但依然不算特别成熟，而玩家的耐心是有限的。 写于8.5我怀疑现在方舟的夏活总是要试探玩家的底线，去年的火蓝之心复刻也是。 就我目前的看法，方舟夏活的主要问题就出在限定陈上，而这个问题连带引爆了从周年的“覆巢之下”， 甚至是更往前的“画中人”之后玩家所积蓄的不满，最后连带引爆了方舟游戏本身内容匮乏的问题。 先说最主要的问题：限定陈。 个人在专业上与美术没有交集，所以作为一个限定，其立绘表现如何不做评价，我更看重的是像skade老师在立绘上隐藏的一些要素。然而从目前来看，这方面的要素并不多。 之后就是限定的问题，诚然 yj 从来都没有说过每年只会出三个限定，但是有人不知怀有什么样的心态，引导出了这个问题：“方舟只会在新年和周年庆典出限定”，虽然这最终被证伪，但是在“限定”这个并不讨喜的词汇下，以及方舟那并不廉价的抽卡机制下，又有多少人关心？就像“沃伦姆德”剧情一样。 同时，玩家虽然在查证时并没有查到支持这个论点的论据，但许多玩家在此之前都或多或少得相信这个论点，这次的空降限定加深了玩家对yj的不信任，“如果这次的夏活出了限定，以后呢？” 其次方舟目前限定中的“异格”有着特殊意义，炎熔是在成长之后，斯卡蒂是 if 线，而这次的陈仅仅是去多索雷斯度了个假，这种更倾向于皮肤的剧情就出了异格，引起了部分关心方舟剧情的玩家不满。 而在限定陪跑干员水月，甚至是五星羽毛笔的衬托下，玩家对限定水陈的不满愈发严重。 （对于技能和强度设计，这种带有“先射箭，再画靶”的推测不敢苟同，但在发声的少数玩家引导下，整个圈子被搞得十分混乱） 剧情 方舟现在的支线剧情（side story）出现了一定同质化的现象，从开服的骑猎到至今的多索雷斯，除去周年庆之前的“生于黑夜”和“遗尘漫步”是为了引出限定干员外，剧情大多数都是一群在罗德岛工作的人到某个城市去发生了什么事，并在剧情中体现一个城市或地区、国家的现状，而这就是方舟最初剧情框架定下的“在地图里找故事”的基调所导致的结果。 虽然这样的剧情安排无可厚非，内容大多数也在及格线以上，其中也不乏有比如“玛利亚临光”和“画中人”这样优秀的剧情，但是由于方舟对于主要干员和地区的描述非常琐碎，单调、无聊的情绪会在剧情中或后逐渐产生。所以方舟需要除了剧情重心需要移动以外，也需要在这些活动之中穿插一些真正能引起大多数玩家兴趣的内容，比如“集成战略”、“多维合作”这类新玩法，又或是主线这种能让玩家更有沉浸感的内容。 活动 基于目前方舟本身的品质，其活动层次不齐的品质和有问题的安排也暴露出来。 最为突出的就是二周年庆的“覆巢之下”，虽然补充了一部分关于阿戈尔和海嗣这个涉及方舟核心世界观的剧情和背景，但对于许多玩家来说就像是一个特殊点的 side story，没有一周年时的主线“怒号光明”那样让玩家感觉上更加震撼和实在，无论是对于作为大多数的“非剧情党”，还是少数的“剧情党”。 6 7 8 21 故事集+复刻ss 联锁竞赛+复刻ss+故事集 多索雷斯ss 20 故事集 沃伦姆德ss 复刻ss+密林悍将ss+集成战略 “联锁竞赛”的玩法虽然有创新，但关卡并不丰富，到后期基本上就又回到了挂代理的地步，再加上其奖励设置得并不合理，剧情人设上的 ooc ，这次活动的反响并不算太好，和20年的“集成战略”比起来差距明显。 “如我所见”在剧情上按理说虽然比ss重要，但故事集和ss相比依然还是有较大差距，并且，不是所有玩家都看剧情。 所以整个6、7月，对于不怎么看剧情的许多玩家来说，实质内容并不算多，更多玩家想要的是新的ss，再加上联锁竞赛的玩法并不算太好，与集成战略比起来差距确实比较大。 然后就是最有争议的8月，如果单纯从ss的角度看，多索雷斯的假日作为夏活本身是没有什么问题的，但却出乎玩家意料的空降限定，然后，就没有然后了。。 综上，从活动上来说，一周年的主线和二周年的ss，20年7月份的ss和21年的故事集，20年的“集成战略”和21年的“联锁竞赛”，活动各方面的缩水和问题，再加上美术设定集、夏活组合包和限定的问题，最终引爆了方舟这近半年以来的问题。 随着复刻活动的增多，以后在夏活8月前的6、7月可能见不到ss，而作为新推出的玩法不可控性太高，那么玩家对8月夏活的期待理应会升高，而如果新玩法和8月夏活都出现了问题，那么方舟的整个夏天可能就不太那么好过了。 但如果规律不变，第三年的6、7月份没有新的ss的话，按照规律可能是第一年的复刻ss，在可预见的未来有可能又要出问题，所以这个规律需要改变。 关卡难度的降低也让游戏流程显得无聊，虽然这让新玩家更容易体会到完整的活动流程，但这让相对更多老玩家的活动流程变得无聊，一个高配成型阵容几乎就能打穿关卡，与“塔防”的策略性产生了矛盾，关卡难度不能一味倾向新玩家。 模组 方舟为了强化某些干员，除去直接在干员数值和机制上动手外，另一个方法就是装备系统“模组”，所以推出这个机制本身没有问题，但模组的获取方式就成了另一个问题。 由于玩家对这种直接影响干员强度系统的敏感，模组的获取方式就成为了玩家最为关心的问题，而yj很不合适宜的说明：这些模组“目前”可以直接通过类似于精英化的方式获得。在经历了限定异格陈的事情后，玩家如何相信yj以后不会做出类似的事情出来。 运营 方舟官号那“装死”的态度，引发了又一群玩家的不满，再加上少数“玩家”的引导和煽动，搞得包括沉默的大多数玩家的整个圈子十分混乱。 虽然“装死”是“解决”问题成本最低的方式，但已经有太多游戏死在了运营的“装死”，yj不是像某些在一片骂声中依然赚的盆满钵满的大公司，更何况有多少人正盯着这游戏。 危机合约 危机合约现在正逐渐变成单纯的数值堆叠、属性压制和“凹概率”，许多关卡都能猜出关卡设计师想让玩家干什么，以“黄铁”为例，弑君者和幽灵兵很单纯的就是想让玩家尽可能提升输出，再加上塔防的“抄作业”，关卡难度的相对下降，使玩家能从中获得的体验越来越无聊。 除此以外，危机合约现在的设计就是让“18”成为玩家的目标，这让追求极限和更高等级的人纯粹是“用爱发电”，建议获取的蚀刻章上加上最高合约等级。 所以针对最近状况的建议是：周年庆典固定推出主线，新玩法与剧情关卡挂钩来提供容错空间，限定每年出的数量需要给个确切数字，明确模组未来获取条件，提高对剧情和玩法的把控。用口碑换流水属于饮鸩止渴，大多数玩家正期待着半周年的主线。 二创已经救了方舟许多次了，仅仅在b站就能看到太多不亚于文案水平的、优秀且有深度的方舟同人作者，更不用说自发为方舟分析整理剧情和创建专门网站的玩家们，但二创终究只是玩家自发为游戏提供和维持热度的非官方手段，而 yj 需要考虑如何利用好方舟独特的二创环境。","keywords":"关于"},{"title":"Project_Neural_Cloud_4th_test","date":"2021-08-18T08:17:36.000Z","updated":"2021-08-18T08:19:59.993Z","comments":false,"path":"Project_Neural_Cloud_4th_test/index.html","permalink":"/Project_Neural_Cloud_4th_test/index.html","excerpt":"","text":"云图计划4测评价前言作为《少前1》开服前几个月入坑，直到去年底才逐渐退坑的玩家，对《少前1》本身的游戏品质有一定的认识和肯定，对“少前”这个 ip 以及其制作组云母也有一定的关注，除去《面包房行动》和《橘境》两款情怀向的单机作品外，对少前 ip 下的另两款作品《少前2》和《云图计划》也保持着关注。而个人在4测（终测）前有幸获得资格体验2测，再加上这一次的不限量测试，对这个 ip 下应该是最早公测的手游有了一定的看法。 虽然应该是2测提过建议，进而获得过3测的资格，但当时我并没有时间，所以给我另一个玩少前的同学玩去了。。 当时他是冲着自走棋去玩的，然后跟我说这根本不是自走棋，自走棋玩这个还不如玩云顶。。 玩法《云图》虽然看上去是自走棋，但实际上更像是 roguelike + 公主链接 / 刀塔传奇，讲道理，长期运营的以 roguelike 玩法为核心的游戏着实不多，而我最近了解的就是解神者。。我只能说不愧是云母组。。 我个人理解 roguelike 玩法是倾向于“简短、快节奏”的，每一局几乎从0开始，对未知未来的好奇推动着玩家不断前进和做出决策，直至面对最终事件，而 roguelike 的乐趣除去玩家对未知的渴望以外，就是决策中达成“1+1&gt;2” 效果的爽快感。以以撒为例，对未来未知的好奇感，随机遇到各式各样武器、道具、装备、随从的惊喜感，过程中不断从0做出决策建立起一套“无敌”搭配的成就感，以及恰当组合几乎能瞬间秒了关底 Boss 的爽快感，再加上游戏本身的简单易懂，各种各样的玩法的和强大的可拓展性、可开发性成就了这款游戏。 （简单、玩法多样、拓展性强的另一个著名游戏还是 mc ） 《云图》中划分有战士、射手、坦克、治疗、特种五种职业，每种职业各自有一套 buff 加成，被称作“函数卡”，随着游戏进行逐渐提供给玩家，让玩家根据当前阵容进行搭配，而每个职业的“函数卡”也分为多个不同的方向，比如坦克的防御、自奶和反伤，还有花样最多的特种。 一、roguelike 和养成这是个长期运营的游戏，必须加入能够长期支持玩家玩下去的系统，而养成就是最简单粗暴的，目前的问题之一也就出现在这里：作为长期玩法的养成和关卡内快节奏的 roguelike 玩法本身就存着冲突，如果关卡形成有一定套路的无敌阵容搭配，那么养成的热情会被削弱，反之，如果养成系统占比过高而形成练度的碾压，那么会弱化关卡内 roguelike 的玩法，这让目前作为这游戏宣传重点的 roguelike 玩法有些似是而非的感觉，两者间要寻找到一个解决办法和平衡点。 目前《云图》的解决方法是：前期在第一扇区注重养成教学，之后关卡和包括“故障协议”的内容向 roguelike 的策略性倾斜。但问题是不是所有玩家都能坚持到第一章，也就是第一扇区结束，因为我之前参与过2测所以知道这游戏后面的“故障协议”和 roguelike 比重的增加，但被 roguelike 吸引的玩家体验游戏前期注重养成的玩法时会感到不及预期。 所以个人的建议是缩短随着第一章逐渐展示玩法的教学，让玩家能尽早体验到作为核心玩法的 roguelike 和“故障协议”，又或是增加更多的比如固定人形的关卡。 二、轻度和重度玩家的内容虽然有手机玩家“弱智保姆软件”的调侃，但不得不说轻度玩家依旧是大流，即使已经有较多在少前1培养下的硬核或重度玩家。如果要同时吸引这两部分玩家，游戏内也应有相应的内容来迎合，所以对于轻度玩家有二倍速，重度玩家有“故障协议”。 虽然这方面没有什么问题，但个人感觉上玩法还是较少，目前 roguelike 的“房间”也依旧较少，显得有些“无聊”，也许是我个人对待“养成”的态度造成的。当然这游戏才刚开始也不能指望一下子就做出很多内容，长线运营的游戏不就是在运营过程中对游戏内容逐渐丰富的吗？ 其次，依然在 roguelike 和养成的冲突上，单纯的 roguelike 对现在大多数手游玩家并不友好，而需要花费较长时间的养成玩法又会影响单纯想体验 roguelike 的玩家。在前期比起认真思考策略通关的，刷材料升强度直接碾过去的玩家应该会更多，“前期较为容易而后期较为困难的养成数值提升”的设计并不是没有道理，但这样在前期就提供给了玩家更有效的方法过关，在前期对 roguelike 的体验较少，对“函数卡”选择的体验不足，使得后期加强 roguelike 玩法后不知道该做什么，反而淡化了作为卖点的 roguelike 。 而建议如同之前提到的尽早实际体验到游戏的核心玩法，加强对“函数卡”等玩法的引导和教程，又或是在类似于周常、月常本中加入较多 roguelike 元素。 三、roguelike 的策略和随机之前提到过，roguelike 玩法的乐趣之一就是从0到“无敌”的成就感，而《云图》中除去“故障协议”，大多数玩家能经常体验的主线、资源材料本、以及未来可预期的活动支线将一局 roguelike 大大缩短，再加上 roguelike 玩法本身就与运气有着很强联系，这就导致有些时候“函数卡”的一套搭配还没齐，还未体验到成就感就结束了，又或者是一直都不出来较好的“函数卡”，从而导致后面打得很难受或是直接失败。 虽然这对平时有接触 roguelike 单机的我来说是能够理解的，但氪金手游和单机还是有很大差别的，定位不同直接使得相同的玩法给玩家的感受不同。我也许能够接受单机上连续数十次在通关过程中的遗憾和失败，但在手游中哪怕连续失败只有两三次我也会感到难受。羽中“弱保软”的说法在手游玩家身上还是非常合理的。 针对“函数卡”的出现，目前《云图》里“函数卡”已经有锁定和降低概率两种方案，但实际体验下来依然需要加强。由于关卡的限制已经将一局时长大大缩短，所以个人建议直接对“函数卡”的概率动手，比如固定出现和从池子里删除等。 而针对随机性对游戏的影响，《云图》在 roguelike 基础上加上了“刀塔传奇”和释放战术技能的玩法，但从目前来看依旧不够，感受下来依旧“无聊”。当然在后续的直播里也提到了针对这方面的改进，比如主动释放的战术技能的增加和反馈提升，主动函数的增加，实际体验如何就要看之后的公测了。 角色和养成这方面就直接说了，升星的碎片获取途径太少，碎片的机制跟公主连接差不多，但公主连接建立在 cy 有钱大方的基础上，而《云图》很显然做不到这一点，游戏内体力太少，导致素材和碎片获取也少，尤其是养成素材，需求大而体力少和素材本掉落少两个因素共同导致了角色养成困难。 在碎片获取难的基础上，技能还和星级挂钩。 芯片这个东西我是从少前1的重装部队起就一直觉得这个东西很复杂，当时还没有教程，好像还跟什么算法有关，这方面还需要加强引导。。 氪金、福利和卡池节奏最大的地方。 角色先说男性角色这一问题，少前周期性药丸，只靠硬核和情怀吸引不了新玩家的，虽然我个人倒是对男性角色没有那么强的反感，但对于部分的其他玩家来说，《云图》顶了个“少前”的名字，这就使得玩家对这游戏卡池的期待就是女性，然后结果花了那么多资源就抽出来男性，这难免会让人失望。 好在随后的直播里提到了男性池子和女性池子分开的改进，不过目前来看游戏内的男性角色依旧偏少，而且这游戏究竟会有多少玩家抽男性池子依然要打一个问号，会不会有点费力不讨好的感觉。（当然我又没有数据也不知道实际情况） 福利和卡池单从池子直接充值的金额换取角色抽奖机会来看，1抽20块钱，3% 的三星，26%的 up ，虽然60的保底，但水位不继承，池子还非常多，过关送的福利也非常少，拼死拼活凑出来几十连，结果一个三星都抽不到，又或是歪了个初始送的角色，这很少人能承受得了。 不过还好直播里提到了这方面的改进：新手送自选三星，单抽价格下降，每月日常保底20连的资源，主线过关大概送180连，池子少了，水位能继承了，初始送的角色移除卡池了。目前看来改进还可以，但这 up 的概率感觉还是比较低，不过具体体验还要等实际上手了。 其他画风和 UI 就简单说几句，角色画风统一了，部分还有 live2d ，这些就很不错，而我个人本身就比较喜欢科技 + 简洁的风格，所以《云图》的 UI 我看着也很舒服。 角色的技能动画不错，但这个方面我要吐槽一下，我怎么感觉升星的立绘变化就是加了个图层的感觉。作战音效也太少了，关卡的 3d 环境和背景也不够丰富，这方面需要进一步优化。 而世界观，虽然只在2测的时候有看剧情，当时感觉中规中矩，比较平淡，而4测我直接 skip ，所以不好评价，但少前的底子在那，我还是相信《云图》能讲好故事的。 4测感觉下来就是非常经典的那句话：啥都好，就是不好玩，又或者是换个“高情商”的说法：这是个玩到后期越来越好玩的游戏。而直播的时候提到了这些中的大多数都会有改进，但这些可能改进可能会有点多，预定的8月上线可能要推迟了。 总的来说，底子还行，有一定潜力，爆款可能还会差点，还得看《少前2：追放》能不能成为爆款。","keywords":"云图计划4测"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-01-28T13:27:29.579Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-01-31T03:09:53.290Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[MoStone] 与&nbsp; MoStone&nbsp; （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-08-28T14:06:15.196Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-01-28T13:14:31.136Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"本主题基于Hexo主题Sakura修改,感谢作者hojun。Hexo版修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"other","date":"2019-02-10T13:32:48.000Z","updated":"2021-08-18T07:48:20.063Z","comments":false,"path":"other/index.html","permalink":"/other/index.html","excerpt":"","text":"","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-08-18T06:11:48.350Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"","date":"2020-01-14T12:56:52.905Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.min.js","permalink":"/lib/reading_progress/reading_progress.min.js","excerpt":"","text":"!function(){var e=$(\".reading-progress-bar\");if(e.length){var n=!1;try{var t=Object.defineProperty({},\"passive\",{get:function(){n=!0}});window.addEventListener(\"test\",$.noop,t),window.removeEventListener(\"test\",$.noop)}catch(e){}var i=$(window),o=$(document);o.ready(function(){window.addEventListener(\"scroll\",function(){var n=i.height(),t=o.height(),r=i.scrollTop()/(t-n)*100;r=r>100?100:r"},{"title":"","date":"2020-01-14T12:56:52.910Z","updated":"2019-12-13T04:47:50.084Z","comments":true,"path":"lib/reading_progress/renovate.json","permalink":"/lib/reading_progress/renovate.json","excerpt":"","text":"{\"extends\":[\"config:base\"]}"},{"title":"","date":"2020-01-14T12:56:52.907Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/README.html","permalink":"/lib/reading_progress/README.html","excerpt":"","text":"Reading Progress for NexT Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: $ cd themes/next $ ls bower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: $ git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress Step 3 &rarr; Set it up Enable module in NexT _config.yml file: reading_progress: enable: true color: &quot;#37c6c0&quot; height: 2px And, if you wants to use the CDN, then need to set: vendors: ... reading_progress: //cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js Update $ cd themes/next/source/lib/reading_progress $ git pull"},{"title":"","date":"2020-01-14T12:56:52.903Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.js","permalink":"/lib/reading_progress/reading_progress.js","excerpt":"","text":";(function() { var $bar = $('.reading-progress-bar') if (!$bar.length) return //no progress bar found var supportsPassive = false try { var opts = Object.defineProperty({}, 'passive', { get: function() { supportsPassive = true } }) window.addEventListener('test', $.noop, opts) window.removeEventListener('test', $.noop) } catch (e) {} var $w = $(window) var $d = $(document) $d.ready(function() { window.addEventListener( 'scroll', function() { var wh = $w.height() var dh = $d.height() var st = $w.scrollTop() var percent = (st / (dh - wh)) * 100 percent = percent > 100 ? 100 : percent < 0 ? 0 : percent $bar.css('width', percent + '%') }, supportsPassive ? { passive: true } : false ) }) })()"},{"title":"","date":"2020-01-14T12:56:52.901Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/package.json","permalink":"/lib/reading_progress/package.json","excerpt":"","text":"{\"name\":\"theme-next-reading-progress\",\"version\":\"1.2.0\",\"description\":\"Reading Progress for NexT\",\"main\":\"reading_progress.js\",\"scripts\":{\"uglify\":\"uglifyjs --compress --mangle -o reading_progress.min.js -- reading_progress.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-reading-progress.git\"},\"author\":\"theme-next\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-reading-progress/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-reading-progress#readme\",\"dependencies\":{\"uglify-js\":\"^3.3.9\"}}"}],"posts":[{"title":"附件","slug":"附件","date":"2021-08-10T09:50:00.000Z","updated":"2021-08-24T09:19:30.511Z","comments":true,"path":"2021/08/10/附件/","link":"","permalink":"/2021/08/10/附件/","excerpt":"","text":"此版用于存放附件。 《群星》系统划分和问题 明日方舟分析和评价 云图计划4测评价 边境检查官_游戏策划案","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Unity 笔记（2）","slug":"Unity 的一些技巧和常用的方法","date":"2021-06-12T08:54:00.000Z","updated":"2021-06-12T08:54:46.371Z","comments":true,"path":"2021/06/12/Unity 的一些技巧和常用的方法/","link":"","permalink":"/2021/06/12/Unity 的一些技巧和常用的方法/","excerpt":"","text":"书籍依旧为 [日] 北村爱实/著，罗水东/译 《Unity 2018 入门与实战——2D&amp;3D 游戏开发入门指南》 每隔一定时间生成 GameObject 的方法当需要创建大量相同对象时，一般都会使用 Prefab。在将作为 Prefab 的对象从层级窗口拖拽到工程窗口后，创建生成器（Generator）脚本。 以下以每隔 1s 随机在一定区域内生成 GameObject 为例。 using System.Collections; using System.Collections.Generic; using UnityEngine; public class Generator:MonoBehaviour{ public GameObject prefab; //间隔时间为 1s float span = 1.0f; float delta = 0; void Update(){ delta += Time.deltaTime; if(delta &gt; span){ delta = 0; GameObject go = Instantiate(prefab) as GameObject; //生成对象的位置 go.transform.position = new Vector(Random.Range(-1,2),7,0); } } } 之后为一个空对象挂载生成器脚本后，它就变成了 “工厂对象” ，并将 Prefab 实体通过 outlet 连接传给生成器脚本即可实现。 3D 游戏中获取鼠标点击位置前面提到 3d 游戏中世界坐标系和本地坐标系间的区别，以及使用 ScreenPointToRay 方法处理。如果将本地坐标传给该方法，那么可以获得一个世界坐标系中从 “摄像机” 指向将 “本地坐标” 的向量。 以下以在 3d 空间中获取鼠标点击的世界坐标为例（默认点击位置存在拥有碰撞体 Collider 组件的物体）。 using System.Collections; using System.Collections.Generic; using UnityEngine; public class GetPosition:MonoBehaviour{ void Update(){ if(Input.GetMouseButtonDown(0)){ Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if(Physics.Raycast(ray,out hit,Mathf.Infinity)){ Debug.Log(hit.point); } } } } 此处使用了 ScreenPointToRay 方法，从而计算出一条从摄像机位置射向画面深处的射线（Ray）。该射线可以检测到其与某碰撞器发生了碰撞。Physics.Raycast 的 hit 变量前加的 out 关键字，在这个方法中表示射线与某碰撞器发生碰撞时的坐标将会被存放到 hit.point 变量中。 Unity 中 C# 常用的类和方法以 Unity 官方文档：脚本 API 为准。 Vector2 / Vector3以下以 Vector2 为例。 用于表示 2D 向量和点。 静态变量 描述 down 用于编写 Vector2(0, -1) 的简便方法。 left 用于编写 Vector2(-1, 0) 的简便方法。 one 用于编写 Vector2(1, 1) 的简便方法。 right 用于编写 Vector2(1, 0) 的简便方法。 up 用于编写 Vector2(0, 1) 的简便方法。 变量 描述 magnitude 返回该向量的长度。（只读） normalized 返回 magnitude 为 1 时的该向量。（只读） x 向量的 X 分量。 y 向量的 Y 分量。 构造函数 描述 Vector2 使用给定的 x、y 分量构造新向量。 公共函数 描述 Equals 如果给定向量与该向量完全相等，则返回 true。 Normalize 使该向量的 magnitude 为 1。 Set 设置现有 Vector2 的 x 和 y 分量。 ToString 对于该向量，返回整齐格式化的字符串。 GameObjectUnity 场景中所有实体的基类。 等价于 GameObject.GetComponent &lt; Transform &gt; 变量 描述 position 世界空间中的变换位置。 公共函数 描述 Rotate 使用 Transform.Rotate 以各种方式旋转 GameObjects。通常以欧拉角而不是四元数提供旋转。 Translate 根据 translation 的方向和距离移动变换。 GameObject.Findpublic static GameObject Find (string name); 按 name 查找 GameObject，然后返回它。 此函数仅返回活动 GameObject。如果未找到具有 name 的 GameObject，则返回 null。如果 name 包含“/”字符，则会向路径名称那样遍历此层级视图。 出于性能原因，建议不要每帧都使用此函数，而是在启动时将结果缓存到成员变量中，或者使用 GameObject.FindWithTag。 注意：如果您要查找子 GameObject，使用 Transform.Find 通常会更加轻松。 GameObject.GetComponentpublic Component GetComponent (Type type); 参数 描述 type 要检索的组件的类型。 如果游戏对象附加了类型为 type 的组件，则将其返回，否则返回 null。 使用 gameObject.GetComponent 将返回找到的第一个组件，并且未定义顺序。 GameObject.SetActivepublic void SetActive (bool value); 参数 描述 value 激活或停用对象：true 可激活 GameObject，而 false 可停用 GameObject。 根据给定的值 true 或 false，激活/停用 GameObject。 GameObject 可能因为父项未处于活动状态而处于非活动状态。在这种情况下，调用 SetActive 不会激活它，而是仅设置此 GameObject 的本地状态，该状态可使用 GameObject.activeSelf 加以检查。当所有父项均处于活动状态时，Unity 便可以使用此状态。 停用 GameObject 将禁用每个组件，包括附加的渲染器、碰撞体、刚体和脚本。 Input访问输入系统的接口。 使用该类来读取传统游戏输入中设置的轴，以及访问移动设备上的多点触控/加速度计数据。 若要使用输入来进行任何类型的移动行为，请使用 Input.GetAxis。 它为您提供平滑且可配置的输入 - 可以映射到键盘、游戏杆或鼠标。 请将 Input.GetButton 仅用于事件等操作。不要将它用于移动操作。Input.GetAxis 将使脚本代码更简洁。 静态函数 描述 GetKey 在用户按下 name 标识的键时返回 true。 GetKeyDown 在用户开始按下 name 标识的键的帧期间返回 true。 GetKeyUp 在用户释放 name 标识的键的帧期间返回 true。 GetMouseButton 返回是否按下了给定的鼠标按钮。 GetMouseButtonDown 在用户按下给定鼠标按钮的帧期间返回 true。 GetMouseButtonUp 在用户释放给定鼠标按钮的帧期间返回 true。 Input.GetMouse…Input.GetMouseButtonDown / Input.GetMouseButton / Input.GetMouseButtonUp 以 Input.GetMouseButton 为例。 public static bool GetMouseButton (int button); 返回是否按下了给定的鼠标按钮。 button 值为 0 表示左按钮，1 表示右按钮，2 表示中间按钮。按下鼠标按钮时返回 true，释放时返回 false。 Input.GetKey…Input.GetKeyDown / Input.GetKey / Input.GetKeyUp 以 Input.GetKey 为例。 public static bool GetKey (string name); 在用户按下 name 标识的键时返回 true。 GetKey 将报告指定键的状态。 可以使用该函数确认用于自动开火的键。有关键标识符的列表， 请参阅 输入管理器。 处理输入时，建议改用 Input.GetAxis 和 Input.GetButton，因为 这允许最终用户对键进行配置。 Time从 Unity 获取时间信息的接口。 静态变量 描述 注释 deltaTime 完成上一帧所用的时间（以秒为单位）（只读）。 - timeScale 时间流逝的标度。可用于慢动作效果。 当 timeScale 为 1.0 时，时间流逝的速度与实时一样快。 当 timeScale 为 0.5 时，时间流逝的速度比实时慢 2x。当 timeScale 设置为 0 时，如果您的所有函数都是独立于帧率的， 则游戏基本上处于暂停状态。 ObjectUnity 可以引用的所有对象的基类。 您从 Object 派生的任何公共变量都将在 Inspector 中显示为放置目标， 让您能够从 GUI 设置其值。UnityEngine.Object 是所有 Unity 内置对象的基类。 虽然 Object 是一个类，但其本意不是为了在脚本中广泛使用。 静态函数 描述 Destroy 移除 GameObject、组件或资源。 Instantiate 克隆 original 对象并返回克隆对象。 Rigidbody通过物理模拟控制对象的位置。 向对象添加 Rigidbody 组件后，其运动将受到 Unity 物理引擎的控制。即使不添加任何代码，Rigidbody 对象也受到向下的重力，并在与其他对象碰撞时作出反应（如果也存在适当的 Collider 组件）。 变量 描述 isKinematic 控制物理是否影响刚体。 velocity 刚体的速度矢量。它表示刚体位置的变化率。 公共函数 描述 AddForce 向 Rigidbody 添加力。 Rigidbody.addForcepublic void AddForce (Vector3 force, ForceMode mode= ForceMode.Force); 参数 描述 force 力矢量（世界坐标）。 mode 要施加的力的类型。 向 Rigidbody 添加力。 沿 force 矢量的方向连续施加力。可以指定 ForceMode /mode/，以将力的类型更改为 Acceleration、Impulse 或 Velocity Change。 Random用于生成随机数据的类。 Random.Rangepublic static float Range (float min, float max); 返回介于 min [含] 与 max [含] 之间的随机浮点数（只读）。 请注意，max 包含在内。Random.Range(0.0f, 1.0f) 可能会返回 1.0 作为值 Random.Range 分布是均匀的。Range 是一个随机数生成器。 public static int Range (int min, int max); 返回介于 min [含] 与 max [不含] 之间的随机整数（只读）。 请注意，max 不包含在内。Random.Range(0, 10) 可以返回介于 0 与 9 之间的值。如果 max 等于 /min/，则返回 /min/。Random.Range 分布是均匀的。Range 是一个随机数生成器。 SceneManager运行时的场景管理。 SceneManager.LoadScenepublic static void LoadScene (int sceneBuildIndex, SceneManagement.LoadSceneMode mode= LoadSceneMode.Single);public static void LoadScene (string sceneName, SceneManagement.LoadSceneMode mode= LoadSceneMode.Single); 参数 描述 sceneName 要加载的场景的名称或路径。 sceneBuildIndex Build Settings 中要加载场景的索引。 mode 允许您指定是否以累加方式加载场景。有关选项的更多信息，请参阅 LoadSceneMode。 按照 Build Settings 中的名称或索引加载场景。 注意：在大多数情况下，为了避免在加载时出现暂停或性能中断现象， 您应该使用此命令的异步版，即： LoadSceneAsync。 使用 SceneManager.LoadScene 时，系统将不会立即加载场景，而是会在下一帧完成加载。这种半异步的行为可能会导致帧卡顿，并可能令人困惑，因为加载无法立即完成。 Animator用于控制 Mecanim 动画系统的接口。 变量 描述 speed 动画器的播放速度。1 为正常播放速度。 公共函数 描述 SetTrigger 设置给定触发器参数的值。 Camera摄像机 (Camera) 是供玩家观看世界的设备。 屏幕空间的点以像素定义。屏幕的左下角为 (0,0)，右上角 为 (pixelWidth,pixelHeight)。z 位置为与摄像机的距离，采用世界单位。 视口空间的点是标准化的、相对于摄像机的点。摄像机左下角为 (0,0)，右上角为 (1,1)。z 位置为与摄像机的距离，采用世界单位。 在全球坐标中定义一个世界空间点（例如，Transform.position）。 Camera.ScreenPointToRaypublic Ray ScreenPointToRay (Vector3 pos);public Ray ScreenPointToRay (Vector3 pos, Camera.MonoOrStereoscopicEye eye); 返回从摄像机通过屏幕点的光线。 产生的光线位于世界空间中，从摄像机的近平面开始，并通过屏幕上 位置的 (x,y) 像素坐标（忽略 position.z）。 Ray 射线表示形式。 射线是从 origin 开始并按照某个 direction 行进的无限长的线。 Physics全局物理属性和 Helper 方法。 Physics.Raycastpublic static bool Raycast (Vector3 origin, Vector3 direction, float maxDistance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction= QueryTriggerInteraction.UseGlobal); public static bool Raycast (Ray ray, float maxDistance= Mathf.Infinity); 参数 描述 origin 射线在世界坐标系中的起点。 direction 射线的方向。 maxDistance 射线应检查碰撞的最大距离。 layerMask 层遮罩，用于在投射射线时有选择地忽略碰撞体。 queryTriggerInteraction 指定该查询是否应该命中触发器。 返回 bool 如果射线与任何碰撞体相交，返回 true，否则为 false。 描述 向场景中的所有碰撞体投射一条射线，该射线起点为 /origin/，朝向 /direction/，长度为 /maxDistance/。您可以选择提供一个 LayerMask，以过滤掉不想生成与其碰撞的碰撞体。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"/tags/Unity/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"Unity 笔记","slug":"Unity 笔记","date":"2021-06-11T13:35:00.000Z","updated":"2021-06-12T08:28:43.793Z","comments":true,"path":"2021/06/11/Unity 笔记/","link":"","permalink":"/2021/06/11/Unity 笔记/","excerpt":"","text":"断断续续写了一个月左右。 书籍为 [日] 北村爱实/著，罗水东/译 《Unity 2018 入门与实战——2D&amp;3D 游戏开发入门指南》 第一章：开发前准备游戏制作步骤 Step1：罗列出画面上所有对象。 Step2：确定游戏对象运行需要哪些控制器脚本。 这个步骤需要找出 Step1 列出的所有对象中“会动”的游戏对象。 对于”会动“的游戏对象，需要用脚本来控制其行动，这种脚本可被称为控制器脚本。 Step3：确定自动生成游戏对象需要哪些生成器脚本。 这个步骤需要找出游戏过程中被生成的对象。敌人角色和舞台场景等 根据玩家移动情况和时间变化将会出现的对象 都属于此类。 在游戏过程中用来创建各个游戏对象的脚本，可被称为 生成器脚本 。生成器脚本相当于一个专门创建游戏对象的工厂。 Step4：准备好用于更新 UI 的调度器脚本。 为了使玩家能 通过游戏 UI（用户界面）来操作游戏并能够及时了解游戏进度，还需要一个能够”总揽全局“的脚本，可被称作 调度器脚本。 Step5：思考脚本的编写流程。 大体按照 ”控制器脚本“ → ”生成器脚本“ → ”调度器脚本“ 的顺序。 开发 最重要的是先从整体上弄清楚”需要什么脚本“”按什么步骤完成制作“这些问题，后续再针对各个脚本思考具体的实现方式。 第四章：UI和调度器UIUI 用于表示游戏的状态和进度，对增强用户的游戏体验有非常重要的作用。 UI 的制作方法 把 UI 组件配置到场景视图中。 编写用于切换 UI 的调度器脚本。 创建调度器对象（空对象），为其挂载编写好的脚本。 由于 UI 的设计画面比通常的游戏设计画面要大很多，所以有时可能无法在场景试图中看到新添加的内容，但它的实际大小和游戏画面是对应的。实际运行后并不存在 UI 溢出画面的情况。 组件Unity 的对象就像一个叫做 GameObject 的 “空箱子”，用户可以通过往里面添加各种设置（相当于挂载各种组件）来丰富它的功能。例如，要让对象具有物理特性，可以为它挂载 Rigidbody 组件；要让它发出声音，可以为它挂载 AudioSource 组件。如果想添加其他特殊的功能，还可以挂载脚本组件（包括控制器脚本和调度器脚本）。 此外，还有一个用于管理对象坐标与旋转的组件，即 Transform 组件。如果说 AudioSource 组件相当于 CD 播放器，那么 Transform 组件就相当于方向盘，负责提供坐标数据和移动等功能。例如 car.transform.position.x 访问被挂载到小车对象（car）上的 Transform 组件所持有的坐标（position）信息。 除 Transform 组件外，当对象访问组件时需要用到 GetComponent 方法。GetComponent 方法会向游戏对象发起 “请给我某某组件”的请求，然后返回相应的组件。例如，需要 AudioSource 组件，就调用 GetComponent&lt; Audio Sorce &gt;() ；如果需要 Text 组件，则调用 GetComponent&lt; Text &gt;() 。 如果只是为了获取坐标，每次都编写 “GetComponent&lt; Transform &gt;()” 语句太过繁琐。因此，对于常用的 Transform 组件，可以直接用 transform 来替代 “GetComponent&lt; Transform &gt;()”。也就是说， trasform 相当于 GetComponent&lt; Transform &gt;() 。 此外，自行编写的脚本也属于一种组件，它也能通过 GetComponent 方法调用。例如，在 CarController 脚本中编写了 Run 方法，那么通过 car.GetComponent&lt; CarController &gt;().Run() 语句，就可以调用小车对象上挂载的 CarController 脚本中的 Run 方法。 访问非自身所在对象的组件的方法 用 Find 方法找到该对象。 用 GetComponent 方法获取该对象挂载的组件。 访问该组件持有的数据。 第五章：Prefab 与碰撞检测Prefab 和 工厂工厂（Generator）相当于一台能够按照 “设计图” 生产相应 “产品” 的 “加工机器”。 设计图相当于一份描述了 “产品规格” 的说明书。Unity 中将这个设计图称为 Prefab。将设计图（Prefab）传给加工机器（生成器脚本）后，就可以按照设计图生成相应的产品（游戏对象实例）。 在 Unity 中，当需要创建大量相同对象时，一般都会使用 Prefab。这样做的优势是：如果使用了 Prefab，那么在改变游戏对象时只需要修改 Prefab 文件就可以了。 工厂的创建方法 通过已经存在的对象生成 Prefab。 创建生成器脚本。 在空对象上挂在生成器脚本。 将 Prefab 传给生成器脚本。 outlet 连接outlet 连接可以非常方便地将实体对象带入脚本内的变量。 要在脚本中创建 outlet “插口”，就必须在变量前添加 public 关键字。 添加了 public 关键字的变量都会显示在检视器窗口中。 通过检视器窗口中的 “插口” 将希望代入的对象 “插入”（拖拽操作）。 非 Physics 碰撞检测以将两个 GameObject ：A 和 B 的轮廓视为圆形，并利用圆的圆心坐标和半径，使用勾股定理来完成碰撞检测为例。 假定 A 的半径为 r1 ，圆心位置向量为 p1，B 的半径为 r2 ，圆心位置为 p2，从 B 指向 A 的向量 dir = p1 - p2 = A.transform.position - B.transform.position，dir 的距离 d 为 dir.magnitude。当 d = r1 + r2 时认为 A、B 两物体发生了碰撞。 Button 按钮在 UI 添加按钮后： 创建按钮按下后控制的 GameObject 的方法。 为各个按钮指派相应的方法。 在层级窗口中选择相应按钮，在检视器窗口中的 Button（Script）项中单击 OnClick 中的 + 按钮。将 控制的 GameObject 从层级窗口中拖拽到写有 None(Object) 的那一栏。这样就可以将该 GameObject 上挂载的脚本中包含的方法指派给按钮。单击打开写有 No Function 的下拉列表，选择 该 GameObject 的脚本 → 想要触发的相应方法。 如果列表中找不到该方法，确认该方法是否添加了关键字 public 。 第六章：Physics 和动画PhysicsPhysics 是 Unity 提供的物理引擎，可以用来使游戏对象模拟物理规律运动（下落和碰撞等）。使用物理引擎时，程序将会结合游戏对象的质量、摩擦系数以及重力等因素进行综合计算，从而使其实现仿真物理运动。 Physics 需要 Rigidbody 组件和 Collider 组件的配合才能发挥功能，即要使用 Physics 来让对象按物理规律运动，必须在对象上挂载 Rigidbody 和 Collider 两个组件。 Rigidbody（刚体）是实现游戏对象的物理行为的主要组件，负责 “受力计算（作用于对象上的重力和摩擦力等力的计算）”，而 Collider（碰撞体） 组件负责 “对象的碰撞检测”。 由于刚体组件会接管附加到的游戏对象的运动，因此不应试图借助脚本通过更改 “Transform”（变换） 属性（如位置和旋转）来移动游戏对象。相反，应该施加 力 来推动游戏对象并让物理引擎计算结果。 在某些情况下，可能 希望游戏对象具有刚体，并让刚体的运动摆脱物理引擎的控制。例如，可能希望直接从脚本代码控制角色，但仍允许触发器检测角色。脚本产生的这种非物理运动称为 运动学运动。刚体组件有一个名为 Is Kinematic 的属性，该属性可以让刚体摆脱物理引擎的控制，并允许通过脚本以运动学方式来移动刚体。可以通过脚本来更改 Is Kinematic 的值，从而为某个对象开启和关闭物理引擎，但这会产生性能开销，应谨慎使用。 Mecanim借助 Mecanim，动画的创建到动画的播放都可以在 Unity 编辑器中完成。使用 Mecanim 可以在游戏设计过程中分别制作各种动画，然后指定各动画间切换的时机，游戏运行时会根据 Mecanim 对象的状态进行判断，从而自动播放相应的动画。 使用 Mecanim 时需要理解其组成 “sprite” “Animation Clip” “Animator Controller” “Animator 组件” 之间的关系。 sprite → Animation Clip → Animator Controller → Animator 组件 一挂载→ 对象 Animation Clip 相当于一个将零散的序列帧图片整合到一起的文件。例如 “行走动画” 和 “跳跃动画”，都分别对应一个 Animation Clip。动画的序列帧信息以及播放速度、播放时长等信息都在 Animation Clip 中设置。 Animator Controller 负责将上述的 Animation Clip 整合到一起。Animator Controller 可以指定 在什么时刻播放什么 Animation Clip。例如，“当角色位于地面上时播放行走动画” “跳跃时播放跳跃动画” “在水中则播放游泳动画” 这些条件都可以在 Unity 编辑器中设置。 创建动画在动画的 Animation Clip 准备好后，如果存在多个动画间的切换，则需要 使用 Animator Controller 来切换动画。Animator Controller 中需要考虑以下两个问题。 从哪个 Animation Clip 跳转到哪个 Animation Clip？ 在什么时机跳转到目标 Animation Clip？ 设置动画跳转 打开工程窗口中的 Animator Controller 可以看到动画结点，以及自动生成的 Entry、Any State、Exit（Exit 结点在画面外） 结点名 功能 Entry 动画开始时都是从 Entry 结点跳转过去的。 Any State 在任意时刻希望跳转到某状态时会用到。 Exit 结束动画时将先跳转到 Exit 结点。 在希望跳转的结点上右键，选择 Make Transition ，并点击希望跳转到的结点即可实现跳转。 设置跳转时机 选择动画跳转的箭头，在右侧检视器中根据具体需求和条件，设置跳转时动画播放效果。 参数 说明 Has Exit Time 动画播放结束后，是否自动跳转到其他动画。 Exit Time 用归一化（0.0~1.0）处理后的值设置动画的结束时间。 Transition Duration 用归一化（0.0~1.0）处理后的值设置跳转到下一个动画的时间。 Transition Offset 用归一化（0.0~1.0）处理后的值设置下一个动画开始播放的时间。 之后设置动画跳转的时机，需要在跳转箭头上设置 Trigger。例如 在按下某个按钮时 Trigger 将被打开，动画将实现跳转。 首先在 Animator Controller 中创建 Trigger。单击 Animator 窗口左上的 Parameters 标签，单击 + 按钮，然后在下拉菜单中选择 Trigger。 跳转条件的各种参数如表。 数据类型 功能 Float 使用浮点小数作为跳转条件。 Int 使用整数作为跳转条件。 Bool 使用布尔值作为跳转条件。 Trigger 使用触发器作为跳转条件。 创建 Trigger 后，再对跳转箭头进行设置。选择相应的箭头，在检视器窗口中设置跳转条件的具体信息。单击 Conditions 的 + 按钮，在下拉列表选择相应 Trigger。 最后，添加满足一定条件（例如按下某个按钮）时打开 Trigger 的脚本，可以使用 Animator 组件持有的 SetTrigger 方法。SetTrigger 方法会打开参数所指定的 Trigger ，从而使动画跳转。 第七章：3D 游戏的开发方法TerrainTerrain 是 Unity 提供的用于创建地形的工具，使用 Terrain 不仅可以很容易地创建出山川河流等地形，而且还可以方便地在地面铺设纹理。更为强大的是，除了铺设简单纹理，它还支持通过涂抹操作在地面创建出 3D 的树木和草地等对象。 粒子系统（Particle System）粒子系统可以创建大量的例子，并且可以通过控制各个粒子的行为、颜色以及大小模拟出水、烟、火等效果。 使用粒子来呈现不同特效时，必须按一定的策略来调整各个粒子的颜色、大小以及速度等参数。粒子系统的主要参数如下： 参数 说明 Duration 粒子的持续生成时长。 Looping 是否持续生成粒子。 Start Delay 创建粒子的延迟时间。 Start Lifetime 粒子的存活时长。 Start Speed 粒子的初始速度。 Start Size 粒子的初始大小。 Start Color 粒子的初始颜色。 Gravity Modifier 粒子受到的重力。 Max Particles 粒子数量上限。 Rate over Time 每秒生成的粒子数。 Bursts 指定时间内的生成粒子数。 Shape 生成粒子的排列形状。 显示粒子特效的方法 给对象挂在 ParticleSystem 组件。 调整 ParticleSystem 组件的参数以创建特效。 通过脚本播放相应的粒子特效。 世界坐标系和本地坐标系Input.mousePosition 方法能够获取单击位置的坐标，但在 3D 游戏中无法直接使用 mousePosition 的坐标，因为 mousePosition 表示的不是世界坐标系的值而是本地坐标系的值。 世界坐标系是用于表示对象在 “游戏世界” 中具体位置的坐标系。而本地坐标系只是用来表示 “游戏画面上” 具体位置的坐标系。 世界坐标系和本地坐标系的定义完全不同。例如，在世界坐标系中，GameObject 的坐标为（2,1,2）；而在本地坐标系中，GameObject 的坐标为（400,150）。 事实上 Unity 提供了 ScreenPointToRay 方法。如果将本地坐标传给该方法，那么可以获得一个世界坐标系中从 “摄像机” 指向将 “本地坐标” 的向量。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"/tags/Unity/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"【转】中文文案排版指北","slug":"中文文案排版指北","date":"2021-03-14T09:50:00.000Z","updated":"2021-03-14T13:06:25.172Z","comments":true,"path":"2021/03/14/中文文案排版指北/","link":"","permalink":"/2021/03/14/中文文案排版指北/","excerpt":"","text":"本文转自编辑部群文件，为更好增加网站内容的可读性和美观。原文来自 外部链接 。 统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。 空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。今天出去买菜花了5000元。 数字与单位之间需要增加空格正确： 我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB 错误： 我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB 例外：度 / 百分比与数字之间不需要增加空格： 正确： 今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！刚刚买了一部 iPhone， 好开心！ 用 text-spacing 来挽救？CSS Text Module Level 4 的 text-spacing 和 Microsoft 的 -ms-text-autospace.aspx) 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号不重复使用标点符号正确： 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！她竟然对你说「喵」？！？！？？！！ 全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全形和半形』。 使用全角中文标点正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！ 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符正确： 这个蛋糕只卖 1000 元。 错误： 这个蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。 遇到完整的英文整句、特殊名词，其内容使用半角标点正确： 贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误： 贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录使用 GITHUB 登录使用 Github 登录使用 gitHub 登录使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写正确： 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误： 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格用法： 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？” 工具 仓库 语言 vinta/paranoid-auto-spacing JavaScript huei90/pangu.node Node.js huacnlee/auto-correct Ruby sparanoid/space-lover PHP (WordPress) nauxliu/auto-correct PHP jxlwqq/chinese-typesetting PHP hotoo/pangu.vim Vim sparanoid/grunt-auto-spacing Node.js (Grunt) hjiang/scripts/add-space-between-latin-and-cjk Python hustcc/hint Pytho studygolang/autocorrect Go 谁在这样做？ 网站 文案 UGC Apple 中国 是 N/A Apple 香港 是 N/A Apple 台湾 是 N/A Microsoft 中国 是 N/A Microsoft 香港 是 N/A Microsoft 台湾 是 N/A LeanCloud 是 N/A V2EX 是 是 Apple4us 是 N/A Ruby China 是 标题达成 PHPHub 是 标题达成 少数派 是 N/A 参考文献 Guidelines for Using Capital Letters - ThoughtCo. Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Correctly - wikiHow 格式 - openSUSE 全形和半形 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"《数据结构》笔记（续）——尝试&Test代码","slug":"数据结构笔记12","date":"2020-06-26T01:45:00.000Z","updated":"2020-09-07T02:53:38.205Z","comments":true,"path":"2020/06/26/数据结构笔记12/","link":"","permalink":"/2020/06/26/数据结构笔记12/","excerpt":"","text":"这是数据结构课程的实验，里面会有会有很多不成熟的错误。 其实只是写了这么多找个地方存而已。 https://github.com/mo-stone-0214/blog_source/tree/master/Data%20%20Structure_Java 如果不介意中文的问题的话：https://cdn.jsdelivr.net/gh/mo-stone-0214/blog_source@1.1.1/Data%20%20Structure_Java 测试用 二叉排列树 双链表 中缀表达式转后缀表达式、中缀和后缀表达式的运算 哈夫曼树 单链表转置 队列 排序：直接插入、希尔、冒泡、快速、直接选择、堆、归并排序 矩阵乘法 顺序表 单链表 栈：用数组创建 栈：用链表创建 栈的应用：判断回文 用数组和链表创建二叉树 二叉树的先序、中序、后序递归遍历 二叉树的先序、中序、后序、层次非递归遍历 实验课 实验课：队列 实验课：单链表和顺序表的查找 实验课：直接插入、直接选择、冒泡排序 实验课：栈的操作、中缀表达式转后缀表达式以及计算 实验课：二叉树的先序、中序、后序递归遍历 实验课：二叉树的先序、中序、后序非递归遍历","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（11）——图","slug":"数据结构笔记11","date":"2020-06-12T01:45:00.000Z","updated":"2020-06-25T09:28:13.234Z","comments":true,"path":"2020/06/12/数据结构笔记11/","link":"","permalink":"/2020/06/12/数据结构笔记11/","excerpt":"","text":"概念 定义 图是一种较之线性表和树形结构更为复杂的非线性数据结构。图中各数据元素之间的关系可以是任意的，描述的是“多对多”的关系。 图是由顶点集合 (Vertex) 及顶点间的关系（边：Edge）集合组成的一种数据结构：Graph＝( V , E )其中 V 是顶点的有穷非空集合； E 是顶点之间关系的有穷集合，也叫做边(Edge)集合。 分类 无向图：图G中顶点的偶对是无向的，其偶对用（Vx，Vy）表示。有向图：图G中顶点的偶对是有向的。其偶对用 &lt;Vx,Vy&gt; 表示。 相关概念 顶点（Vertex）:图中的数据元素（结点）称为顶点。 邻接点无向图中，若边（Ｖx，Ｖy）∈ E， 则Ｖx、Ｖy互为邻接点。有向图中，若弧〈Ｖx，Ｖy〉 ∈ E， 则Ｖy是Ｖx的邻接点，反之，不是。 边（Edge）:顶点间的关系可描述为顶点的偶对，也称为顶点的边。记为:(Vx，Vy）。边是无序的，与(Vy，Vx）含义相同。 弧（Arc）:若顶点间的边是有方向性（有序）的，则称该偶对为弧。记为：〈Vx，Vy〉。弧是有序的，〈Vx，Vy〉表示从Vx到Vy。 弧头：弧的终点称为弧头（方向前方）。 弧尾：弧的起始点称为弧尾（方向后方）。 度：无向图中，顶点的度是以该顶点为一个端点的边的条数。有向图中，以某顶点为弧头的弧的数目称为该顶点的入度。以某顶点为弧尾的弧的数目称为该顶点的出度。该顶点的度=入度+出度。 路径：在图 G＝( V,E ) 中, 若存在一个顶点序列 v p1,v p2 , …,v pm ，使得(vi,v p1)、(v p1,v p2)、…、(v pm,vj)均属于 E， 则称顶点 vi 到 vj 存在一条路径。若一条路径上除了 vi 和 vj 可以相同外，其余顶点均不相同，则称此路径为一条简单路径。起点和终点相同的路径称为回路或环。 完全图：在无向图中任何两个顶点都存在一条边。n个顶点的完全无向图拥有 [n(n+1)]/2 条边，有向图为 n(n+1) 。 连通顶点：在无向图中,顶点A和顶点B间存在一条路径,则称顶点A和顶点B为连通顶点。 连通图：在无向图中，若每一对顶点间都有路径，称此图是连通图。 连通单元：将无向图分成多个分离的子图后,原图形的连通点仍在同一个子图中。 根据连通分量的定义，可知任何连通图的连通分量是其自身，非连通的无向图有多个连通分量。 强连通图：在有向图中，若每对顶点Vx到Vy间都存在Vx到Vy，及从Vy到Vx的路径，则称此图是强连通图。 强连通单元：将有向图分为多个分离的子图后,原图形的连通顶点仍在同一个子图中。 强连通图的唯一强连通分量是其自身，而非强连通的有向图有多个强连单元。 有n个顶点的连通无向图最多有[n(n-1)]/2条边，最少有 n-1 条边，可构成一棵树。有n个顶点的强连通图最多有 n(n-1)条边，最少有 n 条边，可构成一个环。 权：若图的边或弧带有与之相关的数，称此数为该边或弧的权。权通常用来表示从一个顶点到另一个顶点的距离或费用。 网：带权的图称为网。 存储 特点 邻接矩阵存储：第i个矩阵中结点数目为顶点i的度。无向图中，所有矩阵中结点数目的一半为图中边数。 邻接表存储：第i个链表中结点数目为顶点i的出度。有向图中，所有链表中结点数目为图中弧数。 优点 邻接矩阵存储：优点：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。缺点：n个顶点需要n*n个单元存储边(弧);空间效率为O(n^2)。对稀疏图而言尤其浪费空间。 邻接表存储：优点：空间效率高；容易寻找顶点的邻接点；缺点 ：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。 邻接矩阵存储有向图、无向图定义： 有向图邻接矩阵 设图G=（V，E）是有n（n ≥ 1）个顶点的图，则G的邻接矩阵是具有下述性质的 n x n 的方阵，元素为： 无向图邻接矩阵 与有向图邻接矩阵类似。 例子 有向图的邻接矩阵结论： 矩阵不一定是对称的。 第 i 行中1的个数为顶点 i 的出度。 第 i 列中1的个数为顶点 i 的入度。 矩阵中1的个数为图中弧的数目。 很容易判断顶点 i 和顶点 j 是否有弧相连。 无向图的邻接矩阵结论： 矩阵是对称的，可压缩存储（上/下三角）。 第 i 行或第 i 列中1的个数为顶点 i 的度。 矩阵中1的个数的一半为图中边的数目。 很容易判断顶点 i 和顶点 j 之间是否有边相连(看矩阵中i行j列值是否为1)。 网 邻接表存储无向图： 有向图： 网： 遍历从图中指定顶点出发访问图中每一个顶点，且使每个顶点只被访问一次，该过程为图的遍历。 深度优先搜索法DFS（Depth First Search） 从图中某个顶点V0出发，并访问此顶点； 从V0出发，访问与V0邻接的顶点V1后，再从V1出发，访问与V1邻接且未被访问过的顶点V2。重复上述过程，直到不存在未访问过的邻接点为止。 如果是连通图，从任一顶点V0出发，就可以遍历所有相邻接的顶点；如果是非连通图，则再选择一个未被访问过的顶点作为出发点，重复step1、step2，直到全部被访问过的邻接点都被访问为止。 简单来说，DFS一条路走到底，走到底之后逐步回退至未走的另一条路的分叉结点，走另一条路，直至最终返回起点，并且所有节点都已遍历。 深度优先搜索法类似于树的先根遍历法。 例： 链接表例：（叉表示已遍历的结点） 广度优先搜索法BFS（Breadth First Search） 从图中某个顶点V1出发，并访问此顶点。 从V1出发，访问V1的各个未曾访问的邻接点V2，V3，…,Vk;然后,依此从V2,V3,…,Vk出发访问各自未被访问的邻接点。 重复step2，直到全部顶点都被访问为止。 广度优先搜索法类似于树的层次遍历法。 例： 链接表例：此处仅将链表有数据的第一行遍历完毕的情景，此后按照队列的“先进先出”的特点，取出并查找V2的链接表，此处V1已遍历，跳过并将之后的V4，V5按顺序加入队列，V2结点遍历结束，取出并查找V3的链接表，以此类推，直至所有节点都已遍历。 应用最小生成树定义连通图G的一个子图如果是一棵包含G的所有顶点的树，则该子图称为G的生成树。生成树各边的权值总和称为生成树的权。权最小的生成树称为最小生成树。 生成树是连通图的极小连通子图。所谓极小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。 该问题是构造连通图的最小代价生成树问题。一棵生成树的代价就是树上各边（弧）的代价之和。 实现方法普里姆（Prim）算法思想：假设N=（V，E）是连通图，TE是N上最小生成树中边的集合。 从U={u0} （u0∈V），TE=空 开始。 重复执行：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0,v0）并入TE，同时u0 并入U，直到U=V为止； 此时TE中必有n-1条边，则T=（V，TE）为N的最小生成树。 个人理解：将已连接的结点看成一个整体，选取该整体与其他散的结点权值最小的路径连接。 例： 鲁斯卡尔（Kruskal）算法思想：假设N=（V，E）是连通图 取图中每个顶点自成一个连通分量。 在{ E }中选择代价最小的边，若该边所依附的顶点落在T中不同的连通分量上，则将此边加入生成树T中；否则，舍去此边，再选择下一条代价最小的边。 重复上述步，直到T中所有顶点都在同一连通分量上为止。 个人理解：始终找最短路径，除非该路径能使树形成回路。 例： 最短路径单源最短路径（Dijkstra算法）思路： 首先求出长度最短的一条路径； 再参照它求出长度次短的一条路径； 依次类推，直到从顶点v到其它顶点的最短路径全部求出为止。 例子： 每对顶点间的最短路径（Floyd算法）转：Floyd算法(三)之 Java详解 拓扑排序方法步骤： 在有向图中选一个没有前驱的顶点并输出; 从图中删除该顶点和所有以它为尾的弧; 重复前2步,直到全部顶点均输出为止。 输出序列即为拓扑排序序列。 拓扑排序序列不唯一。 转：拓扑排序详解与实现","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（10）——查找","slug":"数据结构笔记10","date":"2020-05-30T01:45:00.000Z","updated":"2020-07-06T04:03:19.918Z","comments":true,"path":"2020/05/30/数据结构笔记10/","link":"","permalink":"/2020/05/30/数据结构笔记10/","excerpt":"","text":"基本概念 关键码 数据元素或纪录中的某个数据项的值，用它可以标识一个数据元素或纪录。 查找 在一个给定的数据结构中，根据给定的条件查找满足条件的结点。 查找方法 静态查找：顺序查找、折半查找、分块查找、费氏查找、插补查找动态查找：散列查找、树型查找 查找方法评价 查找速度占用存储空间算法本身复杂程度平均查找长度ASL(Average Search Length)：为确定记录在表中的位置，需和给定值进行比较的关键字的个数的期望值叫查找算法的ASL。 静态查找部分静态查找算法比较 顺序查找查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较。 参考代码注：只能返回首个与指定关键字相符的关键字位置。 /** * 在顺序表中查找指定元素 * * @param list 给定顺序表 * @param key 查找关键字 * @return 查找成功返回指定位置，否则返回 -1 */ public static int seqSearch(int[] list, int key) { for (int i = 0; i &lt; list.length; ++i) { if (list[i] == key) { return i; } } return -1; } ` 算法分析ASL： 优点：算法简单，无需排序，采用顺序和链式存储均可。 缺点：平均查找长度较大，更加费时。 折半查找（二分查找）算法思想和前提 算法思想 先确定待查找记录所在的范围，然后逐步缩小范围，直到找到或确认找不到该记录为止。 前提 必须在具有顺序存储结构的有序表中进行。 算法演示分三种情况： 若中间项的值等于x,则说明已查到。 若x小于中间项的值，则在线性表的前半部分查找。 若x大于中间项的值，则在线性表的后半部分查找。 成功找到的例子： 未成功找到的例子： 参考代码注：只能返回首个与指定关键字相符的关键字位置。 /* * @param list 已经排序好的顺序表 * @param key 查找关键字 * @return 查找成功返回指定位置，否则返回 -1 */ public static int binarySearch(int[] list, int key) { int begin = 0, end = list.length - 1, mid; while (begin &lt;= end) { mid = (begin + end) / 2;//mid向下取整 if (list[mid] == key) { return mid; }else if (key &lt; list[mid]) { end = mid-1 ; }else { begin = mid+1 ; } } return -1; } ` 算法分析如果把当前查找位置上的结点作为根，左子表和右子表的结点分别作为根的左子树和右子树，由此得到的二叉树称为描述折半查找的判定树。 借助于判定树很容易求得折半查找的平均查找长度。 设结点总数为n，其高度为k，那么 2^(k-1)-1 &lt; n ≤ 2^k -1 折半查找的算法复杂度为：log2 nASL = 各个结点层数的平均数（以图中为例：(ASL = （1+2×2+3×4+4×4）/11=3 ） 即在最坏情况下，折半查找方法查找成功的比较次数不超过判定树的高度。 虽然折半查找的效率较高，但它要求被查找序列事先按关键字排好序，而排序本身是一种很费时的运算；另外，折半查找只适用于顺序存储结构。 因此，折半查找特别适用于那种一经建立就很少改动、而又需要经常查找的线性表。 分块查找算法思想首先，查找索引表，因为索引表是有序表，故可采用二分查找，也可以采用线性查找，以确定待查的结点在哪一块；然后在以确定的那一块中顺序查找。 适用条件分块有序表 算法演示 参考代码默认给定顺序表、索引表、块地址表。 /** * @param indexTable 索引表 * @param seqList 已经分好块的顺序表 * @param addressTable 块地址表 * @param key 查找关键字 * @return 查找成功返回指定位置，否则返回 -1 */ public static int blkSearch(int[] indexTable, int[] seqList, int[] addressTable, int key) { // 首先通过折半查找找到所在块的起始地址 int begin = 0, end = indexTable.length - 1, mid; while (begin &lt;= end) { mid = (begin + end) / 2; if (key &lt;= indexTable[mid]) { end = mid - 1; } else { begin = mid + 1; } } // 查找完毕，begin为所在块，然后进行顺序查找 int seqSearchEnd; // 如果所在块为最后一块 if (begin == indexTable.length - 1) { seqSearchEnd = seqList.length; } else { seqSearchEnd = addressTable[begin + 1]; } for (int i = addressTable[begin]; i &lt; seqSearchEnd; ++i) { if (key == seqList[i]) { return i; } } return -1; } `` 算法评价若将表长为 n 的表平均分成 b 块，每块含有 s 个记录，设表中每个记录的查找概率相等，则： 动态查找——散列查找基本思想和目标基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。 目标：提高查找效率，即缩短查表和填表的时间。 相关概念散列函数在记录的关键字与记录的存储地址之间建立的一种对应关系叫散列函数。 散列函数是一种映象，是从关键字空间到存储地址空间的一种映象，可写成：addr(ai)=H(ki) ➢ ai是表中的一个元素➢ addr(ai)是ai的存储地址➢ ki是ai的关键字 例子： 冲突和同义词散列函数只是一种映象，所以散列函数的设定很灵活，只要使任何关键字的散列函数值都落在表长允许的范围之内即可 冲突：key1 ≠ key2，但H(key1) = H(key2)的现象叫冲突。 同义词：具有相同函数值的两个关键字，叫该散列函数的同义词。 散列函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；同时，冲突发生后，应该有处理冲突的方法。 散列函数的构造方法散列法查找必须解决如下两个问题： 选择一个计算简单且冲突尽量少的“均匀的”散列函数。确定一个解决冲突的方法，即寻求一种方法存储产生冲突的的同义词。 包括：除留余数法、数值抽出法、平方取中法、折叠法、旋转法、伪随机数法 数值抽出法 将数据的关键值中的某几位数值取出后，作为数据存储的位置。 例：数据的关键值为一组6位数的号码。我们假设关键值中的第1位、第2位、第5位作为数据位置的索引值，则：136781=&gt;138215484=&gt;218021157=&gt;025 平方取中法 将数据的关键值中的前几位数取出后平方产生一个新的数值，再从新产生的数值中取出中间的某几位作为数据存储的位置。 例：决定以数据的关键值的前3位，平方后产生一个新的数值，再从新的数值中取第2位到第4位作为数据位置的索引值。325483=&gt;325×325=105625=&gt;056213457=&gt;213×213=045369=&gt;453654875=&gt;654×654=427716=&gt;277 折叠法 将数据的关键值中分为多层，然后相加后取其结果作为数据存储的位置。 例:关键值为123456789，将关键值分成三层后，运算后的结果如下：&nbsp;&nbsp;123&nbsp;&nbsp;456+789——1368最后，我们取368为数据存储的位置。 处理冲突的方法开放定址法线性探测法 思想 将散列表看成是一个环形表。若地址为d（即H(key)=d）的单元发生冲突，则依次探查下述地址单元：d+1，d+2，……，m-1，0，1，……，d-1直到找到一个空单元或查找到关键字为key的结点为止。当然，若沿着该探查序列查找一遍之后，又回到了地址d，则无论是做插入操作还是做查找操作，都意味着失败。 例子 表长为11的哈希表中已填有关键字为17，60，29的纪录，H(key)=key MOD 11,现有第4个记录，其关键字为38，按线性探测法，将它填入表中。 二次方探索法 思想 当散列函数产生的数据地址已有数据存在时，以现在的数据地址加上冲突次数的平方，当数据地址超出数组大小时，则让数据地址采用循环的方式处理。 例子 假设第一次发生散列冲突的位置在1，数组的大小为80，其运作方式为： 双哈希函数法 思想 这个方法使用两个散列函数 H1 和 H2 ，若 H1 (key)=d 时发生冲突，则再计算 H2 (key)，得到的探查序列为：(d+H2 (key))%m，(d+2 H2 (key))%m ，(d+3 H2 (key))%m ，… 例子 已知一组关键字(19,14,23,1,68,20,84)。哈希函数H(key)=key MOD 13, 哈希表长为 m=16，ReH(key)=int(key+3)MOD 7，用双哈希函数处理冲突。 差值解决法 思想 当发生杂凑碰撞时，以现在的数据地址加上一个固定的差值，当数据地址超出数组大小时，则让数据地址采用循环的方式处理。 例子 假设现有数据（23 57 65 63 67 33），采用除留余数法hash(k)=k%10，数组大小为10，差值为3。试插入这些数据。产生冲突数据以33为例：33%10 = 3（已插入23），（33+3）%10 = 6（已插入63），（33+6）%10 = 9 链地址法 思想 将同义词结点拉成一个链表，将各链表的投指针按杂凑函数计算出来的地址顺序组织在相应的指针数组中。 例子 关键字(19,14,23,1,68,20,84,27,55,11,10,79)，通过链表解决方法，将其插入对应的位置。 分桶杂凑法 思想 建立两个表：一个基本表，每个单元只能存放一个元素；另一个是溢出表，将产生冲突的值放入该表。 动态查找——树型查找二叉排列树，B树","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（9）——排序","slug":"数据结构笔记9","date":"2020-05-19T01:45:00.000Z","updated":"2021-08-18T07:03:17.807Z","comments":true,"path":"2020/05/19/数据结构笔记9/","link":"","permalink":"/2020/05/19/数据结构笔记9/","excerpt":"","text":"在学习过程中，断断续续写了一个月。 基本概念 排序 将一组杂乱无章的数据按一定的规律排列起来（递增或递减）。 排序的分类(按待排序涉及的存储器不同) 内排序：待排序记录存放在内存外排序：排序过程中需对外存进行访问。 排序的分类(按排序依据的原则) 插入排序：直接插入排序、希尔排序。交换排序：冒泡排序、快速排序。选择排序：直接选择排序、堆排序。归并排序：2-路归并排序。基数排序。 排序的特性 关键字相同的记录在排序过程中是否保持前后次序不变。注：以下例子中数据“2”没有任何区别，只是在此对其先后顺序进行标记。关于判别是否是稳定排序的方法：如果算法中关键字是依次比较的，那么几乎可以确定这个排序是稳定的。 排序的基本操作 1、比较两个关键字大小2、将记录从一个位置移动到另一个位置 排序的时间开销 是衡量算法好坏的最重要的标志。通常用算法执行中的关键字比较次数和关键字移动次数来衡量。 选取排序方法时需要考虑的因素 待排序的记录数目 记录本身信息量的大小 关键字的结构及其分布情况 对排序稳定性的要求 语言工具的条件、辅助空间的大小 排序算法均以升序为例。 插入排序每步将一个待排序的对象，按其关键字大小，插入到前面已经排好序的一组对象适当位置上，直到对象全部插入为止。 直接插入排序此方法为稳定排序。 思想插入第i个对象时，前面的V[0],V[1], …,V[i-1]已排好序，此时，用v[i]的关键字与V[i-1], V[i-2],…的关键字顺序进行比较，找到插入位置即将V[i]插入，原来位置上对象向后顺移。 示例 希尔排序(缩小增量排序)此方法为不稳定排序。 思想先取一个正整数 d1 &lt; n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2 &lt; d1，重复上述分组和排序操作；直至di=1，即将所有记录放进一个组中排序为止。 当d = 1 是与直接插入排序相同，但由于之前关键字较小的记录已跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序，所以能够节省运算时间。 示例 参考代码/** * 直接插入算法（升序） * @param arr 需要排序的int数组 * @return 排好序的int数组 */ public static int[] insertSort(int[] arr){ //如果数组中没有或只有一个元素，无需排序，直接返回。 if (arr.length == 0 || arr.length == 1) return arr; int j; //从数组中位置为1的数据开始，循环至最后一个 for (int i = 1 ; i&lt;arr.length ; i++){ //储存当前所选数据 int theNum = arr[i]; //从当前数据往前读取，依次向后移动并判断，直至循环完毕或遇到比其更小的数据，储存当前位置j for (j = i-1 ; j&gt;=0 ; j--){ arr[j+1] = arr[j]; if (arr[j]&lt;theNum)break; } //将数据输入至j位置 arr[j+1] = theNum; } //返回已排好序的数组 return arr; } /** * 希尔算法（升序） * @param arr 需要排序的int数组 * @return 排好序的int数组 */ public static int[] shellSort(int[] arr){ //如果数组中没有或只有一个元素，无需排序，直接返回。 if (arr.length == 0 || arr.length == 1) return arr; int n; //将步长n取为当前数组长度一半，向下取整，之后依次循环/2，直至n=1 for(n = (int)(Math.floor(arr.length / 2));n&gt;=1;n = (int)(Math.floor(n / 2))){ //与直接插入排序类似，只是步长从1改为n for(int i = n ; i &lt; arr.length ; i+=n){ int theNum = arr[i]; int j; for (j = i-n ; j &gt;= 0 ; j-=n){ arr[j+n] = arr[j]; if (theNum&gt;arr[j]) break; } arr[j+n]= theNum; } } //返回已排好序的数组 return arr; } /** * 输出用 * @param arr int数组 */ public static void print(int[] arr) { // TODO Auto-generated method stub if(arr == null)System.out.println(&quot;列表为null&quot;); System.out.print(&quot;[&quot;); for (int i = 0 ; i &lt; arr.length ; i++){ if(i == arr.length -1 ) { System.out.println(arr[i]+&quot;]&quot;); break; } System.out.print(arr[i]+&quot;,&quot;); } } ` 测试主函数public static void main(String[] args){ int[] arr = {1,3,6,4,2,5,0,7}; System.out.print(&quot;排序前：&quot;); print(arr); System.out.println(&quot;排序后：&quot;); print(insertSort(arr)); print(shellSort(arr)); } `` 结果排序前：[1,3,6,4,2,5,0,7] 排序后： [0,1,2,3,4,5,6,7] [0,1,2,3,4,5,6,7] ` 复杂度分析一、空间复杂度： 只需要一个记录的辅助空间。 二、时间复杂度： 直接插入排序 希尔排序 平均比较次数和对象平均移动次数在 n^1.25 与 1.6*n^1.25 之间。 交换排序两两比较待排序的对象的关键字，如果发生逆序，则交换之，直到全部对象都排好序为止。 冒泡排序此方法为稳定排序。 思想 将第一个记录的关键字与第二个记录的关键字进行比较，若为逆序r[1].key&gt;r[2].key，则交换；然后比较第二个记录与第三个记录；依次类推，直至第n-1个记录和第n个记录比较为止。此时为第一趟冒泡排序，结果关键字最大的记录被安置在最后一个记录上。 对前n-1个记录进行第二趟冒泡排序，结果使关键字次大的记录被安置在第n-1个记录位置。 重复上述过程，直到“在一趟排序过程中没有进行过交换记录的操作”为止。 示例 快速排序此方法为不稳定排序。 若基准值比重复的关键字大的时候，后面的数据会移动到前面，因而该排序方法不稳定。 思想通过一趟排序将待排序列分成两部分，使其中一部分记录的关键字均比另一部分小，再分别对这两部分排序，以达到整个序列有序。 示例 参考代码/** * 冒泡排序，升序 * @param arr 需排列的int数组 * @return 已排列的int数组 */ public static int[] bubbleSort(int[] arr){ if (arr.length == 0 || arr.length == 1) return arr; int j,midNum; //添加一个判定是否交换的标志，如果在循环过程中某一次循环的所有元素没有交换，则说明已经排好序，并且可以提前结束循环 boolean isExchange; for (int i = 0 ; i&lt;arr.length-1 ; i++){ isExchange=false; for ( j=0 ; j &lt; arr.length-1-i; j++){ if (arr[j]&gt;arr[j+1]){ midNum = arr[j+1]; arr[j+1] = arr [j]; arr[j] = midNum; isExchange = true; } } if(!isExchange) break; } midNum = -1; return arr; } /** * 快速排序，递归，升序 * @param arr 所需排序的数组(需保证输入符合规范) * @param start 开始位置 * @param end 结束位置 * @return 已部分或完全排好序的数组 */ public static int[] quickSort(int[] arr , int start , int end){ //如果起始位置和终止位置相同，直接返回 if(start == end) return arr ; //如果满足开始位置和结束位置在0~数组长度-1的返回内，并且开始位置小于结束位置时 if(start&lt;end &amp;&amp; start&gt;=0 &amp;&amp; start&lt;=arr.length-1 &amp;&amp; end&gt;=0 &amp;&amp; end&lt;=arr.length-1){ //创建首尾指针 int i = start; int j = end; //取出基准值 int theNum = arr[i]; //循环至首尾指针相等 while(i!=j){ //首指针不动，尾指针循环从右往左寻找比基准值小的数据，并将尾指针所指数据赋予首指针所指位置 while(i&lt;j &amp;&amp; arr[j]&gt;=theNum) j-=1; if(i&lt;j) {arr[i]=arr[j];i+=1;} //尾指针不动，首指针循环从左往右寻找比基准值大的数据，并将首指针所指数据赋予尾指针所指位置 while(i&lt;j &amp;&amp; arr[i]&lt;=theNum) i+=1; if(i&lt;j) {arr[j]=arr[i];j-=1;} } //此时首尾指针相等，将基准值赋予该位置 arr[i] = theNum; //递归运算 quickSort(arr,start,i-1); quickSort(arr,i+1,end); } //返回部分或完全已排序好的数组 return arr; } ``` 复杂度分析 冒泡排序 总共要进行 n-1 趟，对 i 个记录的表进行一趟冒泡需要 i-1 次关键码比较，所以： 快速排序 时间复杂度： 最好情况（每次总是选到中间值作枢轴）:T(n)=O(nlog2n) 最坏情况（每次总是选到最小或最大元素作枢轴）:T(n)=O(n²) 空间复杂度： 最坏情况：S(n)=O(n) 一般情况：S(n)=O(log2n) 选择排序将待排序的结点分为已排序(初始为空)和为未排序两组，依次将未排序的结点中值最小的结点插入已排序的组中。 直接选择排序此方法为不稳定排序。 若第二个重复关键字之后存在比其小的关键字，那么在排序中第一个重复关键字会与后面更小的关键字交换，从而导致该算法不稳定。 比如：49 50 49* 13 思想 通过 n-1 次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换。 再通过 n-2 ，n-3 ，…… 次共 n-1 次排序后，排序结束。 示例 堆排序此方法为不稳定排序。 思想先将无序序列建成一个堆，得到关键字最小（或最大）的记录；输出堆顶的最小（大）值后，使剩余的n-1个元素重又建成一个堆，则可得到n个元素的次小值；重复执行，得到一个有序序列。 整个排序过程可分为以下三步： 将一个无序序列建成一个堆。 输出堆顶元素。 调整剩余元素，使之成为一个新的堆。 重复2、3步骤，直至输出完毕。 示例以将{49 38 65 97 76 13 27 50}按升序排列为例。 将该序列建成一个最小堆。 输出堆顶元素，并调整剩余元素，使之成为一个新的最小堆。 同理，重复上一步，直至清空堆。 参考代码需要注意的是：在堆排序算法中构建的堆优先用顺序储存；若升序排列则需要构建最大堆，降序排列需构建最小堆，可降低空间复杂度。 /** * 直接选择排序，升序 * @param arr 需要排序的int数组 * @return 排好序的int数组 */ public static int[] straight_selectSort(int[] arr){ //如果数组长度为0或1，直接返回 if(arr.length == 0 || arr.length == 1) return arr; int midNum; //循环（数组长度-2）次排序 for (int i = 0 ; i&lt;arr.length-1 ; i++){ //创建未排序部分最小数据位置 int min_index = i; //循环寻找未排序部分的最小数据 for (int j = i+1 ; j&lt;arr.length ; j++){ if(arr[j]&lt;arr[min_index]) min_index = j; } //未排序部分的最前端数据与最小数据调换，并并入已排序部分 midNum = arr[i]; arr[i] = arr[min_index]; arr[min_index] = midNum; } //返回已排好序的数组 return arr; } /** * 堆排序，升序 * @param arr 需排列的int数组 * @return 已排好列的int数组 */ public static int[] heapSort(int[] arr){ //将拥有n个数据的数组创建为最大堆 //注：在循环过程中始终保证根结点为arr[i]的堆为最大堆，下方同理 for(int i = arr.length/2-1 ; i&gt;=0 ; i--){ to_maxheap(arr,i,arr.length-1); } int midNum; //每次将n个数据的最大堆的最大值（根结点，第0位置）与数组最后一个数调换，并将前n-1个重新排为最大堆。 //依次类推，共循环n次 for(int i = arr.length-1 ; i&gt;=1 ; i--){ midNum = arr[i]; arr[i] = arr[0]; arr[0] = midNum; to_maxheap(arr,0,i-1); } //数据初始化并返回 midNum = 0; return arr; } /** * 创建最大堆 * @param arr int数组 * @param root 堆的根结点 * @param end 范围 */ private static void to_maxheap(int[] arr,int root,int end) { // TODO Auto-generated method stub //寻找根结点最大子结点，初始化为左子结点 int max_child = root * 2 + 1; int maxNum; //当最大子结点在root~end范围内时循环 while(max_child&lt;=end){ //如果根结点右子结点比左子结点大，最大子变更为右子结点 if(max_child&lt;end &amp;&amp; arr[max_child]&lt;arr[max_child+1]/*如果需要为降序，此处为&gt;符号*/) max_child+=1; //如果子结点数据比根结点数据大，结点数据交换，并将root、max_child指针向下层移动 if(arr[root]&lt;arr[max_child]/*如果需要为降序，此处为&gt;符号*/){ maxNum = arr[root]; arr[root] = arr[max_child]; arr[max_child] = maxNum; root = max_child; max_child = 2*root+1; //否则，跳出循环 }else{ break; } } //数据初始化 maxNum = 0; } ``` 复杂度分析 直接选择排序： 时间复杂度： 移动次数：最好情况：0最坏情况：3(n-1) 比较次数： 堆排序: 时间复杂度：O(n log2(n)) 空间复杂度：O(1) 归并排序此方法为稳定排序。 思想设有两个有序表A和B，对象个数分别为al 和 bl ，变量i和j分别是两表的当前指针。 设表C是归并后的新有序表，变量k是它的当前指针。 i和j对A和B遍历时，依次将关键字小的对象放到C中，当A或B遍历结束时，将另一个表的剩余部分照抄到新表中。 示例以将{8 4 5 6 3 2 9 7}按升序排列为例。 参考代码需要注意的是：此参考代码与思想有一定出入。 但能成功排序。。 /** * 归并排序，数组中的一段 * @param arr 数组 * @param start1 第1开始位置 * @param start2 第2开始位置 * @param n 需排序的数组总长度 * @return 已排序的数组 */ private static int[] mergeSort_1(int[] arr,int start1,int start2,int n){ //创建过渡数组 int[] arr2 =new int[n]; //将数组看成两个部分，并创建指针 int p = start1,q = start2; int k = 0; //循环至p，q指针其中一个指到各部分末尾 while(p&lt;start2 &amp;&amp; q&lt;start1+n){ //取指针所指数据大的添加入过渡数组中，并取出数据的指针向后移动 if(arr[p]&lt;arr[q]){ arr2[k++]=arr[p++]; }else{ arr2[k++]=arr[q++]; } } //如果各部分还有未添加入过渡数组的数据，直接按顺序加入 if(p!=start2){ for (int i = p ; i&lt;start2 ; i++) arr2[k++] = arr[i]; } if(q!=start1+n){ for (int i = q ; i&lt;start1+n ; i++) arr2[k++] = arr[i]; } //将过渡数组中已排好序的数据添加回原来需排序数组的位置 p = start1; for(int i = 0 ; i&lt;n ; i++) arr[start1++]=arr2[i]; //返回已部分排好序的数组 return arr; } /** * 归并排序，升序 * @param arr 需排列的int序列 * @return 已排列的int序列 */ public static int[] mergeSort(int[] arr){ //如果长度为0或1，直接返回输出 if(arr.length==0 || arr.length==1) return arr; //将需排序的序列分为元素数为n的子序列，i为子序列开始位置 int n = 1,i = 0; //循环至子序列元素数n大于需排序序列 while(n&lt;arr.length){ //依次取两个子序列进行归并，结束后取之后的两个子序列 for(i = 0; i&lt;arr.length ; i+=2*n) { //若第一个子序列能取n个元素，而第二个不能取，则这两个长度不等的子序列进行归并 if(n&lt;(arr.length-i) &amp;&amp; 2*n&gt;(arr.length-i)){ mergeSort_1(arr,i,i+n,arr.length%(2*n)); //若两个子序列均完整有n个数据，则直接归并 }else if(i+2*n&lt;=arr.length){ mergeSort_1(arr,i,i+n,2*n); } //若第一个子序列无法取完整的n个元素，则跳过 } //子序列元素数×2 n*=2; } //返回已排好序的序列 return arr; } ` 复杂度分析归并排序在第 i 趟归并后，有序子序列长度为 2i 。对于具有 n 个记录的序列来说，必须做 log2(n) 趟归并，每趟归并所花的时间为 O(n)。 所以，二路归并排序算法的时间复杂度为 O(n log2(n))，空间复杂度为 O(n)。 基数排序 基本原理 采用“分配”和“收集”的办法，用对多关键字进行排序的思想实现对单关键字进行排序的方法。 多关键字排序原理 以扑克牌为例 每张扑克牌有两个“关键字”：花色和面值，它们之间有次序的优先。 对以上排序，可以先对花色排序，或先对面值排序，之后再对另一个关键字排序。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记(8.4.2)——二叉树的应用：二叉排列树，线索二叉树","slug":"数据结构笔记8.4.2","date":"2020-05-12T01:45:00.000Z","updated":"2021-08-18T07:08:57.173Z","comments":true,"path":"2020/05/12/数据结构笔记8.4.2/","link":"","permalink":"/2020/05/12/数据结构笔记8.4.2/","excerpt":"","text":"二叉排序树概念在二叉排序树中，若按中序遍历就可以得到由小到大的有序序列，即{ 2，3，3，7，8，10，12，18 } 构造将添加的数据若小于根结点的数据，则放在根结点的左子树中；若大于等于根结点的数据，则放在右子树中。 构造参考算法核心//结点 static class Node{ int data; Node left; Node right; public Node(int data){ this.data = data; } } //二叉排列树 static class Tree{ /** * 添加数据 * @param root 根结点 * @param data 添加数据 * @return 根结点 */ private Node add(Node root , int data){ //如果根为null，直接添加 if (root == null) { return new Node(data); //当数据小于根结点的数据时，添加至左子树中，反之则添加至右子树中 //相等时结点位于右子树 } else if (data &lt; root.data) { root.left = add(root.left, data); } else { root.right = add(root.right, data); } return root; } } `` 输出用直接采用之前的文章的参考代码。 import java.util.ArrayList; import java.util.Stack; /** * 中序 * @param root 树的根结点 * @return 中序遍历序列数组 */ public static ArrayList&lt;Object&gt; inOrder(Node root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); //创建中序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向根结点 Node p = root; //循环至p指针为null，以及栈为空。 while(p!=null || !stack.isEmpty() ){ //依次将左子树结点入栈，直至为null while(p!=null){ stack.add(p); p = p.left; } /* * 如果指针p和栈均为空，则遍历完成 * 如果栈不为空，弹出的栈顶结点，数据入组，p指针指向该节点右子节点 */ if(!stack.isEmpty()){ p = stack.pop(); list.add(p.data); p = p.right; } } //返回中序遍历序列数组 return list; } 主函数测试//主函数测试 public static void main(String[] args){ Node root = new Node(1); int[] datas = {3,2,4,6,5}; Tree BSTree = new Tree(); for(int i = 0 ; i&lt;datas.length ; i++){ BSTree.add(root,datas[i]); } ArrayList&lt;Object&gt; list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.print(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } } ` 结果中序遍历序列为：[1,2,3,4,5,6] 二叉排序树的查找算法此处参考代码只判断二叉排列树中是否有该数据。 核心(此处应加在上文class Tree中) /** * 查找指定值的结点 * @param root 父节点 * @param data 查找值 * @return true代表找到 */ private boolean search(Node root, int data) { //如果为空树，返回false if (root == null) {return false;} //如果查找到，返回true if (data == root.data) {return true; } //如果未找到，并且结点数据大于查找的数据，进入左子树 else if (data &lt; root.data) {return search(root.lchild, data); } //未找到，并且结点数据小于等于查找数据，进入右子树 else {return search(root.rchild, data); } } ` 主函数测试//主函数测试 public static void main(String[] args){ Node root = new Node(1); int[] datas = {3,2,4,6,5}; Tree BSTree = new Tree(); for(int i = 0 ; i&lt;datas.length ; i++){ BSTree.add(root,datas[i]); } ArrayList&lt;Object&gt; list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.println(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } //查找 int find = 2; if (BSTree.search(root, find)) { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，找到&quot;+find+&quot;元素&quot;); } else { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，未找到&quot;+find+&quot;元素&quot;); } int find1 = 10; if (BSTree.search(root, find1)) { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，找到&quot;+find1+&quot;元素&quot;); } else { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，未找到&quot;+find1+&quot;元素&quot;); } } `` 结果中序遍历序列为：[1,2,3,4,5,6] 在以1为根结点的二叉排列树中，找到2元素 在以1为根结点的二叉排列树中，未找到10元素 `` 二叉排序树的删除原则：删除某结点以后，依旧是一棵二叉排序树。 删除二叉排序树中的p结点，分三种情况。 p为叶子结点。只需修改p双亲f的指针。 p只有左子树或右子树。用p的左孩子或右孩子代替p。 p左、右子树均非空。 沿p左子树的根C的右子树分支找到S，S的右子树为空，将S的左子树成为S的双亲Q的右子树，用S取代p。 若C无右子树，用C取代p。 核心//二叉排列树 static class Tree{ /** * 删除指定结点 * @param root 根结点 * @param data 删除的数据（若二叉树中存在重复数据，优先删除靠近左子树根结点的结点） */ private Node remove(Node root , int data){ //查找指定结点 Node theNode = search_Node(root,data); //若没找到，不进行操作 if (theNode == null) { System.out.println(&quot;未找到&quot;+data+&quot;结点，不进行操作&quot;); return root; } int thedata = theNode.data; //找到父母结点 Node parNode = search_parentNode(root,theNode); //若该结点为叶子节点，直接删除，并删除并将父母结点的指向删除 if(theNode.left == null &amp;&amp; theNode.right == null){ //若为根结点，删除唯一的结点root if(parNode == null){ root = null; //若在左子树，父母结点的左子结点删除 }else if(parNode.left == theNode){ parNode.left = null; //若在右子树，父母结点的右子结点删除 }else{ parNode.right = null; } //指针清空 theNode = null; //输出结果并返回根结点 System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; } //若该结点没有左子树或右子树，直接删除该结点，并将其父母节点的指向变为其右子树或左子树根结点 if(theNode.left == null || theNode.right == null){ //如果该结点没有左子树 if (theNode.left == null){ //如果是根结点，新根结点变为根结点的右子结点 if(parNode == null){ root = theNode.right; //如果是其父母结点的左子结点，左子结点变更为该结点的右子节点 }else if(parNode.left == theNode){ parNode.left = theNode.right; //如果是其父母结点的右子节点，右子结点变更为该结点的右子节点 }else{ parNode.right = theNode.right; } //清空指针 theNode = null; //输出结果并返回根结点 System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; //如果该结点没有右子树，其余与上者类似 }else{ if(parNode == null){ root = theNode.left; }else if(parNode.left == theNode){ parNode.left = theNode.left; }else{ parNode.right = theNode.left; } theNode = null; System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; } } //若该结点右左右子树，找到左子树中最大值代替，并将原最大值的结点位置由其左子树根结点代替 if(theNode.left != null &amp;&amp; theNode.right != null){ //找到该结点左子树中最大的节点，作为代替的结点 Node reNode = search_MaxNode(theNode); //代替结点的父母结点的右子树变更为其左子树 search_parentNode(root,reNode).right = reNode.left; //如果该结点为根结点，新根结点变更为代替结点 if(parNode == null){ root = reNode; } //如果该结点不是根结点，即拥有父母结点，并且是其父母结点的左子结点 //该结点的父母结点的左子结点变为代替结点 else if(parNode.left == theNode){ parNode.left = reNode; //如果该结点不是根结点，即拥有父母结点，并且是其父母结点的右子结点 //该结点的父母结点的右子结点变为代替结点 }else{ parNode.left = reNode; } //如果代替结点不是该结点的左子结点，代替结点的左子结点变更为该结点的左子结点 //此时代替结点应在该结点位置 if(theNode.left != reNode){ reNode.left = theNode.left; } //代替结点的右子节点变更为该结点的右子节点 reNode.right = theNode.right; //清空指针 theNode = null; //输出结果并返回根结点 System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; } throw new RuntimeException(&quot;删除错误&quot;); } /** * 寻找父母结点 * @param root 根结点 * @param theNode 需要找的结点 * @return 父母结点（如果没有则为null） */ private Node search_parentNode(Node root,Node theNode) { if (root.data == theNode.data){return null;} while(root.left != theNode &amp;&amp; root.right != theNode){ if (root.data &lt;= theNode.data) {root = root.right;} else {root = root.left;} } return root; } /** * 查找到指定数值的结点，并返回 * @param root 根结点 * @param data 指定数值 * @return 拥有指定数值的结点 */ private Node search_Node(Node root , int data){ if (root == null) {return null;} if (data == root.data) {return root;} else if (data &lt; root.data) { return search_Node(root.left, data);} else { return search_Node(root.right, data);} } /** * 查找指定节点的左子树中最大值的结点 * @param root 指定节点 * @return 最大数值的结点 */ private Node search_MaxNode(Node root){ Node p = root.left; while(p.right != null){ p = p.right; } return p; } } ```` 主函数测试此处包含二叉排列树的构造和添加的代码。 //主函数测试 public static void main(String[] args){ Node root = new Node(80); int[] datas = {50,120,60,110,55,70,53}; Tree BSTree = new Tree(); for(int i = 0 ; i&lt;datas.length ; i++){ BSTree.add(root,datas[i]); } ArrayList&lt;Object&gt; list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.println(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } list = preOrder2(root); //删除 root = BSTree.remove(root,53); root = BSTree.remove(root,50); root = BSTree.remove(root,120); root = BSTree.remove(root,80); root = BSTree.remove(root,80); list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.println(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } } ` 结果中序遍历序列为：[50,53,55,60,70,80,110,120] 结点53已删除 结点50已删除 结点120已删除 结点80已删除 未找到80结点，不进行操作 中序遍历序列为：[55,60,70,110] `` 线索二叉树概念线索：指向前驱或后继结点的指针。 线索二叉树：加上线索的二叉链表表示的二叉树。 前驱与后继：在二叉树的先序、中序或后序遍历序列中两个相邻的结点。 线索化：对二叉树按某种遍历次序使其变为线索二叉树的过程。 优点：⚪利用线索二叉树进行中序遍历时，不必采用栈处理，其速度较一般二叉树的遍历速度快，并且节约存储空间。⚪任意一个结点都能直接找到它的前驱和后继结点。 构造在线索二叉树的结点中需增加两个标志域 ltag：若 ltag=0, lchild 域指向左孩子；若 ltag=1, lchild域指向其前驱 rtag：若 rtag =0, rchild 域指向右孩子；若 rtag=1, rchild域指向其后继。 线索二叉树中的结点所包含的区域：lchild（左子结点） ltag（左标志） data（数据） rtag（有标志） rchild（右子节点） 示例","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"方舟一周年","slug":"方舟一周年","date":"2020-05-01T08:00:00.000Z","updated":"2021-08-18T06:36:13.964Z","comments":true,"path":"2020/05/01/方舟一周年/","link":"","permalink":"/2020/05/01/方舟一周年/","excerpt":"","text":"凯尔希，原谅我有可能在头图中没有把你的脸露出来。。 最近微博上的一些事周年直播整活的鹰小姐。老板大气，老板身体健康。 哦，我亲爱的傲娇鹰小姐，自从之前你微博发错号的时候，你的傲娇御姐人设已经崩塌了，想不到你原来是在电脑前啪嗒啪嗒拍键盘的兔兔。从此之后，有了个外在高冷御姐内在却是可爱萌妹的诡异人设。 鹰小姐这人设太生艹了，运营你这样弄不会把自己弄成人格分裂吗？ 以上图均来自微博。 微博里个个都是人才，说话又好听，超喜欢在里面的。 博客专供周年直播中yj表达出的正在努力的态度是很重要的信息，即使是一个商业游戏，是要赚钱的，但能感受得出来yj对自家游戏的喜爱，期间在不停告诉玩家他们正努力制作新内容。 为什么喜欢方舟的剧情？不仅仅是因为它并非像其他许多二次元游戏中软萌的形象，它更多反映的的是阴暗的一面，表面看似平静，实则暗流涌动。 （以下地名均来自方舟世界观，请不要与现实对应，均基于档案和自我推测） 方舟最大的坑，在卡兹戴尔发生的特雷西娅和摄政王特雷西斯的王位争夺战中，特雷西斯的斩首行动为何会如此奇怪的获得成功；特雷西娅是否与博士之间有什么不可告人的计划；罗德岛前身巴别塔在解体之前博士究竟策划了什么；作为目前的唯一正统的特雷西斯强腕下统一的卡兹戴尔会走向何方。 乌萨斯是否会借整合之手乘机夺取龙门；整合运动对乌萨斯的渗透究竟到了哪一地步；帝国的高压统治和内部的腐朽，最终是否会导致爆发革命，而罗德岛在其中会扮演什么角色。 在维多利亚发生的感染者事件始末如何；皇室成员之一的王维娜为何流落街头；皇位为何空缺，使得卡兹戴尔摄政王特雷西斯乘虚而入。 谢拉格军阀、喀兰贸易公司董事长、三大家族之一的希瓦艾什家族现任族长银灰与罗德岛合作目的为何；谢拉格爆发的雪山事变的过程和结果如何，罗德岛是否参与其中。 西西里女士用了什么手段将曾经的黑手党家族赶出叙拉古。 哥伦比亚的莱茵生命在军方的投资下究竟在一些实验上走了多远；炎魔事件是否揭露了莱茵生命真正实验的冰山一角。 政局混乱的玻利瓦尔，三方混战的局面什么时候会被打破。 曾经的龙门和乌萨斯之间爆发的战争起因、过程如何；在表面“自由、博爱”的龙门背后是否还有残杀感染者等类似事件，是否是魏延武的无奈之举；魏延武和炎国高层之间有什么关系，又和柯西切发生过什么矛盾。 陈sir和塔露拉之间发生了什么；塔露拉在“那个村子”里发生了什么，为何拥有“两个影子”；前妻凯尔希的身上还有多少谜团，她对博士的不信任来源于何处；阿米娅是否接手了特雷西娅的理想，而最终是否会带领罗德岛带给泰拉大陆一线光明；加入罗德岛的W，被软禁的赫德雷，可能未牺牲的“信使”伊内丝，脱离特雷西斯控制的萨卡兹雇佣兵最终会带给依旧在迷雾中的卡兹戴尔什么变数；博士之前为何会沉睡，这是否是计划的一环。 支线剧情中：莫斯提马为何会射杀能天使的姐姐，而且最终获得了拉特兰的宽大处理；未来玻利瓦尔大行军中殿后的精英干员米格鲁为何称之为“她的最后考验”——我更愿意相信这是她在玻利瓦尔最后的任务，之后会返回罗德岛继续完成其他任务；拉狗子在家族中发生了什么，又和萨科塔之间发生过什么；以及个人私货，德克萨斯家族为何会覆灭，在以前德狗子和拉狗子在叙拉古有什么交往（虽然我是卑微的德空党）。 绝了，这样梳理下来方舟的坑还不少，而且因为我一般是满好感精二之后再看干员档案，所以可能存在许多还不知道的坑。 对于我来说，没了剧情，方舟乐趣至少少了一半，而且制作组还喜欢往里面加谜题虽然我大多看不懂，只有看看埃及研和up分析。就像埃及人海猫采访时说的那样，想改变二次元手游的固有印象，在某种程度上说确实做到了。 当然，方舟的剧情并不会单方面的表达负面情绪和思想，先给你丰满一个人物，然后在之后剧情中让他/她牺牲。依然会在残酷的泰拉大陆带来一线光明上——“即使付出代价，也总要追寻什么”（W），一次相遇、一个契机可能就会改变人一生轨迹（霜星），即使是在残酷的世界中，也存在宁可赴死，也要坚守自己意志和信念的人（爱国者）。就如同日剧一样，不会跟你说社会是美好的，未来是光明的，告诉自己这社会是现实的、残酷的、黑暗的，但又会教你如何在这样的社会中积极生活下去。这也算是比较喜欢方舟剧情的原因之一。 比如说像清流的晋升档案中写的“一定要注意那些在你面前大谈人生和理想的上级”，我怀疑文案在暗示某个人（笑） 最后，关于关卡难度的问题，表示：打突袭、超难本、危机合约时唯唯诺诺，问卷调查请继续加大力度。 方舟一周年快乐，凯尔希终于肯笑了。凯尔希现在的人设太戳我了，果然在一定深入了解后不可避免地会对凯尔希产生一些好感，剧情中愿意笑就好了。。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"《数据结构》笔记(8.4.1)——二叉树的应用：哈夫曼树","slug":"数据结构笔记8.4.1","date":"2020-04-24T01:45:00.000Z","updated":"2021-08-18T07:11:50.332Z","comments":true,"path":"2020/04/24/数据结构笔记8.4.1/","link":"","permalink":"/2020/04/24/数据结构笔记8.4.1/","excerpt":"","text":"基本术语路径：在一棵树中，从一个结点往下可以达到的孩子或子孙结点之间的通路。 路径长度：通路中分支的数目。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 结点的权：若将树中结点赋给一个有着某种含义的数值，这个数值称为该结点的权。 带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。 树的带权路径长度：所有叶子结点的带权路径长度之和，记为WPL。 哈夫曼树(Huffman tree)定义：在一棵二叉树中，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。 特点 哈夫曼树中不存在度为1的结点。 哈夫曼树中权值越大的叶子结点越靠近根结点。 哈夫曼树中根结点的值等于所有叶子结点的权值之和 n个叶节点的哈夫曼树共有2n-1个结点 哈夫曼树的构造假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1 ,w2 ,…,wn , 则哈夫曼树的构造规则为： 将 w1 ,w2 ,…,wn 看成是有n棵树的森林(每棵树仅有一个结点) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和 从森林中删除选取的两棵树，并将新树加入森林 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为我们所求得的哈夫曼树 n 个权值构造哈夫曼树需n-1次合并，每次合并，森林中的树数目减1，最后森林中只剩下一棵树，即为我们求得的哈夫曼树。 示例假设给定的4个叶子结点的权分别为1,5,7,3。 初始森林 第一次合并 第二次合并 第三次合并 哈夫曼树构造算法仅供参考。 /* * 创建结点 * 结点包含：权重，父级，左子级和右子级结点 */ static class Node&lt;E&gt;{ Node&lt;E&gt; parent,left,right; int weight; public Node(int weight,Node&lt;E&gt; parent,Node&lt;E&gt; left,Node&lt;E&gt; right){ this.weight = weight; this.parent = parent; this.left = left; this.right = right; } public Node(int weight){ this(weight,null,null,null); } } /** * 创建哈夫曼树 * @param weights 叶子节点的权重集合的数组 * @return 哈夫曼树根结点 */ public static Node&lt;?&gt; BuildHTree(int[] weights){ //判断是否为空 if(weights == null) throw new RuntimeException(&quot;叶子节点为空&quot;); //创建结点数组 Node&lt;Integer&gt;[] HTree = new Node[weights.length]; //将各个权重当成一棵树，加入到森林数组中 for (int i = 0 ; i&lt;weights.length ; i++){ Node&lt;Integer&gt; theNode = new Node&lt;Integer&gt;(weights[i]); HTree[i] = theNode; } //如果只有一个节点，直接返回 if(weights.length == 1) return HTree[0]; //创建指针，当前最小的两个权重值及其位置 Node&lt;Integer&gt; p = null , q = null; int x1 = 0,x2 = 0; int index1 = 0 , index2 = 0; //循环（叶子节点个数-1）次 for (int i = 0 ; i&lt;weights.length-1;i++){ //x1，x2取最大值 x1 = Integer.MAX_VALUE; x2 = Integer.MAX_VALUE; //循环找出最小的两个权重及其位置，并将其移出森林 for (int j = 0 ; j&lt;HTree.length ; j++){ if (HTree[j] == null) continue; if (HTree[j].weight &lt;= x1){ p = HTree[j]; x1 = HTree[j].weight; index1 = j; } } HTree[index1] = null; for (int j = 0 ; j&lt;HTree.length ; j++){ if (HTree[j] == null) continue; if (HTree[j].weight &lt;= x2){ q = HTree[j]; x2 = HTree[j].weight; index2 = j; } } HTree[index2] = null; //创建新的结点，并构建新的树 Node&lt;Integer&gt; newNode = new Node&lt;&gt;(p.weight+q.weight); newNode.left = p; newNode.right = q; p.parent = newNode; q.parent = newNode; //将树加入到森林中 HTree[index1] = newNode; } //找到最后一颗树的位置 for (int i = 0 ; i&lt;weights.length ; i++){ if (HTree[i] != null) {x1 = i ; break;} } //输出根结点 return HTree[x1]; } `` 测试时所需的非必要方法直接使用的二叉树遍历的递归算法。 /** * 二叉树的遍历（使用的之前的递归遍历） */ public static class TreeTraver{ //先序 public static void preOrder(Node&lt;?&gt; root){ if(root == null) return; System.out.print(root.weight + &quot; &quot;); preOrder(root.left); preOrder(root.right); } //中序 private static void inOrder(Node&lt;?&gt; root){ if (root == null) return; inOrder(root.left); System.out.print(root.weight + &quot; &quot;); inOrder(root.right); } //后序 private static void postOrder(Node&lt;?&gt; root){ if (root == null) return; postOrder(root.left); postOrder(root.right); System.out.print(root.weight + &quot; &quot;); } } 主函数测试//主函数测试 public static void main(String[] args){ int[] weights = {1,3,5,7,6}; Node&lt;?&gt; BTree = BuildHTree(weights); System.out.print(&quot;先序遍历序列：&quot;); TreeTraver.preOrder(BTree); System.out.println(); System.out.print(&quot;中序遍历序列：&quot;); TreeTraver.inOrder(BTree); System.out.println(); System.out.print(&quot;后序遍历序列：&quot;); TreeTraver.postOrder(BTree); System.out.println(); } ` 结果先序遍历序列：22 9 4 1 3 5 13 6 7 中序遍历序列：1 4 3 9 5 22 6 13 7 后序遍历序列：1 3 4 5 9 6 7 13 22 ` 哈夫曼树的应用之一：数据编码定长编码在特定条件下的通讯中，要将待传字符转换成二进制组成的字符串。 例： 设要传输的字符为：ACDBADDDDD 采用定长编码方式：A——00；B——01；C——10；D——11 传输时编码为：00101101110011111111（20位） 可看出此方法缺陷：字符A和D出现频率比B、C高，而它们占用了相同空间，导致一定空间的浪费。 变长编码单个编码的长度不一致，可以根据整体出现频率来调节，出现频率越高，编码长度越短。 变长编码优于定长编码的是，变长编码可以将短编码赋予平均出现频率较高的字符，同一消息的编码长度小于定长编码。 既可节约空间，又可节约传输时间。 例： 设要传送的字符为:ACDBADDDDD 频次：A:2；B:1；C:1；D:6 采用二叉树设计二进制前缀编码。 假设：左分支为“1”，右分支为“0”。 由此得到字符的前缀码为：A——01B——001C——000D——1 最终传输时编码为：0100010010111111（16位）","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.3）——二叉树的非递归遍历算法","slug":"数据结构笔记8.3","date":"2020-04-21T01:45:00.000Z","updated":"2021-08-18T07:16:52.403Z","comments":true,"path":"2020/04/21/数据结构笔记8.3/","link":"","permalink":"/2020/04/21/数据结构笔记8.3/","excerpt":"","text":"二叉树遍历递归算法 导入的包，树、队列的构建其实完全可以不用导入动态数组ArrayList包的，这只是我比较倾向于用而已。 import java.util.ArrayList; import java.util.Stack; `` 栈在先序、中序、后序遍历中使用。队列在层次遍历中使用。（其实这是直接搬用的前面用数组构建循环队列的方法，懒得再写一遍而已） /** * 创建结点，包含数据，左右子结点地址 */ static class Node&lt;E&gt;{ E data; Node&lt;E&gt; right; Node&lt;E&gt; left; //相关数据的添加 public Node(E data , Node&lt;E&gt; right , Node&lt;E&gt; left){ this.left = left; this.right = right; this.data = data; } //初始化 public Node(E data){ this(data,null,null); } } /** * 创建树 */ public static class LinkedTree&lt;E&gt;{ //根结点 Node&lt;E&gt; root; //初始化树 public LinkedTree(E data){ root = new Node&lt;&gt;(data); } /** * 添加结点 * @param data 添加的数据 * @param father 父级结点地址 * @param isLeft 是否为父级结点的左子结点 * @return 添加的结点 */ public Node&lt;E&gt; add(E data , Node&lt;E&gt; father , boolean isLeft){ if(father == null) throw new RuntimeException(&quot;无父级，拒绝添加&quot;); Node&lt;E&gt; theNode = new Node&lt;&gt;(data); if(isLeft){ father.left = theNode; }else{ father.right = theNode; } return theNode; } } /** * 循环队列 */ static class QueueArray&lt;E&gt;{ //设定队列，队的容量，前端和后端，元素数量。 //前端为队头元素位置，后端下标为队尾元素后一个位置。 private int size = 20 ; private Object[] que_arr ; private int front ; private int rear ; private int count ; //初始化队列 public QueueArray(){ que_arr =new Object [size] ; this.front = 0 ; this.rear = 0 ; this.count = 0; } /** * 入队 * @param data */ public void In(E data){ //判断是否队满 if (count == size){ throw new RuntimeException(&quot;队满&quot;); } //添加数据，元素总数+1 que_arr[rear] = data ; ++count; //队尾标号的增加 if (rear+1 &gt;= size){ rear = 0; }else{ ++rear; } } /** * 出队 * @return 队头元素 */ public Object Out(){ if (count == 0){ throw new RuntimeException(&quot;队空&quot;); } Object data = que_arr[front]; que_arr[front] = null ; --count; if (front+1 &gt;= size){ front = 0; }else{ ++front; } return data; } } /** * 输出 * @param list 需输出的数组 */ public static void print(ArrayList&lt;Object&gt; list){ for (int i = 0 ; i&lt;list.size() ; i++) System.out.print(list.get(i)+&quot; &quot;); System.out.println(); } ` 先序遍历思想1循环控制： 1、入栈前，指向本结点；2、先左子树一次入栈并输出（入栈前先指向该结点），直到没有左子树的结点为止；3、出栈顶元素，然后找到右子树，继续1、2操作，直到栈为空且结点为空。 举例 指针指向根结点，将左子树结点1、2、3循环依次入栈并输出，直至没有左子树结点，指针为null。 栈中元素：1 2 3 输出元素：1 2 3 栈顶结点3出栈，无右子结点，之后栈顶结点2出栈，指针指向结点2的右子结点5，继续重复一步骤：将结点5的左子树结点循环入栈并输出，当然此处5为叶子结点，无左子节点。 栈中元素：1 5 输出元素：1 2 3 5 结点5出栈，无右子结点，之后栈顶结点1出栈，指针指向结点1的右子结点4，同上。 栈中元素：4 输出元素：1 2 3 5 4 结点4出栈，无右子结点，此时栈为空，指针指向结点4的左子结点null，遍历结束。 栈中元素： 输出元素：1 2 3 5 4 参考代码/** * 先序1 * @param root 树的根结点 * @return 先序遍历序列数组 */ public static ArrayList&lt;Object&gt; preOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建暂时存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建先序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向root Node&lt;Object&gt; p = root; //循环至栈空 while(p!=null || !stack.isEmpty() ){ /* * 循环将p结点和左子结点入栈入组，直至p为null */ while(p!=null){ stack.add(p); list.add(p.data); p = p.left; } /* * 如果p为null，栈为空，表明遍历结束 * 如果栈不为空，弹出栈顶结点，p指针指向该节点的右子节点（有可能为null） * 继续循环将p的左子节点入栈入组 */ if(!stack.isEmpty()){ p = stack.pop(); p = p.right; } } //返回后序遍历序列数组 return list; } 思想2使用一个栈，首先将根结点入栈，开始循环： 从栈中退出当前结点p，先访问它，然后将其右孩子入栈，再将其左孩子入栈，如此直到栈为空。（因为对左孩子的访问先序遍历先于右孩子，后入栈的先访问） 举例 结点1入栈。 栈中元素：1 输出元素： 栈顶结点1出栈，输出结点1，并将结点1的右子结点4先入栈，左子结点2后入栈。 栈中元素：4 2 输出元素：1 栈顶结点2出栈，输出结点2，同样将结点2的右子结点5先入栈，左子结点3后入栈。 栈中元素：4 5 3 输出元素：1 2 栈顶结点3出栈，输出结点3，因结点3为叶子结点，无入栈。栈顶结点5出栈，输出结点5 栈中元素：4 输出元素：1 2 3 5 栈顶结点4出栈，输出结点4，栈空，遍历结束。 栈中元素： 输出元素：1 2 3 5 4 参考代码/** * 先序2 * @param root 树的根结点 * @return 先序遍历序列数组 */ public static ArrayList&lt;Object&gt; preOrder2(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建先序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p; //将根结点入栈 stack.push(root); //循环至栈空 while(!stack.isEmpty()){ /* * 依据先序遍历的特点：p结点→左子节点→右子结点 */ //p指针指向弹出栈顶的结点 p = stack.pop(); //p结点的数据入组 list.add(p.data); //如果有右结点，入栈 if( p.right != null) stack.push(p.right); //如果有左节点，入栈并p指针指向左子节点 if( p.left != null) { stack.push(p.left); p=p.left; } } //返回先序遍历序列数组 return list; } ` 中序遍历思想与先序的循环控制类似： 1、入栈前，先指向本结点；2、先左子树一次入栈（入栈前先指向该结点），直到没有左子树的结点为止；3、出栈顶元素并输出，若有右子树，找到右子树，继续1、2操作，直到栈为空且结点为空。 举例 指针指向根结点，将左子树结点1、2、3循环依次入栈，直至没有左子树结点，指针为null。 栈中元素：1 2 3 输出元素： 栈顶结点3出栈并输出，无右子结点，之后栈顶结点2出栈并输出，指针指向结点2的右子结点5，继续重复一步骤：将结点5的左子树结点循环入栈，当然此处5为叶子结点，无左子节点。 栈中元素：1 5 输出元素：3 2 结点5出栈并输出，无右子结点，之后栈顶结点1出栈并输出，指针指向结点1的右子结点4，同上。 栈中元素：4 输出元素：3 2 5 1 结点4出栈并输出，无右子结点，此时栈为空，指针指向结点4的左子结点null，遍历结束。 栈中元素： 输出元素：3 2 5 1 4 参考代码/** * 中序 * @param root 树的根结点 * @return 中序遍历序列数组 */ public static ArrayList&lt;Object&gt; inOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建中序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向根结点 Node&lt;Object&gt; p = root; //循环至p指针为null，以及栈为空。 while(p!=null || !stack.isEmpty() ){ //依次将左子树结点入栈，直至为null while(p!=null){ stack.add(p); p = p.left; } /* * 如果指针p和栈均为空，则遍历完成 * 如果栈不为空，弹出的栈顶结点，数据入组，p指针指向该节点右子节点 */ if(!stack.isEmpty()){ p = stack.pop(); list.add(p.data); p = p.right; } } //返回中序遍历序列数组 return list; } ` 后序遍历思想1——双栈实际上我觉得这个方法很神奇。实际上它做的是一个反向的预排序遍历。 由于后序序列的顺序是：左子结点→右子结点→根结点，所以入栈1的顺序是正常顺序，入栈2的顺序是：根结点→右子结点→左子结点，之后再将栈2的结点依次出栈输出。 举例 先将根结点入栈1，在循环中将栈1的栈顶结点1出栈，指针指向结点1，并将其入栈2，将指针所指的结点1的左、右子结点2、4按顺序依次入栈1. 栈1元素：2 4 栈2元素：1 栈1的栈顶结点4出栈，指针指向结点4，并入栈2，由于结点4为叶子结点，跳过。 栈1元素：2 栈2元素：1 4 同循环里的步骤1，栈1的栈顶结点2出栈，指针指向结点2，并入栈2，将指针所指的结点2的左、右子结点3、5依次入栈1。 同步骤2栈1的栈顶结点5出栈入栈2，由于结点5是叶子节点，跳过。结点3同理。 栈1元素：3 5 栈2元素：1 4 2 ↓ 栈1元素： 栈2元素：1 4 2 5 3 ` 栈1空，遍历完毕，将栈2元素依次出栈输出即可。 输出元素：3 5 2 4 1 参考代码/** * 后序 双栈 * @param root 树的根结点 * @return 后序遍历序列数组 */ public static ArrayList&lt;Object&gt; postOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建暂时存储结点的栈1，以及存储结点倒序的栈2 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); Stack&lt;Object&gt; stack2 = new Stack&lt;&gt;(); //创建后序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p; //将根结点入栈1 stack.push(root); //循环至栈1为空，即栈1结点数据均入栈2 while(!stack.isEmpty()){ /* * 始终依据后序遍历的特点：左子节点→右子结点→p结点 * 由于栈是先入后出，入栈顺序，p结点→右子结点→左子节点 */ //弹出栈1顶端结点 p = stack.pop(); //根据是否存在左右子节点，按照p→右→左的顺序入栈2 stack2.push(p.data); if( p.left != null) stack.push(p.left); if( p.right != null) stack.push(p.right); } //将栈2里的元素依次输入至数组 while (!stack2.isEmpty()){ list.add(stack2.pop()); } //返回后序遍历序列数组 return list; } `` 思想2——标记因后序遍历：左子树→后右子树→根结点，则需要判断上次访问的结点是位于左子树，还是右子树。 若是位于左子树，则需跳过根结点，先进入右子树；若是位于右子树，则直接输出根结点。 因此，可通过设置标志位，标明上次访问的结点是位于左子树，还是右子树。 举例 指针指向根结点，将左子树结点1、2、3循环依次入结点栈，标记栈中入“左”的标记，直至没有左子树结点，指针为null。 结点栈元素：1 2 3 标记栈元素：左 左 左 输出元素： 查看结点栈的栈顶结点3，查看栈栈顶标记，标记为“左”，指针指向结点3的右子结点（为null），标记栈入“右”标记。 结点栈元素：1 2 3 标记栈元素：左 左 右 输出元素： 由于指针为null，跳过循环，查看标记栈栈顶标记，标记为“右”，结点栈栈顶结点3出栈并输出，标记栈栈顶标记出栈。 结点栈元素：1 2 标记栈元素：左 左 输出元素：3 查看结点栈的栈顶结点2，查看栈栈顶标记，标记为“左”，指针指向结点2的右子结点5，标记栈入“右”标记。 结点栈元素：1 2 标记栈元素：左 右 输出元素：3 指针不为null，将结点5入结点栈，“左”标记入标记栈。 结点栈元素：1 2 5 标记栈元素：左 右 左 输出元素：3 同理，查看结点栈的栈顶结点5，查看栈栈顶标记，标记为“左”，指针指向结点3的右子结点（为null），标记栈入“右”标记。 结点栈元素：1 2 5 标记栈元素：左 右 右 输出元素：3 同理，由于指针为null，跳过循环，查看标记栈栈顶标记，标记为“右”，结点栈栈顶结点5出栈并输出，标记栈栈顶标记出栈。之后同上 结点栈元素：1 2 标记栈元素：左 右 输出元素：3 5 ↓ 结点栈元素：1 标记栈元素：左 输出元素：3 5 2 ↓ 结点栈元素：1 4 标记栈元素：右 左 输出元素：3 5 2 ↓ 结点栈元素：1 4 标记栈元素：右 右 输出元素：3 5 2 ↓ 结点栈元素：1 标记栈元素：右 输出元素：3 5 2 4 ↓ 结点栈元素： 标记栈元素： 输出元素：3 5 2 4 1 参考代码/** * 后序 标记 * @param root 树的根结点 * @return 后序遍历序列数组 */ public static ArrayList&lt;Object&gt; postOrder2(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建储存结点和左右子树的标记的栈，此处左子树记为-1，右为1. Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); //创建后序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p = root; //循环直至结点栈为空和指针为null while( p != null || !stack.isEmpty()){ //若指针不为null，将结点入栈，并标记为左子树（-1），循环至p指向null while (p!=null){ stack.push(p); stack2.push(-1); p = p.left; } //若p指针为null,栈中为空，则已遍历完成，跳出循环。 if(stack.isEmpty()) break; /* * 指针上一个指向的结点，即结点栈顶端的结点若在右子树， * 则该节点左右结点结点均已遍历（当然也有可能为空），弹出右标记，并将该结点入表 */ if(stack2.peek() == 1){ stack2.pop(); list.add(stack.pop().data); } /* * 指针上一个指向的结点，即结点栈顶端的结点若在左子树， * 则弹出左标记，指针指向该节点的右结点，并标记为右子树（1）。 * * 这里需要注意，指向右结点后有可能该节点存在左子树， * 所以需要再次利用前方添加左节点的循环， * 所以需要在循环最后。 */ else if(stack2.peek() == -1){ stack2.pop(); p = stack.peek().right; stack2.push(1); } } //循环结束，返回后序遍历序列数组 return list; } ` 层次遍历（从上向下）思路层次遍历：从上往下，从左往右。 先将根结点入队，指针指向队首，将根结点的左、右子结点依次入队，如果没有就跳过。之后指针向后移动，队首结点出队输出，再次重复将指针所指结点的左、右子结点依次入队。直至队空。 举例 先将根结点入队，指针指向根结点，之后将指针所指结点1的左、右子结点2、4依次入队。 队列元素：1 2 4 输出元素： 指针向后移动，队首结点出队输出，再将指针所指结点2的左、右子结点3、5依次入队。 队列元素：2 4 3 5 输出元素：1 指针向后移动，队首结点出队输出，指针所指结点4为叶子结点，跳过。 队列元素：4 3 5 输出元素：1 2 之后同理，直至队列元素为空。 队列元素： 输出元素：1 2 4 3 5 ` 参考代码/** * 层次 */ @SuppressWarnings(&quot;unchecked&quot;) public static ArrayList&lt;Object&gt; levelOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建储存结点的队列 QueueArray&lt;Node&lt;Object&gt;&gt; quearr = new QueueArray&lt;&gt;(); //创建后序遍历序列储存的数组 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //将根结点入队 quearr.In(root); //创建当前结点和指针,指针指向队首结点 int flag = 0; Node&lt;Object&gt; p = (Node&lt;Object&gt;) quearr.que_arr[flag]; //循环至队列为空 while (quearr.count != 0){ /* * 指针从队首依次向后移动，依次将该节点的左右子节点入队 * 若指针向后移动，之前的结点出队 */ if(p.left!=null) quearr.In(p.left); if(p.right!=null) quearr.In(p.right); //出队入组 list.add(((Node&lt;Object&gt;)quearr.Out()).data); //flag标号的增加 if (flag+1 &gt;= quearr.size){ flag = 0; }else{ ++flag; } //指针向后移动 p = (Node&lt;Object&gt;) quearr.que_arr[flag]; } //返回层次遍历序列数组 return list; } ` 所有方法的主函数测试 public static void main(String[] args){ LinkedTree&lt;Object&gt; tree = new LinkedTree&lt;&gt;(&quot;A&quot;); Node&lt;Object&gt; A = tree.root; Node&lt;Object&gt; B = tree.add(&#39;B&#39;, A, true); Node&lt;Object&gt; C = tree.add(&#39;C&#39;, A, false); Node&lt;Object&gt; D = tree.add(&#39;D&#39;, B, true); Node&lt;Object&gt; E = tree.add(&#39;E&#39;, B, false); Node&lt;Object&gt; F = tree.add(&#39;F&#39;, C, false); Node&lt;Object&gt; G = tree.add(&#39;G&#39;, D, true); Node&lt;Object&gt; H = tree.add(&#39;H&#39;, E, true); Node&lt;Object&gt; I = tree.add(&#39;I&#39;, E, false); Node&lt;Object&gt; J = tree.add(&#39;J&#39;, I, false); System.out.print(&quot;先序遍历序列，法一：&quot;); print(preOrder(A)); System.out.print(&quot;先序遍历序列，法二：&quot;); print(preOrder2(A)); System.out.print(&quot;中序遍历序列：&quot;); print(inOrder(A)); System.out.print(&quot;后序遍历序列，双栈：&quot;); print(postOrder(A)); System.out.print(&quot;后序遍历序列，标记：&quot;); print(postOrder2(A)); System.out.print(&quot;层次遍历序列：&quot;); print(levelOrder(A)); } 结果先序遍历序列，法一：A B D G E H I J C F 先序遍历序列，法二：A B D G E H I J C F 中序遍历序列 ：G D B H E I J A C F 后序遍历序列，双栈：G D H J I E B F C A 后序遍历序列，标记：G D H J I E B F C A 层次遍历序列：A B C D E F G H I J `","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.2）——二叉树的遍历","slug":"数据结构笔记8.2","date":"2020-04-14T01:45:00.000Z","updated":"2021-08-18T07:21:38.057Z","comments":true,"path":"2020/04/14/数据结构笔记8.2/","link":"","permalink":"/2020/04/14/数据结构笔记8.2/","excerpt":"","text":"二叉树的遍历遍历（Traversing）是树形结构的一种重要运算，即按一定的次序系统地访问结构中的所有结点，使每个结点只被访问一次。 常用方法：先序法；中序法；后序法；层次法。 先序法（PreOrder）从根结点a开始访问，接着访问左子结点b，最后访问右子结点c。即：根结点 → 左子树 → 右子树 中序法（InOrder）从左子结点b开始访问，接着访问根结点a，最后访问右子结点c。即：左子树 → 根结点 → 右子树 偷懒的简单转换方法： 后序法（PostOrder）从左子结点b开始访问，接着访问右子结点c，最后访问根结点a。即：左子树 → 右子树 → 根结点 层次法从上往下，从左往右依次读出结点。 依据序列构建二叉树若仅已知先序序列、中序序列、后序序列其中任意一个，无法唯一确定二叉树。 若知先序和后序序列，同样无法唯一确定二叉树。 特殊情况 前序遍历与中序遍历相同的二叉树。 空二叉树、只有根结点的二叉树、只有左子树的二叉树 中序遍历与后序遍历相同的二叉树。 空二叉树、只有根结点的二叉树、只有右子树的二叉树 前序遍历与后序遍历相同的二叉树。 空二叉树、只有根结点的二叉树 先序、中序序列例：若已知某二叉树的先序序列 [ ABHFDECKG ] 和中序序列 [ HBDFAEKCG ] ，构建该二叉树。 对于先序序列，根结点在第一个位置。对于中序序列，根结点大多数情况在中序序列的中间某一位置（也可能存在位于首尾的情况），左边部分是根结点的左子树的中序遍历序列，右边部分是根结点的右子树的中序遍历序列。 先序：A BHFD ECKG 中序：HBDF A EKCG 结论：A是根结点，HBDF结点在左侧，ECKG结点在右侧。 先序：B H FD 中序：H B DF 结论：B是左子树根结点，H结点在左侧，FD结点在右侧。 根据先序和中序的特点，F位于D的上一层，且D在以F为根结点的子树的左子树中，F无右子树。 先序：E CKG 中序：E KCG 结论：E是右子树根结点，左侧无结点，CKG结点在右侧。 先序：C KG 中序：K C G 同样的，根据先序和中序的特点，C位于KG的上一层，且K在以C为根结点的子树的左子树中，G在右子树中。 中序、后序序列实际上，已知中序、后序序列来构建二叉树与已知先序、中序来构建方法类似，均是利用遍历序列特性。 例：若已知某二叉树的后序序列 [ DGEBFCA ] 和中序序列 [ DBGEACF ] ，构建该二叉树。 对于后序序列，根结点在最后一个位置。中序序列同上 后序：DGEB FC A 中序：DBGE A CF 结论：A是根结点，DBGE结点在左侧，CF结点在右侧。 后序：D GE B 中序：D B GE 结论：B是左子树根结点，D结点在左侧，GE结点在右侧。 根据后序和中序的特点，E位于G的上一层，且G在以E为根结点的子树的左子树中，E无右子树。 同理，右子树中，C位于F的上一层，且F在以C为根结点的子树的右子树中，C无左子树。 二叉树递归遍历算法二叉树以用链表构建的为例，每个结点中包含：该节点的数据，左、右子结点的地址。 实际上个人觉得二叉树遍历的递归算法虽容易理解，但写出来对于我来说可能会有点困难，因为找到进入和跳出的点可能对于我来说有些困难，所以个人的倾向还是使用非递归的算法。 结点和树的创建及递归遍历/** * 创建结点，包含数据，左右子结点地址 */ static class Node&lt;E&gt;{ E data; Node&lt;E&gt; right; Node&lt;E&gt; left; //相关数据的添加 public Node(E data , Node&lt;E&gt; right , Node&lt;E&gt; left){ this.left = left; this.right = right; this.data = data; } //初始化 public Node(E data){ this(data,null,null); } } /** * 创建树 */ static class LinkedTree&lt;E&gt;{ //根结点 Node&lt;E&gt; root; //初始化树 public LinkedTree(E data){ root = new Node&lt;&gt;(data); } /** * 添加结点 * @param data 添加的数据 * @param father 父级结点地址 * @param isLeft 是否为父级结点的左子结点 * @return 添加的结点 */ public Node&lt;E&gt; add(E data , Node&lt;E&gt; father , boolean isLeft){ if(father == null) throw new RuntimeException(&quot;无父级，拒绝添加&quot;); Node&lt;E&gt; theNode = new Node&lt;&gt;(data); if(isLeft){ father.left = theNode; }else{ father.right = theNode; } return theNode; } //先序 private void preOrder(Node&lt;E&gt; root){ if(root == null) return; System.out.print(root.data + &quot; &quot;); preOrder(root.left); preOrder(root.right); } //中序 private void inOrder(Node&lt;E&gt; root){ if (root == null) return; inOrder(root.left); System.out.print(root.data + &quot; &quot;); inOrder(root.right); } //后序 private void postOrder(Node&lt;E&gt; root){ if (root == null) return; postOrder(root.left); postOrder(root.right); System.out.print(root.data + &quot; &quot;); } int lives_count = 0; int count=0; //计算叶子结点和总结点，递归 private void count(Node&lt;E&gt; root){ if (root == null) return; if (root.right == null &amp;&amp; root.left == null) lives_count +=1 ; count(root.left); count(root.right); count+=1; } } ` 主函数测试@SuppressWarnings(&quot;unused&quot;) public static void main(String[] args){ LinkedTree&lt;Object&gt; tree = new LinkedTree&lt;&gt;(&quot;A&quot;); Node&lt;Object&gt; A = tree.root; Node&lt;Object&gt; B = tree.add(&#39;B&#39;, A, true); Node&lt;Object&gt; C = tree.add(&#39;C&#39;, A, false); Node&lt;Object&gt; D = tree.add(&#39;D&#39;, B, true); Node&lt;Object&gt; F = tree.add(&#39;F&#39;, C, true); Node&lt;Object&gt; G = tree.add(&#39;G&#39;, C, false); System.out.print(&quot;先序遍历序列：&quot;); tree.preOrder(A); System.out.println(); System.out.print(&quot;中序遍历序列：&quot;); tree.inOrder(A); System.out.println(); System.out.print(&quot;后序遍历序列：&quot;); tree.postOrder(A); System.out.println(); tree.count(A); System.out.print(&quot;总结点数：&quot;); System.out.println(tree.count); System.out.print(&quot;叶子结点数：&quot;); System.out.println(tree.lives_count); } 结果先序遍历序列：A B D C F G 中序遍历序列：D B A F C G 后序遍历序列：D B F G C A 总结点数：6 叶子结点数：3 `","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.1）——树的定义和存储结构","slug":"数据结构笔记8.1","date":"2020-04-10T01:45:00.000Z","updated":"2021-08-18T07:30:37.053Z","comments":true,"path":"2020/04/10/数据结构笔记8.1/","link":"","permalink":"/2020/04/10/数据结构笔记8.1/","excerpt":"","text":"定义由零个、一个或多个结点组成的有限集合。仅有一个根结点，结点间有明显的层次结构关系。 从逻辑结构看：1）树中只有根结点没有前趋；2）除根外，其余结点都有且仅一个前趋；3）树的结点，可以有零个或多个后继；4）除根外的其他结点，都存在唯一条从根到该结点的路径；树是一种分枝结构（除了一个称为根的结点外）每个元素都有且仅有一个直接前趋，有且仅有零个或多个直接后继。 表示方法树形表示、图形表示、凹入表表示、嵌套集合表示 二叉树定义：二叉树是n(n≥0)个结点的有限集。它或为空树(n=0)，或由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树构成。 特点：1、每个结点至多有二棵子树(即不存在度大于2的结点)。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、二叉树的子树有左、右之分，且其次序不能任意颠倒。 基本形态：空二叉树，只有根结点，右子树为空，左子树为空，左、右子树均非空。 性质： 在二叉树的第 i 层上至多有 2^(i-1) 个结点 ( i ≥ 1 ) 。 高度为 k 的二叉树至多有 2^k -1 个结点 (k ≥ 1) 。 对任何一棵二叉树T，如果其叶结点数为n0 ，度为2的结点数为n2 ，则n0 = n2 + 1 。 具有 n 个结点的完全二叉树的高度为 (log2 n) + 1 。 如果对一棵有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i(1≤i≤n)，有： 如果 i=1 ，则结点 i 是二叉树的根，无双亲。 如果 i&gt;1 ，则其双亲是 i/2 。 如果 2i&gt;n ，则结点 i 无左孩子；如果 2i≤n ，则其左孩子是 2i 。 如果 2i+1&gt;n ，则结点 i 无右孩子；如果 2i+1≤n ，则其右孩子是 2i+1 。 特殊形式的二叉树满二叉树定义：一棵高度为 k 且有 2^k - 1 个结点的二叉树称为满二叉树。 特点，每一层上的结点数都是最大结点数。 完全二叉树定义：高度为 k ，有 n 个结点的二叉树，当且仅当其每一个结点都与高度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时，称为完全二叉树。 特点：1、叶子结点只可能在层次最大的两层上出现。2、对任一结点，若其右分支下子孙的最大层次为 L，则其左分支下子孙的最大层次必为 L 或 L+1 。 判断方法：1、根据特点2，若存在一个 k 层的完全二叉树，那么从 1 到 k-1 层必为满二叉树。2、根据定义，在完全二叉树第 k 层，从左往右必定依次与满二叉树的第 k 层一一对应，允许 k 层右端连续空缺，但不允许左端中途空缺。 二叉树的储存方法顺序存储思路：若存在两个数据，分别为树的父级和子级，位置为 i 和 j ，若子级位于左侧，其位置关系为：j = i × 2 ；若位于右侧，为： j = i × 2 + 1 方法参考代码public static class ArrayTree&lt;E&gt;{ //初始化数组 private final int totall = 3 * 3 - 1 ; //(height^2-1) private Object[] arraytree ; public ArrayTree(){ this.arraytree = new Object[totall]; } /** * 向树里添加第一个数据 * @param data 添加的数据 */ public void add(E data){ arraytree[1] = data ; } /** * 向树里添加数据 * @param data 添加的数据 * @param index 添加数据的父级的位置 * @param isLeft 是否在左侧 */ public void add(E data , int index , boolean isLeft){ //判断插入位置是否合法 if ( arraytree[index] == null ){ throw new RuntimeException(&quot;插入位置没有父级，不合法。&quot;); } //根据isLeft值赋予x值 int x ; if ( isLeft ){ x = 0; } else { x = 1 ; } //判断是否超出数组范围 if(2 * index + x &gt;= totall){ throw new RuntimeException(&quot;插入位置超出数组范围&quot;); } //在相应位置添加数据 arraytree[ 2 * index + x ] = data ; } /** * 输出 */ public void print(){ System.out.print(&quot;[&quot;); for ( int i = 0 ; i &lt; totall ; i++ ){ if ( i == totall - 1){ System.out.print(arraytree[i]+&quot;]&quot;); }else{ System.out.print(arraytree[i]+&quot;,&quot;); } } System.out.println(); } } ` 主函数测试public static void main(String[] args){ ArrayTree&lt;Integer&gt; arrtr = new ArrayTree&lt;&gt;(); arrtr.add(1); //arrtr.add(4, 2, true); arrtr.add(2, 1, true); arrtr.add(3, 1, false); arrtr.print(); arrtr.add(4, 2, true); arrtr.add(5, 2, false); arrtr.add(6, 3, true); arrtr.add(7, 3, false); arrtr.print(); //arrtr.add(8, 4, true); } 结果[null,1,2,3,null,null,null,null] [null,1,2,3,4,5,6,7] ` 优缺点优点:1、找双亲结点、子结点和兄弟结点容易。2、每个结点的存储空间不大。 缺点：当二叉树的高度和结点比例偏高时，内存利用率偏低，即可能存在大量空内存。 适用于静态数组，并且结点个数已知的完全二叉树或接近完全二叉树的二叉树。 链式存储个人最初的想法结点拥有三个部分：数据域，三个指向父级和左右子级的地址域。 参考方法代码//定义结点 public static class Node&lt;E&gt;{ private E data; private Node&lt;E&gt; fath; private Node&lt;E&gt; sonLeft ; private Node&lt;E&gt; sonRight ; //创建结点 public Node(E data , Node&lt;E&gt; fath , Node&lt;E&gt; sonLeft , Node&lt;E&gt; sonRight){ this.data = data ; this.fath = fath ; this.sonLeft = sonLeft ; this.sonRight = sonRight ; } //初始化结点 public Node(E data){ this(data,null,null,null); } } //用链表创建二叉树 public static class LinkedTree2&lt;E&gt;{ //创建并初始化头结点 private class Header{ private Node&lt;E&gt; next; public Header(Node&lt;E&gt; next){ this.next = next ; } } //创建二叉树 private Header header ; public LinkedTree2(){ header = new Header(null); } /** * 新增或更改第一个结点 * @param firNode 结点 */ public void addfir(Node&lt;E&gt; firNode){ //新增第一个结点 if(header.next == null){ header.next = firNode; //更改第一个结点 }else{ header.next.data = firNode.data ; } } /** * 添加结点 * @param node 添加的结点 * @param fath 父级结点 * @param isLeft 是否在左侧 */ public void add(Node&lt;E&gt; node , Node&lt;E&gt; fath , boolean isLeft){ node.fath = fath ; if(isLeft){ fath.sonLeft = node ; }else{ fath.sonRight = node ; } } } /** * 输出结点 * @param Node 需输出的结点 */ public static void printNode(Node&lt;Integer&gt; Node){ System.out.print(&quot;结点数据&quot;+Node.data); if (Node.fath != null) System.out.print(&quot;,父级为&quot;+Node.fath.data); if (Node.sonLeft != null) System.out.print(&quot;,左子级为&quot;+Node.sonLeft.data); if (Node.sonRight != null) System.out.print(&quot;,右子级为&quot;+Node.sonRight.data); System.out.println(); } ` 主函数测试public static void main(String[] args){ LinkedTree2&lt;Integer&gt; litree = new LinkedTree2&lt;&gt;(); Node&lt;Integer&gt; A = new Node&lt;&gt;(1); litree.addfir(A); printNode(A); Node&lt;Integer&gt; A1 = new Node&lt;&gt;(10); litree.addfir(A1); printNode(A1); Node&lt;Integer&gt; B = new Node&lt;&gt;(2); litree.add(B, A, true); Node&lt;Integer&gt; C = new Node&lt;&gt;(3); litree.add(C, A, false); printNode(A); printNode(B); printNode(C); Node&lt;Integer&gt; D = new Node&lt;&gt;(4); litree.add(D, B, true); Node&lt;Integer&gt; E = new Node&lt;&gt;(5); litree.add(E, B, false); printNode(D); Node&lt;Integer&gt; G = new Node&lt;&gt;(7); litree.add(G, C, false); printNode(C); } 结果结点数据1 结点数据10 结点数据10,左子级为2,右子级为3 结点数据2,父级为10 结点数据3,父级为10 结点数据4,父级为2 结点数据3,父级为10,右子级为7 参考方法代码//定义结点 public static class BTNode&lt;E&gt;{ private E data; private BTNode&lt;E&gt; sonLeft ; private BTNode&lt;E&gt; sonRight ; //创建结点 public BTNode(E data , BTNode&lt;E&gt; sonLeft , BTNode&lt;E&gt; sonRight){ this.data = data ; this.sonLeft = sonLeft ; this.sonRight = sonRight ; } //初始化结点 public BTNode(E data){ this(data,null,null); } } //二叉树的链表实现 public static class LinkedBTree&lt;E&gt; { //根结点 BTNode&lt;E&gt; root; public LinkedBTree(E data) { root = new BTNode&lt;E&gt;(data); } /** * 为指定结点添加子结点 * @param parent 需要添加节点的双亲结点的索引值 * @param data 新结点数据 * @param isLeft 是否添加左孩子 * @return 新增结点 */ public BTNode&lt;E&gt; add(BTNode&lt;E&gt; parent, E data, boolean isLeft) { if(parent == null) throw new RuntimeException(parent+&quot;结点为空，不能添加子结点!&quot;); BTNode&lt;E&gt; newNode = new BTNode&lt;&gt;(data); if (isLeft) { parent.sonLeft = newNode; } else { parent.sonRight = newNode; } return newNode; } public void printChild(BTNode&lt;E&gt; parent) { System.out.println(&quot;结点&quot; + getString(parent) + &quot;的孩子结点为：&quot; + getString(parent.sonLeft) + &quot;和&quot; + getString(parent.sonRight)); } private Object getString(BTNode&lt;E&gt; node) { if (node == null) { return &quot;空&quot;; } else { return node.data; } } } ` 主函数测试public static void main(String[] args){ LinkedBTree&lt;Character&gt; linkedBTree = new LinkedBTree&lt;&gt;(&#39;A&#39;); BTNode&lt;Character&gt; nodeB = linkedBTree.add(linkedBTree.root, &#39;B&#39;,true); BTNode&lt;Character&gt; nodeC = linkedBTree.add(linkedBTree.root, &#39;C&#39;,false); BTNode&lt;Character&gt; nodeD = linkedBTree.add(nodeB, &#39;D&#39;, true); BTNode&lt;Character&gt; nodeE = linkedBTree.add(nodeB, &#39;E&#39;, false); BTNode&lt;Character&gt; nodeF = linkedBTree.add(nodeC, &#39;F&#39;, false); BTNode&lt;Character&gt; nodeG = linkedBTree.add(nodeE, &#39;G&#39;, true); // 测试，输出某个结点的孩子结点 linkedBTree.printChild(nodeF); } ` 结果结点F的孩子结点为：空和空 特点找儿子容易,找双亲结点难。（可用三叉列表） 一般来说，适用于任何的二叉树。 5.12日补充。 树、森林与二叉树的关系树、森林与二叉树的转换由于二叉树简单，并且其构造等方法成熟，所以在非二叉树和森林中，往往会先将其转化为二叉树。 树转换成二叉树以该树为例。 步骤1：加线——在兄弟结点之间加一连线。 步骤2：抹线——对每个结点，除了保留其第一个孩子的连线外，去除其与其余孩子之间的连线。 步骤3：旋转——以树的根结点为轴心，将整树顺时针转45°。 特点：用该方法将树转换成的二叉树其右子树一定为空。 森林转换成二叉树 将各棵树分别转换成二叉树。 将每棵树的根结点用线相连。 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构。 以图示例。 二叉树转换成树 1、加线。 若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，……沿分支找到的所有右孩子，都与p的双亲用线连起来。 2、抹线。 抹掉原二叉树中双亲与右孩子之间的连线。 3、调整。 将结点按层次排列，形成树结构。 以图示例。 树的遍历 遍历 按一定规律走遍树的各个顶点，且使每一顶点仅被访问一次，即找一个完整而有规律的走法，以得到树中所有结点的一个线性排列。 常用方法 ⚪先根遍历 先访问树的根结点，然后依次先根遍历根的每棵子树。 ⚪后根遍历 先依次后根遍历每棵子树，然后访问根结点。 ⚪层次遍历 先访问第一层上的结点，然后依次遍历第二层，……第n层的结点。 以图中的树为例： 先根遍历: A B E F I G C D H J K L N O M 后根遍历: E I F G B C J K N O L M H D A 层次遍历: A B C D E F G H I J K L M N O","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（7）——数组","slug":"数据结构笔记7","date":"2020-04-03T01:45:00.000Z","updated":"2021-08-18T07:34:42.623Z","comments":true,"path":"2020/04/03/数据结构笔记7/","link":"","permalink":"/2020/04/03/数据结构笔记7/","excerpt":"","text":"定义数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 特点数组是相同类型数据元素的有限集合。数组中的各个分量称为数组元素。每个数组元素值可以用数组名和一个下标值唯一的确定。 由于数组中各元素具有统一的类型，并且数组元素的下标一般具有固定的上界和下界，因此，数组的处理比其它复杂的结构更为简单。多维数组是向量的推广。 数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。 数组的顺序存储结构数组元素是连续存放的，因此采用顺序存储结构。无论几维数组,在计算机中都是按一维数组来存放。 假定存在一个二维数组A m×n （m行n列） ，L是每个元素所占的存储单元。按行优先顺序存储结构：LOC(a ij)=LOC(a 00)+(i×n+j)×L按列优先顺序存储结构：LOC(a ij)=LOC(a 00)+(j×m+i)×L 假定存在一个三维数组A m×n×p （m页n行p列），L是每个元素所占的存储单元。 数组的压缩存储相同值的多个元素占用一个存储单元，零元素不分配存储单元。以下例子的每个元素存储大小为1。 对称矩阵按行优先顺序存放对称矩阵的存储 示例矩阵 在计算机中存储形式 每个元素存储位置 三角矩阵以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵的下三角(不包括主对角线)中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。大多数情况下，常数为0。 下三角矩阵按行优先顺序存放下三角矩阵的存储。 示例矩阵 在计算机中存储形式 每个元素存储位置 上三角矩阵按行优先顺序存放上三角矩阵的存储 示例矩阵 在计算机中存储形式 每个元素存储位置 带状矩阵对角矩阵中，所有的非零元素集中在以主对角线为中心的带状区域中，即除了主对角线和主对角线相邻两侧的若干条对角线上的元素之外，其余元素皆为零。 按行优先顺序存放带状矩阵的存储。 示例矩阵 在 a ij 之前有 i 行，共有 （3×i-1）个非零元素，在第 i 行，有（j-i+1）个非零元素。这样，非零元素 a ij 的地址为： k=3×i-1+(j-i+1)=2i+j 稀疏矩阵稀疏矩阵中有s个非零元素，且s远远小于矩阵元素的总数（即s≦m×n）。 示例矩阵 在计算机中存储形式","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（6）——队列","slug":"数据结构笔记6","date":"2020-03-31T01:45:00.000Z","updated":"2021-08-18T07:35:43.613Z","comments":true,"path":"2020/03/31/数据结构笔记6/","link":"","permalink":"/2020/03/31/数据结构笔记6/","excerpt":"","text":"概念、特性队列是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。 允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。 特性：先进先出。 关于队列满、空的三种判断方法由于用数组创建的非循环队列会出现“假溢出”的问题——即一方面队列为空，另一方面出现溢出，所以之后以循环队列为例。 判断空和满的举例仅作参考。毕竟参考代码用的是最简单的计数。 使用计数器记录队列中的元素个数。 判断满：count&gt;0 &amp;&amp; rear==front 判断空：count==0 假设标志，出队时置为0，入队时置为1，则可识别当前front=rear属于何种情况 判断满：tag==1 &amp;&amp; rear==front 判断空：tag==0 &amp;&amp; rear==front 少用一个存储单元 判断满：front==(rear+1)%size 判断空：rear==front 用数组创建队列参考代码以循环队列为例。 方法参考代码//用数组创建队列 public static class QueueArray&lt;E&gt;{ //设定队列，队的容量，前端和后端，元素数量。 //前端为队头元素位置，后端下标为队尾元素后一个位置。 private int size = 5 ; private Object[] que_arr ; private int front ; private int rear ; private int count ; //初始化队列 public QueueArray(){ que_arr =new Object [size] ; this.front = 0 ; this.rear = 0 ; this.count = 0; } /** * 入队 * @param data */ public void In(E data){ //判断是否队满 if (count == size){ throw new RuntimeException(&quot;队满&quot;); } //添加数据，元素总数+1 que_arr[rear] = data ; ++count; //队尾标号的后移 if (rear+1 &gt;= size){ rear = 0; }else{ ++rear; } } /** * 出队 * @return 队头的元素 */ public Object Out(){ //判断是否队空 if (count == 0){ throw new RuntimeException(&quot;队空&quot;); } //数据的输出和清空 Object data = que_arr[front]; que_arr[front] = null ; //元素总数-1 --count; //队首标号的后移 if (front+1 &gt;= size){ front = 0; }else{ ++front; } return data; } /** * 打印 */ public void print(){ System.out.print(&quot;[&quot;); for (int i = 0 ; i&lt;size ; i++){ if (i == size-1){ System.out.print(que_arr[size-1]+&quot;]&quot;); }else{ System.out.print(que_arr[i]+&quot;,&quot;); } } System.out.println(&quot;count:&quot;+count+&quot; front:&quot;+front+&quot; rear:&quot;+rear); } } 主函数测试 //主函数测试 public static void main(String[] args){ QueueArray&lt;Object&gt; queue = new QueueArray&lt;&gt;(); //queue.Out(); queue.In(1); queue.In(2); queue.In(3); queue.print(); queue.Out(); queue.print(); queue.In(4); queue.In(5); queue.In(6); //queue.In(7); queue.print(); queue.Out(); queue.Out(); queue.Out(); queue.print(); queue.In(7); queue.Out(); queue.Out(); queue.print(); } ` 输出结果 用链表创建队列参考代码以循环队列为例。 但目前还没有感觉到循环和不循环各有什么优势。 方法参考代码//用链表创建队列 public static class QueueLinked&lt;E&gt;{ private int size; private Node header; //创建指向链表末端结点的指针 Node p; //初始化链表 public QueueLinked(){ header = new Node(); size = 0 ; p = header; } //创建结点 public class Node{ //创建数据域和地址域 private E data; private Node next; //构建方法使结点元素的改变 public Node(E data,Node next){ this.data = data; this.next = next; } //初始化结点 public Node(){ this(null,null); } } /** * 入队 * @param data 需要入队的数据 */ public void In(E data){ //创建结点 Node newnode = new Node(); //赋予数据 newnode.data = data; //将结点添加到当前链表末端之后 p.next = newnode; //p指向新结点，其地址域指向队首 p = newnode; newnode.next = header.next; //结点数+1 ++size; } public E Out(){ //判断队列是否为空 if (size == 0){ throw new RuntimeException(&quot;队空&quot;); } //创建指针指向删除的结点 Node del = header.next; //队首数据输出 E data = del.data; //删除队首结点 //如果队列中只有一个结点，头结点地址域null if (size == 1){ header.next = null ; //否则头结点地址域指向第二个结点 }else{ header.next = del.next; } //队尾地址域指向新队首 p.next = header.next; //将删除的结点清空 del.data = null ; del.next = null ; //总数-1 --size; //返回队首数据 return data; } /** * 打印 */ public void print(){ Node q = header.next; for (int i = 0 ; i&lt;size ; i++){ if (i == size-1){ System.out.print(q.data); }else{ System.out.print(q.data+&quot;,&quot;); q = q.next; } } System.out.println(&quot;——size:&quot;+size+&quot; ; p.next:&quot;+p.next.data); } } 主函数测试//主函数测试 public static void main(String[] args){ QueueLinked&lt;Object&gt; queue2 = new QueueLinked&lt;&gt;(); //queue2.Out(); queue2.In(1); queue2.In(2); queue2.In(3); queue2.print(); queue2.Out(); queue2.Out(); queue2.print(); } ` 输出结果","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（5）——栈应用","slug":"数据结构笔记5","date":"2020-03-24T01:45:00.000Z","updated":"2021-08-18T07:37:20.874Z","comments":true,"path":"2020/03/24/数据结构笔记5/","link":"","permalink":"/2020/03/24/数据结构笔记5/","excerpt":"","text":"表达式括号匹配利用栈判断表达式中括号是否匹配，但这只能判断括号的数目正确，像是“1+(2+3(4/)5)”这类就无法判断。 其实这类问题可以不用栈，直接通过数左括号和右括号的数目来判断。 表达式求值这里有三种表达式：前缀表达式（波兰表达式）、中缀表达式、后缀表达式（逆波兰表达式）。 中缀表达式就是生活中常见的表达式，如：1+2*3 由于中缀表达式对于人能较好理解，但对于计算机来讲难以处理，而后缀表达式则容易处理。后缀表达式如：123*+ 前缀表达式相较于后缀来说，用得就少了些，如：+1*23 部分参考思路关于中缀转后缀表达式，以及后缀表达式的计算，这位大神的文章已经讲得很详细了。 链接在此 中缀转后缀表达式这里就只列出中缀转后缀的代码的参考，首先是因为似乎用的比较多，其次其他的转换可以根据此推出，毕竟转换的思路前辈们都已帮我们确定了下来。 关于java.util.Stack之前找到java有关于栈的类，所以参考代码就直接引用。 实际上这个类存在许多问题，毕竟这是Vector动态数组的子类，但用在这里是没什么大问题。 Stack类是Vector的一个子类，它实现了一个标准的后进先出的栈。 以下为参考函数中使用的类中带有的方法。 boolean empty()检测堆栈是否为空。 Object peek()查看堆栈顶部的对象，但不从堆栈中移除它。 Object pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 Object push(Object element)把项压入堆栈顶部。 参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 导入的类 import java.util.Stack; import java.util.ArrayList; //输入 import java.util.Arrays; import java.util.Scanner; ` 中缀转后缀表达式代码 /** * 中缀表达式转化为后缀表达式 * @param infix 中缀表达式列表 * @return 后缀表达式列表 */ public static ArrayList&lt;String&gt; InfixToSuffix(ArrayList&lt;String&gt; infix){ //创建后缀表达式表 ArrayList&lt;String&gt; suffix = new ArrayList&lt;String&gt;(); //创建符号栈 Stack&lt;String&gt; operator = new Stack&lt;&gt;(); //对原中缀表达式进行循环 for (int i = 0 ; i &lt; infix.size() ; i++){ String item = infix.get(i); //如果是数字，直接入表 if (isNum(item)){ suffix.add(item); //如果是括号 }else if (&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item)){ //如果为（，直接入栈 if (&quot;(&quot;.equals(item)){ operator.push(item); //如果是），从栈顶依次向下出栈入表，直到遇到（ }else{ while (true){ //遇到（，只出栈，并跳出循环 if(&quot;(&quot;.equals(operator.peek())){ operator.pop(); break; //遇到其他符号，出栈入表 }else{ suffix.add(operator.pop()); } } } //如果遇到操作符 }else{ //如果栈为空栈，或当前符号权重大于前一个，入栈 if(operator.isEmpty() || heavy(item) &gt; heavy(operator.peek())){ operator.push(item); //若当前符号权重小于前一个，循环元素出栈入表，直至空栈，或遇到权重更小的操作符或（ }else{ while (!operator.isEmpty() &amp;&amp; !&quot;(&quot;.equals(operator.peek())){ if(heavy(item) &lt;= heavy(operator.peek())){ suffix.add(operator.pop()); } } //当前操作符压栈 operator.push(item); } } } //如果最后一个是括号，会导致输出结果多出空的字符串 for (int i = 0 ; i&lt;suffix.size() ; i++){ if (&quot;&quot;.equals(suffix.get(i))){ suffix.remove(i); } } //循环完毕，若栈不为空，依次出栈入表。 while (!operator.isEmpty()){ suffix.add(operator.pop()); } return suffix; } /** * 符号权重 * @param item 符号 * @return 权重int */ private static int heavy(String item) { int heavy; if (&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item) ){ heavy = 0 ; }else if(&quot;+&quot;.equals(item) || &quot;-&quot;.equals(item)){ heavy = 1 ; }else if(&quot;*&quot;.equals(item) || &quot;/&quot;.equals(item)){ heavy = 2; }else{ throw new IndexOutOfBoundsException (&quot;存在没有设置权重的字符&quot;); } return heavy; } /** * 判断字符串是否为数字 * @param str 需判断的字符串 * @return true/false */ public static boolean isNum(String str){ for (int i = 0 ; i&lt;str.length() ; i++){ if (!Character.isDigit(str.charAt(0))){ return false; } } return true; } /** * 字符串转化为ArrayList * @param str 需转换的字符串 * @return ArrayList */ public static ArrayList&lt;String&gt; StringToList(String str){ //创建列表 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); String digit = &quot;&quot;; //对字符串进行循环 for (int i = 0 ; i &lt; str.length() ; i++){ //储存当前循环的字符 String item = String.valueOf(str.charAt(i)); //如果是数字或小数点，储存到digit中 if (isNum(item) || &quot;.&quot;.equals(item)){ digit+=String.valueOf(item); //如果是符号 }else if(&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item) || &quot;+&quot;.equals(item) || &quot;-&quot;.equals(item) || &quot;*&quot;.equals(item) || &quot;/&quot;.equals(item)) { //如果是第一个，即（，直接入表 if (i==0){ list.add(String.valueOf(item)); //否则将前一个数字入表，随后符号入表 }else{ if (!&quot;&quot;.equals(digit)){ list.add(digit); digit = &quot;&quot;; } list.add(String.valueOf(item)); } }else{ throw new IndexOutOfBoundsException (&quot;非法字符&quot;); } } //循环完毕，若还有储存的数字，入表。 list.add(String.valueOf(digit)); return list; } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); ArrayList&lt;String&gt; suffix = InfixToSuffix(infix); System.out.print(&quot;中缀转化后缀为：&quot;); for (int i = 0 ; i &lt; suffix.size() ; i++){ if (i == suffix.size()-1){ System.out.print(suffix.get(i)); continue; } System.out.print(suffix.get(i)+&quot;,&quot;); } System.out.println(); } 后缀表达式计算参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 /** * 根据后缀表达式suffix计算结果 * @param suffix 后缀表达式列表 * @return 结果 */ private static Double calculate(ArrayList&lt;String&gt; suffix) { //创建数字栈 Stack&lt;String&gt; number = new Stack&lt;&gt;(); //对列表中元素进行循环 for(int i=0; i&lt;suffix.size(); i++){ String item = suffix.get(i); //如果是数字，入栈 if(isNum(item)){ number.push(item); //如果是符号，取栈顶两个元素，运算后入栈 }else { //String → double double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); double result = 0; if(item.equals(&quot;+&quot;)){ result = num1 + num2; }else if(item.equals(&quot;-&quot;)){ result = num1 - num2; }else if(item.equals(&quot;*&quot;)){ result = num1 * num2; }else if(item.equals(&quot;/&quot;)){ result = num1 / num2; }else { throw new RuntimeException(&quot;非法符号&quot;); } //double → String number.push(String.valueOf(result)); } } //返回计算结果 return Double.parseDouble(number.pop()); } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); ArrayList&lt;String&gt; suffix = InfixToSuffix(infix); System.out.print(&quot;最终结果：&quot;+orgexp+&quot;=&quot;+calculate(suffix)); } 中缀表达式计算参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 /** * 两个数字之间的运算 * @param x1 数字1 * @param x2 数字2 * @param item 运算符号 * @return 结果 */ private static double calculate(double x1,double x2,String item){ //定义结果 double result ; //根据运算符对两个数字进行运算 if (item.equals(&quot;+&quot;)){ result = x1+x2; }else if (item.equals(&quot;-&quot;)){ result = x1-x2; }else if (item.equals(&quot;*&quot;)){ result = x1*x2; }else if (item.equals(&quot;/&quot;)){ result = x1/x2; }else{ throw new IndexOutOfBoundsException (&quot;表达式非法&quot;); } //返回 return result; } /** * 中缀表达式的运算 * @param infix 中缀表达式的列表 * @return 结果 */ public static double InFixOperation(ArrayList&lt;String&gt; infix){ //定义数字和操作符的栈 Stack&lt;String&gt; number = new Stack&lt;&gt;(); Stack&lt;String&gt; operator = new Stack&lt;&gt;(); //对中缀表达式进行循环 for (int i = 0 ; i&lt;infix.size() ; i++){ //当前循环的符号 String item = infix.get(i); //如果是数字，直接入数字栈 if (isNum(item)){ number.push(item); //否则就是操作符 }else{ //如果是），将前面的数字和符号依次从后往前运算，直至（，并将结果入数字栈 if (&quot;)&quot;.equals(item)){ while (!operator.peek().equals(&quot;(&quot;)){ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); } operator.pop(); //如果是（，或操作栈为空，或当前运算符权重大于前者，直接入操作符栈 }else if (&quot;(&quot;.equals(item) || operator.isEmpty() || heavy(item)&gt;heavy(operator.peek()) ){ operator.push(item); //否则，将前两个数字进行符号运算，结果入数字栈，操作符入操作栈 }else{ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); operator.push(item); } } } //循环完毕，若符号栈不为空，则从后往前运算，并将结果入数字栈 if (!operator.isEmpty()){ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); } //返回结果 return Double.parseDouble(number.pop()); } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); System.out.print(&quot;最终结果：&quot;+orgexp+&quot;=&quot;+InFixOperation(infix)); }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（3.5）——双向链表","slug":"数据结构笔记3.5","date":"2020-03-20T01:45:00.000Z","updated":"2020-06-16T11:40:37.220Z","comments":true,"path":"2020/03/20/数据结构笔记3.5/","link":"","permalink":"/2020/03/20/数据结构笔记3.5/","excerpt":"","text":"总体思路与单向链表类似，直接给出参考代码。 注：参考代码中各个算法均包含在类中. 单链表部分算法 链表定义//创建链表 public static class DouLinkedList&lt;E&gt; { //链表结点数据类型定义 public class Node{ //数据域，保存数据元素 public E data; //地址域，保存前后结点地址 public Node next; public Node pre; //构造结点，指定数据元素和后继结点 public Node(E data, Node next , Node pre){ this.data = data; this.next = next; this.pre = pre; } //初始化结点 public Node() { this(null,null,null); } } //链表大小 private int num = 0; //链表头结点 Node header; public DouLinkedList() { header = new Node(); } /**查找指定位置结点 * * @param n 位置 * @return 结点 */ private Node findNode(int n) { Node p = header; for (int i = 1; i &lt;= n; ++i) { p = p.next; } return p; } /** 代码6：打印顺序表 * **/ public void print() { System.out.print(&quot;顺序表长度为:&quot;+num+&quot;,内部元素为:&quot;); Node p = header; for (int i = 0; i &lt; num; i++){ p = p.next; System.out.print(p.data + &quot; &quot;); } System.out.println(); } } 插入算法 /**判断插入位置是否合法 * * @param n 插入位置 */ private void Check(int n) { if (n &lt;= 0 || n &gt; num+1) { throw new IndexOutOfBoundsException (&quot;插入位置不合法！&quot;); } } /**在链表头部插入 * * @param data 插入数据 */ public void addFirst(E data) { //如果是空表 if (num == 0){ addLast(data); return; } //创建一个新结点 Node newNode = new Node(); //将新结点和原结点的next和pre域指向相应结点 newNode.next = header.next; header.next.pre = newNode; header.next = newNode; //输入数据 newNode.data = data; //长度+1 ++num; } /**在链表尾部插入 * * @param data 插入数据 */ public void addLast(E data) { //创建一个新结点 Node newNode = new Node(); //找到最后一个结点p Node p = findNode(num); //各地址域指向相应结点 p.next = newNode; newNode.pre = p; //输入数据 newNode.data = data; //链表长度+1 ++num; } /** 在链表指定 n位置前插入结点 * * @param n 插入位置，从1计数 * @param data 插入元素 **/ public void add(int n, E data) { //判断插入位置是否合法 Check(n); if (n == 1) { addFirst(data); return; } if (n == num+1) { addLast(data); return; } //创建一个新结点 Node newNode = new Node(); //找到插入位置n前后的结点p,q Node p = findNode(n-1); Node q = findNode(n); //地址域指向相应 p.next = newNode; newNode.pre = p; newNode.next = q; q.pre = newNode; //输入数据 newNode.data = data; //链表长度+1 ++num; } 删除算法/** 删除链表第一个结点 * */ public void removeFirst() { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } //如果只有一个结点 if (num==1){ removeLast(); return; } //取得第一个结点p Node p = header.next; //相应地址域的改变 p.next.pre = null; header.next = p.next; p.next = null; p.pre = null; //链表长度-1 --num; } /**删除链表尾元素 * */ public void removeLast() { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空!&quot;); } //取得倒数第二个结点p,以及最后一个结点q Node p = findNode(num - 1); Node q = p.next; //相应地址域的改变 p.next = null; q.pre = null; //长度-1 --num; } /** 删除链表指定位置的结点 * * @param n 删除位置 **/ public void remove(int n) { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } //判断删除位置是否合法 CheckForRemove(n); if (n == 0) { removeFirst(); return; } if (n == num) { removeLast(); return; } //找到删除位置n前后的结点p、r，以及删除位置index的结点q Node p = findNode(n-1); Node q = p.next; Node r = q.next; //相应地址域改变 p.next = r; r.pre = p; q.next = null; q.pre = null; //链表长度-1 --num; } /** 判断删除位置是否合法 * * @param n 删除位置 **/ private void CheckForRemove(int n) { if (n &lt;= 0 || n &gt; num) { throw new IndexOutOfBoundsException(&quot;删除位置不合法！&quot;); } } 主函数测试public static void main(String[] args) { DouLinkedList&lt;Integer&gt; linkedList = new DouLinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); // 删除第一个元素 linkedList.removeFirst(); linkedList.print(); // 在链表中间删除元素 linkedList.remove(3); linkedList.print(); // 删除最后一个元素 linkedList.removeLast(); linkedList.print(); }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（4）——栈","slug":"数据结构笔记4","date":"2020-03-17T01:45:00.000Z","updated":"2021-08-18T07:38:02.348Z","comments":true,"path":"2020/03/17/数据结构笔记4/","link":"","permalink":"/2020/03/17/数据结构笔记4/","excerpt":"","text":"栈的相关概念➢栈：限定仅在表尾进行插入或删除操作的线性表。 ➢栈的特点：先进后出（FILO）或后进先出（LIFO）。 ➢栈的举例：子程序的嵌套、阶乘问题（递归问题）。 栈的操作注：参考代码中各个算法均包含在类中. 利用数组创建栈定义栈/**用数组创建栈 */ public static class Stack&lt;E&gt; { //初始化栈的最大容量为100 private static final int totall = 100; private Object[] datas; //n记录目前堆栈数据数量的变量 private int n; //初始化堆栈 public Stack() { this.n = 0; this.datas = new Object[totall]; } //打印链表 public void print(){ System.out.print(&quot;n=&quot;+n+&quot; 元素依次为：&quot;); for (int i = 0; i &lt;= n-1; i++){ System.out.print(datas[i]+&quot; &quot;); } System.out.println(); } } 入栈 /** 入栈 * @param data 入栈元素 **/ public void In(E data) { // 判断栈是否满 if (n == totall) { throw new RuntimeException(&quot;栈满，无法插入新元素!&quot;); } datas[n] = data; n++; } /**在栈底部增加 * * @param data 增加的数据 */ public void ButtonIn(E data){ //判断是否为空栈 if(this.n==0){ this.In(data); return; } // 判断栈是否满 if (this.n == totall) { throw new RuntimeException(&quot;栈满，无法插入新元素!&quot;); } //创建一个新过渡栈和过渡数据 Stack&lt;E&gt; stack1 =new Stack&lt;&gt;(); E data1; //取得增加前栈的数据数量 int n = this.n; //依次将原始栈中元素增加到过渡栈中 for(int i=0;i&lt;n;i++){ data1 = this.Out(); stack1.In(data1); } //此时原始栈为空，在原始栈增加data this.In(data); //将过渡栈中的数据增加到原始栈中 for(int i = 0; i&lt;n; i++){ data1 =(E) stack1.Out(); this.In(data1); } } ` 出栈/** 出栈 * * @return 返回栈顶元素 * **/ public E Out() { // 判断栈是否为空 if (n==0) { throw new RuntimeException(&quot;出栈顶失败，因为此时栈中没有元素！&quot;); } E topdata = (E) datas[n-1]; n--; return topdata; } /** 删除栈的底部元素 * */ public void ButtonOut(){ //判断是否为空栈 if(this.n==0){ throw new RuntimeException(&quot;出栈顶失败，因为此时栈中没有元素！&quot;); } // 判断栈是否只有一个元素 if (n == 1) { this.Out(); return; } //创建一个新过渡栈和过渡数据 Stack&lt;E&gt; stack1 =new Stack&lt;&gt;(); E data1; //取得减少前栈的数据数量 int n = this.n-1; //依次将原始栈中元素增加到过渡栈中 for(int i=0;i&lt;n;i++){ data1 = this.Out(); stack1.In(data1); } //此时原始栈只有一个元素，删除 this.Out(); //将过渡栈中的数据增加到原始栈中 for(int i = 0; i&lt;n; i++){ data1 =(E) stack1.Out(); this.In(data1); } } 主函数测试public static void main(String[] args){ Stack&lt;Integer&gt; stack =new Stack&lt;&gt;(); stack.In(4); stack.In(5); stack.In(6); stack.In(7); stack.In(8); stack.In(7); stack.In(6); stack.print(); Object x=stack.Out(); stack.print(); stack.ButtonIn(9); stack.print(); stack.ButtonOut(); stack.print(); } 利用链表创建栈定义栈//用链表创建栈 public static class Stuck&lt;E&gt;{ //创建结点 public class Node{ //创建结点的数据域和地址域 public E data; public E next; //添加方法修改结点 public Node(E data,E next){ this.data = data; this.next = next; } //初始化结点 public Node(){ this(null,null); } } //初始栈的大小 private final int totall = 100; //初始化当前栈占用的大小 private int num = 0; //创建头结点 Node header; //创建新栈 public Stuck(){ header = new Node(); } /** 查找指定位置的结点 * * @param n 查找位置 * @return 该位置结点 */ public Node FindNode(int n){ //创建新结点 Node thenode = header; //循环查找 for (int i = 0 ; i&lt;n ; i++){ thenode = (Stuck&lt;E&gt;.Node) thenode.next; } //返回 return thenode; } //打印 public void print(){ System.out.print(&quot;栈中数据数目num=&quot;+num+&quot; 分别为：&quot;); Node p = (Stuck&lt;E&gt;.Node) header.next; for (int i = 1 ; i &lt;= num ; i++){ System.out.print(p.data+&quot; &quot;); p = (Stuck&lt;E&gt;.Node) p.next; } System.out.println(); } } 入栈/** 在栈顶部添加数据 * * @param data 添加的数据 */ public void In(E data){ //检查是否栈满 if (num == totall-1){ throw new IndexOutOfBoundsException (&quot;栈满。&quot;); } //创建一个新结点 Node node = new Node(); //输入数据 node.data = data; //找到当前顶部结点 Node topnode = FindNode(num); //将顶部结点的next指向新结点 topnode.next = (E) node; //数目+1 ++num; } /** 在栈底部添加数据 * * @param data 添加的数据 */ public void InButtom(E data){ //检查是否栈满 if (num == totall-1){ throw new IndexOutOfBoundsException (&quot;栈满。&quot;); } //检查是否空栈 if (num == 0){ this.In(data); return; } //创建一个新结点 Node node = new Node(); //输入数据 node.data = data; //创建一个过渡栈 Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); //用循环将当前栈里元素移动到过渡栈中 int n = num; for (int i = 1 ; i&lt;=n ; i++){ stuck.In((Integer) this.Out()); } //此时原栈为空，增加新数据 this.In(data); //用循环将过渡栈里数据返回 for (int i = 1 ; i&lt;=n ; i++){ this.In((E) stuck.Out());; } } 出栈/**删除顶部数据 * * @return 顶部数据 */ public E Out(){ //判断是否为空 if (num == 0){ throw new IndexOutOfBoundsException (&quot;栈空。&quot;); } //找到顶端的两个结点 Node p = FindNode(num); Node q = FindNode(num-1); //将顶部的结点数据赋给其他变量，并删除 E data = p.data; p.data = null; //将第二顶端的结点地址域指向null q.next = null; //数目-1 --num; //返回删除数据 return data; } /** 在栈底部删除数据 * * @return 删除的数据 */ public E OutButtom(){ //检查是否空栈 if (num == 0){ throw new IndexOutOfBoundsException (&quot;栈空。&quot;); } //检查是否只有一个数据 if (num == 1){ return this.Out(); } //创建一个过渡栈 Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); //用循环将当前栈里元素移动到过渡栈中 int n = num-1; for (int i = 1 ; i&lt;=n ; i++){ stuck.In((Integer) this.Out()); } //此时原栈只有一个数据，删除数据 E data = this.Out(); //用循环将过渡栈里数据返回 for (int i = 1 ; i&lt;=n ; i++){ this.In((E) stuck.Out());; } //返回 return data; } 主函数测试public static void main(String[] args){ Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); stuck.In(1); stuck.In(2); stuck.In(3); stuck.In(4); stuck.print(); stuck.Out(); stuck.print(); stuck.InButtom(0); stuck.print(); Object x = stuck.OutButtom(); System.out.println(x); stuck.print(); } 两栈共享对两栈共享情况来说，将两个栈底分别设在两端， 两个栈顶指针 top1 和 top2 相对中间位置动态移动，两个栈之间的分界线是不定的。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（3）——线性表链式储存结构","slug":"数据结构笔记3","date":"2020-03-10T01:45:00.000Z","updated":"2020-06-16T11:40:42.093Z","comments":true,"path":"2020/03/10/数据结构笔记3/","link":"","permalink":"/2020/03/10/数据结构笔记3/","excerpt":"","text":"相关概念结点：数据元素的存储映像。由数据域和地址域两部分组成。➢ 数据域：元素本身信息➢ 地址域：指示直接后继的存储位置 链表：n个结点由地址域组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。➢ 链表种类：单链表、双链表、多链表、循环链表。 有关头结点的作用：为了对链表进行操作时，可以对空表、非空表的情况以及对首元素节点进行统一处理，编程更方便。 特点1、用一组任意的存储单元存储线性表的数据元素，易插入和删除。2、利用指针实现了用不相邻的存储单元存放逻辑上相邻的元素。3、存储结构较复杂，每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息结点。4、不需要预先分配空间。 适用于：频繁需要插入、删除数据的线性表。 单链表算法注：参考代码中各个算法均包含在类中. 插入算法总体参考思路首先定义一个单链表，在单链表中定义结点，结点包括两个属性：数据和地址，再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义六个函数。 判断插入位置是否合法 rangeCheckForAdd(int index) 头部增加元素 addFirst(E data) 在指定位置增加元素 add(int index, E data) 尾部增加元素 addLast(E data) 查找指定位置前的元素 findNode(int index) 打印链表 print() 代码参考 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node header; public LinkedList() { header = new Node(); } //单链表结点数据类型定义 public class Node{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node next; //构造结点，指定数据元素和后继结点 public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(null,null); } } /** 代码3： 在链表中间指定 index 位置前插入结点 * @param index 插入位置，从0计数 * @param data 插入元素 **/ public void add(int index, E data) { // 1. 判断插入位置是否合法 rangeCheckForAdd(index); if (index == 0) { addFirst(data); return; } if (index == size) { addLast(data); return; } // 2. 创建一个新结点 Node newNode = new Node(); // 3. 找到插入位置index前的结点p Node p = findNode(index); // 4. 将新结点的next域指向p结点的next域 newNode.next = p.next; // 5. 将p结点的next域指向新结点 p.next = newNode; // 6. 输入数据 newNode.data = data; // 7. 链表长度+1 ++size; } /** 代码2： 在链表头部插入结点 * @param data 插入元素 **/ public void addFirst(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 将新结点的next域指向为header结点的next域 newNode.next = header.next; // 3. 将header结点指向新结点 header.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码4 在链表尾部插入结点 * @param data 插入元素 **/ public void addLast(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 找到最后一个结点q Node q = findNode(size); // 3. 将q结点的next域指向新结点 q.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码1：判断插入位置是否合法 * @param index 插入位置 **/ private void rangeCheckForAdd(int index) { if (index &lt; 0 || index &gt; size) { throw new IndexOutOfBoundsException (&quot;插入位置不合法！&quot;); } } /** 代码5：找到指定位置index前的结点P * @param index 插入位置，从0计数 * @return 指定位置结点 **/ private Node findNode(int index) { Node p = header; for (int i = 0; i &lt; index; ++i) { p = p.next; } return p; } /** 代码6：打印顺序表 * @param index 插入位置，从0计数 * @return 指定位置结点 **/ public void print() { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); Node p = header; for (int i = 0; i &lt; size; i++){ p = p.next; System.out.print(p.data + &quot; &quot;); } System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); } 其他思路同样定义一个单链表，在单链表中定义结点，结点在存储数据的空间中专门拿出一部分储存地址信息，再在单链表类中定义与插入有关的各种方法。 以下给出创建类和内部类的方法，其他方法视情况修改。 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node&lt;E&gt; header; public LinkedList() { header = new Node&lt;&gt;(); } //单链表结点数据类型定义 public class Node&lt;E&gt;{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node&lt;E&gt; next; //构造结点，指定数据元素和后继结点 public Node(E data, Node&lt;E&gt; next){ this.data = data; this.next = next; } public Node() { this(null,null); } } } 删除算法总体参考思路与上文插入算法类似，只是再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义五个函数。 删除头部元素 removeFirst() 删除尾部元素 removeLast() 删除指定位置的元素 remove(int index) 判断删除位置是否合法 rangeCheckForRemove(int index) 打印链表 print() 代码参考 //定义类与上文相同 public class LinkedList&lt;E&gt; { private int size = 0; Node header; public LinkedList() { header = new Node(); } public class Node{ public E data; public Node next; public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(0,null); } } /** 代码1 删除链表第一个结点 **/ public void removeFirst() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 取得第一个结点p Node p = header.next; // 3. 将 header 的 next 域指向p结点的 next域 header.next = p.next; // 4. 将p结点的 next 域设为 null ，回收p内存 p.next = null; // 5. 链表长度- -1 1 --size; } /** 代码2 ：删除链表尾元素 **/ public void removeLast() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空!&quot;); } // 2. 取得倒数第二个结点p,以及最后一个结点q Node p = findNode(size - 1); Node q = p.next; // 3. 将p的next域指向q的next域 p.next = q.next; // 4. 链表长度-1 --size; } /** 代码3：删除链表指定位置的结点 * @param index 删除位置 **/ public void remove(int index) { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 判断删除位置是否合法 rangeCheckForRemove(index); // 3.判断特殊情况 if (index == 0) { removeFirst(); return; } if (index == size - 1) { removeLast(); return; } // 4. 找到删除位置index前的结点p，以及删除位置index的结点q Node p = findNode(index); Node q = p.next; // 5. 将p结点的next域指向q结点的next域 p.next = q.next; // 6. 将q结点的next域设为null，回收q内存 q.next = null; // 7. 链表长度-1 --size; } /** 代码4： 判断删除位置是否合法 * @param index 删除位置 **/ private void rangeCheckForRemove(int index) { if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;删除位置不合法！&quot;); } } /** 代码5：打印顺序表。（同上，略）*/ } 主代码测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); // 删除第一个元素 linkedList.removeFirst(); linkedList.print(); // 在链表中间删除元素 linkedList.remove(3); linkedList.print(); // 删除最后一个元素 linkedList.removeLast(); linkedList.print(); } 插入删除算法的时间复杂度单链表的插入删除算法由两部分构成，第一是查找到第index个结点，第二是插入和删除结点。所以，如果我们不知道第index个结点的具体位置，链式存储与顺序存储的插入、删除算法都是O（n）。 连接算法若现已存在两个链表，需将这两个链表连起来。其中一个算法是直接将其中一个链表的末端接到另一个的首段，不再赘述。 另一个算法为：若已知链表的数据元素按值非递减有序排列，将两表归并为一个新的线性表, 且其中的数据元素仍按值非递减排列。 整体参考思路搜索：需要两个指针搜索两个链表；比较：比较结点数据域中数据的大小；插入：将两个结点中数据，小的结点插入新链表。 参考代码//创建方法Connection public static LinkedList&lt;Integer&gt; Connection(LinkedList&lt;Integer&gt; a, LinkedList&lt;Integer&gt; b){ LinkedList&lt;Integer&gt; c = new LinkedList&lt;&gt;(); //创建指针，并指向第一个结点 LinkedList&lt;Integer&gt;.Node pa=a.header.next; LinkedList&lt;Integer&gt;.Node pb=b.header.next; //比较指针指向结点大小，依次填入单链表c中，直至其中一个单链表全部录完 while (pa != null &amp;&amp; pb != null){ if (pa.data &gt;= pb.data){ c.addLast(pb.data); pb = pb.next; }else { c.addLast(pa.data); pa = pa.next; } } //将录完单链表的另一个依次录入 if (pa==null){ while(pb!=null){ c.addLast(pb.data); pb=pb.next; } }else if(pb==null){ while(pa!=null){ c.addLast(pa.data); pa=pa.next; } } //返回 return c; } 主函数测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedListA =new LinkedList&lt;&gt;(); linkedListA.addLast(3); linkedListA.addLast(5); linkedListA.addLast(8); linkedListA.addLast(11); linkedListA.print(); LinkedList&lt;Integer&gt; linkedListB =new LinkedList&lt;&gt;(); linkedListB.addLast(2); linkedListB.addLast(6); linkedListB.addLast(8); linkedListB.addLast(9); linkedListB.addLast(11); linkedListB.print(); LinkedList&lt;Integer&gt; linkedListC = new LinkedList&lt;&gt;(); linkedListC=Connection(linkedListA,linkedListB); linkedListC.print(); } 单链表应用一元多项式运算 关于其他链表双链表部分算法 其他的链表与单链表类似，地址域有一定改变，其方法也同样有一定改变，这里不再赘述。（其实就是我懒。）","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（2）——线性表及其顺序储存结构","slug":"数据结构笔记2","date":"2020-03-03T01:45:00.000Z","updated":"2020-06-16T11:40:30.076Z","comments":true,"path":"2020/03/03/数据结构笔记2/","link":"","permalink":"/2020/03/03/数据结构笔记2/","excerpt":"","text":"线性表的逻辑结构定义：数据元素之间的关系为一一对应的n个数据元素。 （a0，a1，…，ai-1，ai，ai+1，…，an-1）a0：线性起点ai-1：前趋ai+1：后继an-1：线性终点 均匀性：数据类型相同。有序性：不可交换次序。 内存地址：Loc(i)+L0+i×m（m：每个元素所占用的存储单元个数） 线性表的顺序存储结构及算法特点、优缺点 特点 数据连续存放、随机存取设备。 逻辑上和物理上相邻。 存储结构简单、易实现。 插入、删除操作不便。 存储密度大，空间利用率高。 优点 无需为表示表中元素之间的逻辑关系而增加存储空间。 可以快速取出表中的任一元素。 缺点 插入删除操作需要移动大量元素。 当线性表长度变化较大时难以确定空间容量。 ，需要预先分配空间，且容易造成存储空间的“碎片”。 适用：表中元素变动较少的情况，且拥有连续的存储空间。 插入算法注：参考代码中各个算法均包含在类中. 思路1、判断插入位置是否合法。2、将第n-1至第i个元素后移一个存储位置。3、将要插入的x元素插入到ai-1之后。4、表长度+1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ public static class SequenceList&lt;E&gt;{ //用数组存储顺序表 private Object[] seqList; //顺序表的元素个数 private int size =0; //初始化顺序表 public SequenceList(){ seqList= new Object[1000]; } /** 定义：在顺序表中末尾添加元素函数 add(E element) * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(E element) { seqList[size] = element; ++size; return true; } /** 定义在顺序表某位置插入函数add(int index, E element) * @param index 插入位置 * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(int index, E element) { // 1. 判断插入是否合法 rangeCheckForAdd(index); // 2. 将存储在size-1位置至index位置的元素依次后移一个位置 for (int i = size; i &gt; index; --i) { seqList[i] = seqList[i - 1]; } // 3. 将x插入到index位置 seqList[index] = element; // 4. 表的长度+1 ++size; return true; } /** 定义插入位置是否合法函数 rangeCheckForAdd(int index) * @param index 插入位置*/ private void rangeCheckForAdd (int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(&quot;插入位置不合法！&quot;); } /** 定义打印顺序表函数 print ( ) * 打印顺序表*/ public void print( ) { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); for (int i = 0; i &lt; size; ++i) System.out.print(seqList[i] + &quot; &quot;); System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList=new SequenceList&lt;Integer&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.add(2); seqList.print( ); // 在1位置插入元素7 seqList.add(1, 7); seqList.print( ); } 时间复杂度在有n个元素的顺序表中，插入的位置有n+1个，并且是等可能的。O(n) 删除算法注：参考代码中各个算法均包含在类中. 思路1、判别指定的位置是否合法2、若合法，则将位置i+1至n上的元素前移一个存储位置3、表的长度 -1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ /** 同上 **/ public static class SequenceList&lt;E&gt;{ private Object[] seqList; private int size =0; public SequenceList(){ seqList= new Object[1000]; } /** 定义删除指定位置的元素函数 remove(int index) * @param index 删除位置 */ public void remove(int index) { // 1. 判别指定的位置是否合法 rangeCheckForRemove(index); // 2. 将位置index+1 至 size-1 位置上的元素前移一个位置 for (int i = index+1; i &lt;= size - 1; ++i) { seqList[i-1] = seqList[i]; } // 3. 表的长度-1 --size; } /** 定义删除位置是否合法函数 rangeCheckForRemove(int index) * @param index 删除位置 */ private void rangeCheckForRemove (int index) { if (index &gt;= size || index &lt; 0) throw new IndexOutOfBoundsException (&quot;删除位置不合法！&quot;); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList = new SequenceList&lt;&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.print(); // 在1位置插入元素7 seqList.add(1, 7); seqList.print(); // 删除1位置元素 seqList.remove(1); seqList.print(); } 时间复杂度在有n个元素的顺序表中，可以删除的元素有n个，并且是等可能的。O(n)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"我和碧蓝航线","slug":"碧蓝航线1000天纪念","date":"2020-02-27T08:00:00.000Z","updated":"2020-06-10T03:54:32.598Z","comments":true,"path":"2020/02/27/碧蓝航线1000天纪念/","link":"","permalink":"/2020/02/27/碧蓝航线1000天纪念/","excerpt":"","text":"关于1000天当天那天相当震憾，有必要提一下。 不知道是疫情影响，还是因为正值毛子活动维护，当天就创了上线人数新高，所以这群在群里嘴上说冲的人一开服就把这游戏的服务器冲爆了，本来是下午3点开服，结果拖到了8点才基本解决问题，相当震憾。（人多可以理解，而且炸服补偿到位也就不说什么了） 一些想法其实如果不是这次惊喜和小加加在官博发文，都不知道这游戏已经1000天了，现在碧蓝航线在我taptap上的在线时间是最多的，1200多个小时，虽然大部分也只是在看后勤，打日常，但确实这游戏是我不舍得弃坑的游戏。 其实我实在舰b开服后两三天里在b站上的广告得知的，当时我对这游戏知之甚少，但是对于一名wows玩家，对二战的海军还是挺感兴趣的，并且看到游戏宣传里企业、拉菲和欧根的立绘，尤其是欧根亲王，就感觉这游戏的游戏资源有点东西胸有大痣，就想着下载来玩一下，就玩到今天了。 当时不知道为什么会对这三个角色有特别的偏好，直到现在业界有科学理论来证实这一现象了：“All Chinese love white hair” 因为我对于手游的态度一向是比较佛系的，而且当时我已步入准高三，所以当时并没有花太多时间在碧蓝航线上，即使我经历过第一次夏活，也对舰b并没有太多感受。所以即使游戏当时的口碑爆炸，我也没有什么亲身体会。 我当时脑子抽了，把装备回收箱和情人节礼物给用了，f**k（简洁有力的维多利亚方言） 开始认真对待这游戏的时候已经是高三寒假和下学期了（高三有什么寒假，别问为什么高三还有时间玩游戏），然后才意识到舰b在当时的手游范围内算是比较良心的了，而且碧蓝航线对自己的定位相当准确，高质量的皮肤，较低的抽卡成本，容易获得的高强度角色让人欲罢不能。她就像一个精打细算的商人，让自己赚钱的同时，让我们花钱的同时获得尽可能大的回报。 这live2d皮肤不香吗 碧蓝航线把“All Chinese love white hair”这一（伪）科学理论表现得淋漓尽致，从每年的人气投票就可以看出，这个梗在圈里过于有名，以至于传到了国外，这也可以看出碧蓝航线确实很懂得自己的定位。其实我对哪种立绘的偏爱是在碧蓝航线中才逐渐了解的，也让我真正对“画师”有了浅显的理解。就是喜欢黑兔的立绘 这游戏愿意肝也可以肝，愿意养老也可以，氪金和不氪金的玩家、肝帝和咸鱼玩家、研究党和娱乐党都可以玩的很高兴。 这游戏到后期本质就是一个聊天软件，一群人大多数时间在公屏里讨论除了碧蓝航线的各种话题，据说通过公屏还成了几对。每个人都可以在碧蓝航线里找到自己的老婆。（雾） 个人感觉，在碧蓝圈子里大多数人都是很和谐的，大家在群里吹吹水也十分和谐，这是我这些年来一直在玩碧蓝的原因之一，也让我认识到对海军感兴趣的大多数人是一群精苏玩家。除了第一次夏活难度的不合理，饺子的开火限制解除，某些皮肤过于xx而被举报外并没有什么大的节奏问题，也许这也正是成就碧蓝航线的原因之一。 对于皮肤，我觉得大多数的玩家反而希望这种皮肤越多与好，你还能对一个曾经适龄年龄13岁，之后提到了18+岁的游戏说什么吗。 结尾转眼间，这游戏已经1000天了，再过几个月就要三周年了，虽然因为各种原因国服难以与日服在本子那边的热度难以相比，但依然希望碧蓝在国内能够继续运营下去，毕竟这游戏确实不错。 最后，大舰队什么的。。。 国服玩家只能看本子的生放送获取最新消息，看美服玩家1周年在衣阿华战列舰上开127mm高平炮。 某些图不方便发，p站上搜一大堆。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"《数据结构》笔记（1）——绪论","slug":"数据结构笔记1","date":"2020-02-25T01:45:00.000Z","updated":"2020-06-16T11:56:28.625Z","comments":true,"path":"2020/02/25/数据结构笔记1/","link":"","permalink":"/2020/02/25/数据结构笔记1/","excerpt":"","text":"认识数据结构 数值计算：利用数学方程。 步骤：具体问题→数学模型→算法→编程、调试→得到答案 非数值计算：利用数据结构。 步骤：问题→抽象出问题的模型→求模型的解 类型：线性结构（一对一）；非线性结构【树形结构（一对多）、图形结构（多对多）】 （注：判断是否为线性结构优先画图，更直观。） 基本概念数据：对信息的一种符号表示。数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。数据项是数据的不可分割的最小单位。数据类型：性质相同的数据元素的组合。（注：数据由数据元素构成，数据元素由数据项构成。数据＞数据元素＞数据项） 数据结构：1、数学概念：S=（D，R）数据和关系的集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、内容概念：逻辑结构+存储结构+算法。（数据逻辑结构独立于计算机，存储结构依赖于计算机，运算定义依赖于逻辑结构，实现依赖于存储结构。） ADT——抽象数据类型，数据↔操作，ADT=（R,S,T）&ensp;&ensp;&ensp;&ensp;定义：1、使用视图：逻辑结构+操作集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、设计视图：存储结构+算法设计&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3、实现视图：成员变量+成员函数 逻辑结构 集合 线性结构 线性表 栈 队列 串级数组 非线性结构 树形结构 图形结构 存储结构 顺序存储方式：存储空间连续。 链式储存方式：存储空间不连续。 索引存储方式：索引表。 散列存储方式：哈希函数。 算法程序=算法+数据结构 定义：有穷规则的集合，规则确定一个解决某一特定类型问题的操作序列。 特征：输入、输出、确定性、有穷性、可行性。 原则：正确性、可读性、健壮性（容错处理）、效率与存储量的需求。 方式：自然语言、流程图、伪代码。 算法评价：时间复杂度——定性描述该算法的运行时间。常用大O符号表述，不包括这个函数的低阶项和首项系数。 程序设计实质：数据的表示和处理。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《决战中途岛》观后感","slug":"决战中途岛观后感","date":"2020-02-20T05:33:00.000Z","updated":"2020-06-10T03:52:24.498Z","comments":true,"path":"2020/02/20/决战中途岛观后感/","link":"","permalink":"/2020/02/20/决战中途岛观后感/","excerpt":"","text":"作为一个稍微对二战历史感兴趣的，并且入坑了舰c、舰b、wows、舰r（虽然在入坑舰c后退坑了）的人，有一部以二战时期的太平洋战场为背景的电影，无论电影好坏都是要看的，现在二战题材的电影又少之又少（毕竟市场小，不赚钱）。之前上映的时候找不到同圈子的人去看，趁着b站上映就去看了。对于自己来说，这是一部不错的电影。 剧情简介《决战中途岛》是由罗兰·艾默里奇执导由伍迪·哈里森、卢克·伊万斯、帕特里克·威尔森、曼迪·摩尔、艾德·斯克林、浅野忠信等主演的电影。 该片于2019年11月8日北美、中国内地同步上映。中途岛战役于1942年——日本偷袭美国珍珠港事件半年之后在南太平洋爆发，美国海军在中途岛环礁成功击退日本帝国海军舰队的攻击，获得了太平洋战区的主动权，这场战役被历史学家视为战争的转折点。 影片改编自1942年6月的中途岛战役，是整个太平洋战争的关键转折点，扭转了自珍珠港事件之后反法西斯盟军节节败退的局面。同时，这也是世界历史上著名“以小搏大”的战役之一，在海空军力大幅弱于日本的情况下，美军以沉没一艘航空母舰为代价，一举击沉日本主力航空母舰四艘、巡洋舰一艘。此次战役的胜利，彻底改变了反法西斯战争的格局，为二战胜利打下坚实的基础。 （摘自“百度百科”） 观后感这部分观后感极具主观色彩，且偏向肯定方向，在此说明。 bug作为一个有点了解那个时期历史的人，最喜欢的就是找bug。印象最深的就是联合舰队有5条大和。。 灭 国 舰 队 / 未 曾 设 想 的 道 路 / 震 撼 美 帝 / wows 10 级 房 现 状 其实还有其他的bug，比如珊瑚海代替太太（列克星敦）沉的是约克城。 约克城你好惨啊，在一部剧里沉了两次。 又或是主炮是鱼雷的驱逐舰。 但印象最深的还是麦克拉斯基发现本子舰队的名场面，这个梗估计这一年我都忘不了。 5艘大和你能把我秒了？ 毕竟经费有限可以理解，而且无伤大雅，所以就在这里调侃一番为止。 优点1、与《珍珠港》相比，这部电影里面没有谈恋爱！没有谈恋爱！没有谈恋爱！所有角色为剧情服务。 男人要看就看大舰巨炮，辣鸡三角恋。 2、难得的全景式、多方位记录一场二战的战争的电影，剧情流水账，主要场景在企业上，偏向于战争纪录片，估计没个5、6年是看不到下一部了，且看且珍惜。 3、国外二战电影中难得有中国内容的电影——空袭东京后，中国军民协助撤离杜立特编队成员，并且当时也因为掩护他们而牺牲了许多人。也可能是因为中国投资方投资比例最大。 不要在意那个微软字体的牌坊。 4、电影中有些情节能使得对历史有一定了解的人感到亲切，比如美帝的铁棍雷，以及本子海军传统艺能——最大的敌人是陆军，还有企业上的牛排，等。 全剧唯二笑的地方就是美帝的铁棍雷，另一个就是五艘大和。 5、演员基本贴合史实，没有强加政治正确元素。 看到剧中的飞龙舰长山口多闻总感觉他们在打外星人。 6、作为中心的中途岛战役该表现的情节基本上表现到了，看得既惊险又刺激，比如vt8鱼雷编队的惨烈，贝斯特俯冲轰炸一发入魂赤诚的情节。 缺点1、由于主要讲述的是中途岛战役，要在两个小时左右既要展现主题，又要讲清前因后果是比较困难的，尤其在经费不足的情况下从珍珠港开始，所以在中途岛之前剧情跳转迅速，比如珊瑚海中列克星敦转眼就沉了，如果不是对历史有点认识的话可能会一脸懵b。好在中途岛之中表现不错。 2、同样是因为经费有限，在中途岛之前的特效有明显的不自然的情况，无法与其他大多数知名战争片相比。 3、由于是全景式、多方位的电影，部分角色的人物形象不太深刻。有些本（感觉）应该是重要的剧情和人物也没有体现出来，比如中途岛一战成名的美方指挥官斯普鲁恩斯，在电影中只有过场；“AF可能缺乏淡水”在中途岛战役中的著名电报，在电影中并未着墨太多。 其他1、剧中在企业上爬上飞机打偏本子神风的猛男——布鲁诺·盖多，在一天干翻两艘航母的俯冲轰炸的猛男——理查德·迪克·贝斯特，在中途岛拍纪录片，后来得了奥斯卡的的导演——约翰·福特，等，都是史实，比抗日神剧的剧情好的太多。 2、电影否定了“命运五分钟”的说法，还进行了调侃。 现在不是昭和，大人，时代变了。 3、由于要增加观众的观看体验，电影中加强了本子的防空火力，历史中本子拉不出那样的防空火力网。 轮射的96神炮，昭和防空。 4、电影的剧本其实很早就基本完成，结果在美国没有投资人感兴趣，直到中方进行投资。（那可是你们父辈的荣光啊） 5、这部电影注定不会有高票房，资方亏钱情理之中，谁叫这个市场小呢。 总结对于对历史感兴趣的人来说，个人建议必看，其他的话也许需要稍微了解一下珍珠港、珊瑚海的相关情况，不然开始的一个小时可能会有点懵。不过对于想了解那一段历史，或者是因为感兴趣，或者单纯是要看“Lucky E”的人来说，都是一部个人推荐的，值得去看的电影。 顺便剧透一下：美帝赢了，本子输了。 大海铭记不朽。为电影的工作人员点赞。 电影之外的东西1、我想起初中的时候自己还年少不懂事，认为本子当年就很傻，没事就偷袭美帝，既把德国拉下水，又给自己找了个爹。现在想起来真是惭愧不如。 2、中途岛都安排了，什么时候安排一下莱特湾？ （但莱特湾估计不太可能，毕竟美帝方面指挥有失误。那以塔菲三号为中心也行。） 3、还有，美帝战后把企业拆了，果然敌在国会山。（和“老女士”厌战一样，工党误国） 企业：我为国家流过血！我要见总统！ 之后企业当核航妈去了，厌战当死库水（潜艇）去了","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"电影","slug":"电影","permalink":"/tags/电影/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"谨此纪念霜星","slug":"谨此纪念霜星","date":"2019-12-25T01:58:00.000Z","updated":"2020-06-10T03:54:43.032Z","comments":true,"path":"2019/12/25/谨此纪念霜星/","link":"","permalink":"/2019/12/25/谨此纪念霜星/","excerpt":"","text":"“…等我们自由了，我们会放声大哭，在荒野里在雪地里，在堆得满满的麦垛里放声大哭” 圣诞节的礼物？？想起其他的牺牲的干员了（Ace、Scout）。。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"Hello World","slug":"Hello World","date":"2019-12-09T09:50:00.000Z","updated":"2020-06-10T03:51:54.125Z","comments":true,"path":"2019/12/09/Hello World/","link":"","permalink":"/2019/12/09/Hello World/","excerpt":"","text":"某种意义上的“First Post”，总结了建站时hexo自带的《Hello World》和主题Sakura的使用文档。 关于hexo关于hexo更多的信息可以查看官网的使用文档，使用中存在的问题可以在troubleshooting查找，或者在GitHub上提问。 创建$ hexo new &quot;My New Post&quot; More info: Writing 启动服务器$ hexo server More info: Server 生成文件$ hexo generate More info: Generating 发布$ hexo deploy More info: Deployment 清理清理本地文件，防止修改部分文件后出现错误。 $ hexo clean 本地调试$ hexo clean &amp;&amp; hexo s 上传服务器$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 关于Sakura主题hexo-theme-sakura主题基于WordPress主题Sakura修改成Hexo的主题。 详细使用方法查看使用文档。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}