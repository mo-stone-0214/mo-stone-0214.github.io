{"meta":{"title":"The Base of MoStone","subtitle":"我们，依旧在路上。","description":null,"author":"Mo_Stone","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-01-31T03:09:53.290Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[MoStone] 与&nbsp; MoStone&nbsp; （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"arknights","date":"2018-12-20T15:14:28.000Z","updated":"2020-01-17T14:00:37.630Z","comments":false,"path":"arknights/index.html","permalink":"/arknights/index.html","excerpt":"","text":"","keywords":"明日方舟编年史"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-01-28T13:27:29.579Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-01-28T14:45:57.579Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-01-28T13:14:31.136Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"本主题基于Hexo主题Sakura修改,感谢作者hojun。Hexo版修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-29T12:27:53.526Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"","date":"2020-01-14T12:56:52.907Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/README.html","permalink":"/lib/reading_progress/README.html","excerpt":"","text":"Reading Progress for NexT Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: $ cd themes/next $ ls bower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: $ git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress Step 3 &rarr; Set it up Enable module in NexT _config.yml file: reading_progress: enable: true color: &quot;#37c6c0&quot; height: 2px And, if you wants to use the CDN, then need to set: vendors: ... reading_progress: //cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js Update $ cd themes/next/source/lib/reading_progress $ git pull"},{"title":"","date":"2020-01-14T12:56:52.901Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/package.json","permalink":"/lib/reading_progress/package.json","excerpt":"","text":"{\"name\":\"theme-next-reading-progress\",\"version\":\"1.2.0\",\"description\":\"Reading Progress for NexT\",\"main\":\"reading_progress.js\",\"scripts\":{\"uglify\":\"uglifyjs --compress --mangle -o reading_progress.min.js -- reading_progress.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-reading-progress.git\"},\"author\":\"theme-next\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-reading-progress/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-reading-progress#readme\",\"dependencies\":{\"uglify-js\":\"^3.3.9\"}}"},{"title":"","date":"2020-01-14T12:56:52.903Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.js","permalink":"/lib/reading_progress/reading_progress.js","excerpt":"","text":";(function() { var $bar = $('.reading-progress-bar') if (!$bar.length) return //no progress bar found var supportsPassive = false try { var opts = Object.defineProperty({}, 'passive', { get: function() { supportsPassive = true } }) window.addEventListener('test', $.noop, opts) window.removeEventListener('test', $.noop) } catch (e) {} var $w = $(window) var $d = $(document) $d.ready(function() { window.addEventListener( 'scroll', function() { var wh = $w.height() var dh = $d.height() var st = $w.scrollTop() var percent = (st / (dh - wh)) * 100 percent = percent > 100 ? 100 : percent < 0 ? 0 : percent $bar.css('width', percent + '%') }, supportsPassive ? { passive: true } : false ) }) })()"},{"title":"","date":"2020-01-14T12:56:52.905Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.min.js","permalink":"/lib/reading_progress/reading_progress.min.js","excerpt":"","text":"!function(){var e=$(\".reading-progress-bar\");if(e.length){var n=!1;try{var t=Object.defineProperty({},\"passive\",{get:function(){n=!0}});window.addEventListener(\"test\",$.noop,t),window.removeEventListener(\"test\",$.noop)}catch(e){}var i=$(window),o=$(document);o.ready(function(){window.addEventListener(\"scroll\",function(){var n=i.height(),t=o.height(),r=i.scrollTop()/(t-n)*100;r=r>100?100:r"},{"title":"","date":"2020-01-14T12:56:52.910Z","updated":"2019-12-13T04:47:50.084Z","comments":true,"path":"lib/reading_progress/renovate.json","permalink":"/lib/reading_progress/renovate.json","excerpt":"","text":"{\"extends\":[\"config:base\"]}"}],"posts":[{"title":"《数据结构》笔记（3）——线性表链式储存结构和算法","slug":"数据结构笔记3","date":"2020-03-10T01:45:00.000Z","updated":"2020-03-14T10:46:58.846Z","comments":true,"path":"2020/03/10/数据结构笔记3/","link":"","permalink":"/2020/03/10/数据结构笔记3/","excerpt":"","text":"相关概念结点：数据元素的存储映像。由数据域和地址域两部分组成。➢ 数据域：元素本身信息➢ 地址域：指示直接后继的存储位置 链表：n个结点由地址域组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。➢ 链表种类：单链表、双链表、多链表、循环链表。 有关头结点的作用：为了对链表进行操作时，可以对空表、非空表的情况以及对首元素节点进行统一处理，编程更方便。 特点1、用一组任意的存储单元存储线性表的数据元素，易插入和删除。2、利用指针实现了用不相邻的存储单元存放逻辑上相邻的元素。3、存储结构较复杂，每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息结点。4、不需要预先分配空间。 适用于：频繁需要插入、删除数据的线性表。 单链表算法插入算法总体参考思路首先定义一个单链表，在单链表中定义结点，结点包括两个属性：数据和地址，再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义六个函数。 判断插入位置是否合法 rangeCheckForAdd(int index) 头部增加元素 addFirst(E data) 在指定位置增加元素 add(int index, E data) 尾部增加元素 addLast(E data) 查找指定位置前的元素 findNode(int index) 打印链表 print() 代码参考 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node header; public LinkedList() { header = new Node(); } //单链表结点数据类型定义 public class Node{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node next; //构造结点，指定数据元素和后继结点 public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(null,null); } } /** 代码3： 在链表中间指定 index 位置前插入结点 * @param index 插入位置，从0计数 * @param data 插入元素 **/ public void add(int index, E data) { // 1. 判断插入位置是否合法 rangeCheckForAdd(index); if (index == 0) { addFirst(data); return; } if (index == size) { addLast(data); return; } // 2. 创建一个新结点 Node newNode = new Node(); // 3. 找到插入位置index前的结点p Node p = findNode(index); // 4. 将新结点的next域指向p结点的next域 newNode.next = p.next; // 5. 将p结点的next域指向新结点 p.next = newNode; // 6. 输入数据 newNode.data = data; // 7. 链表长度+1 ++size; } /** 代码2： 在链表头部插入结点 * @param data 插入元素 **/ public void addFirst(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 将新结点的next域指向为header结点的next域 newNode.next = header.next; // 3. 将header结点指向新结点 header.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码4 在链表尾部插入结点 * @param data 插入元素 **/ public void addLast(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 找到最后一个结点q Node q = findNode(size); // 3. 将q结点的next域指向新结点 q.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码1：判断插入位置是否合法 * @param index 插入位置 **/ private void rangeCheckForAdd(int index) { if (index &lt; 0 || index &gt; size) { throw new IndexOutOfBoundsException (&quot;插入位置不合法！&quot;); } } /** 代码5：找到指定位置index前的结点P * @param index 插入位置，从0计数 * @return 指定位置结点 **/ private Node findNode(int index) { Node p = header; for (int i = 0; i &lt; index; ++i) { p = p.next; } return p; } /** 代码6：打印顺序表 * @param index 插入位置，从0计数 * @return 指定位置结点 **/ public void print() { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); Node p = header; for (int i = 0; i &lt; size; i++){ p = p.next; System.out.print(p.data + &quot; &quot;); } System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); } 其他思路同样定义一个单链表，在单链表中定义结点，结点在存储数据的空间中专门拿出一部分储存地址信息，再在单链表类中定义与插入有关的各种方法。 以下给出创建类和内部类的方法，其他方法视情况修改。 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node&lt;E&gt; header; public LinkedList() { header = new Node&lt;&gt;(); } //单链表结点数据类型定义 public class Node&lt;E&gt;{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node&lt;E&gt; next; //构造结点，指定数据元素和后继结点 public Node(E data, Node&lt;E&gt; next){ this.data = data; this.next = next; } public Node() { this(null,null); } } } 删除算法总体参考思路与上文插入算法类似，只是再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义五个函数。 删除头部元素 removeFirst() 删除尾部元素 removeLast() 删除指定位置的元素 remove(int index) 判断删除位置是否合法 rangeCheckForRemove(int index) 打印链表 print() 代码参考 //定义类与上文相同 public class LinkedList&lt;E&gt; { private int size = 0; Node header; public LinkedList() { header = new Node(); } public class Node{ public E data; public Node next; public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(0,null); } } /** 代码1 删除链表第一个结点 **/ public void removeFirst() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 取得第一个结点p Node p = header.next; // 3. 将 header 的 next 域指向p结点的 next域 header.next = p.next; // 4. 将p结点的 next 域设为 null ，回收p内存 p.next = null; // 5. 链表长度- -1 1 --size; } /** 代码2 ：删除链表尾元素 **/ public void removeLast() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空!&quot;); } // 2. 取得倒数第二个结点p,以及最后一个结点q Node p = findNode(size - 1); Node q = p.next; // 3. 将p的next域指向q的next域 p.next = q.next; // 4. 链表长度-1 --size; } /** 代码3：删除链表指定位置的结点 * @param index 删除位置 **/ public void remove(int index) { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 判断删除位置是否合法 rangeCheckForRemove(index); // 3.判断特殊情况 if (index == 0) { removeFirst(); return; } if (index == size - 1) { removeLast(); return; } // 4. 找到删除位置index前的结点p，以及删除位置index的结点q Node p = findNode(index); Node q = p.next; // 5. 将p结点的next域指向q结点的next域 p.next = q.next; // 6. 将q结点的next域设为null，回收q内存 q.next = null; // 7. 链表长度-1 --size; } /** 代码4： 判断删除位置是否合法 * @param index 删除位置 **/ private void rangeCheckForRemove(int index) { if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;删除位置不合法！&quot;); } } /** 代码5：打印顺序表。（同上，略）*/ } 主代码测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); // 删除第一个元素 linkedList.removeFirst(); linkedList.print(); // 在链表中间删除元素 linkedList.remove(3); linkedList.print(); // 删除最后一个元素 linkedList.removeLast(); linkedList.print(); } 插入删除算法的时间复杂度单链表的插入删除算法由两部分构成，第一是查找到第index个结点，第二是插入和删除结点。所以，如果我们不知道第index个结点的具体位置，链式存储与顺序存储的插入、删除算法都是O（n）。 连接算法若现已存在两个链表，需将这两个链表连起来。其中一个算法是直接将其中一个链表的末端接到另一个的首段，不再赘述。 另一个算法为：若已知链表的数据元素按值非递减有序排列，将两表归并为一个新的线性表, 且其中的数据元素仍按值非递减排列。 整体参考思路搜索：需要两个指针搜索两个链表；比较：比较结点数据域中数据的大小；插入：将两个结点中数据，小的结点插入新链表。 参考代码//创建方法Connection public static LinkedList&lt;Integer&gt; Connection(LinkedList&lt;Integer&gt; a, LinkedList&lt;Integer&gt; b){ LinkedList&lt;Integer&gt; c = new LinkedList&lt;&gt;(); //创建指针，并指向第一个结点 LinkedList&lt;Integer&gt;.Node pa=a.header.next; LinkedList&lt;Integer&gt;.Node pb=b.header.next; //比较指针指向结点大小，依次填入单链表c中，直至其中一个单链表全部录完 while (pa != null &amp;&amp; pb != null){ if (pa.data &gt;= pb.data){ c.addLast(pb.data); pb = pb.next; }else { c.addLast(pa.data); pa = pa.next; } } //将录完单链表的另一个依次录入 if (pa==null){ while(pb!=null){ c.addLast(pb.data); pb=pb.next; } }else if(pb==null){ while(pa!=null){ c.addLast(pa.data); pa=pa.next; } } //返回 return c; } 主函数测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedListA =new LinkedList&lt;&gt;(); linkedListA.addLast(3); linkedListA.addLast(5); linkedListA.addLast(8); linkedListA.addLast(11); linkedListA.print(); LinkedList&lt;Integer&gt; linkedListB =new LinkedList&lt;&gt;(); linkedListB.addLast(2); linkedListB.addLast(6); linkedListB.addLast(8); linkedListB.addLast(9); linkedListB.addLast(11); linkedListB.print(); LinkedList&lt;Integer&gt; linkedListC = new LinkedList&lt;&gt;(); linkedListC=Connection(linkedListA,linkedListB); linkedListC.print(); } 单链表应用一元多项式运算 关于其他链表与单链表类似，地址域有一定改变，其方法也同样有一定改变，这里不再赘述。（其实就是我懒。）","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（2）——线性表及其顺序储存结构和算法","slug":"数据结构笔记2","date":"2020-03-03T01:45:00.000Z","updated":"2020-03-14T10:44:51.428Z","comments":true,"path":"2020/03/03/数据结构笔记2/","link":"","permalink":"/2020/03/03/数据结构笔记2/","excerpt":"","text":"线性表的逻辑结构定义：数据元素之间的关系为一一对应的n个数据元素。 （a0，a1，…，ai-1，ai，ai+1，…，an-1）a0：线性起点ai-1：前趋ai+1：后继an-1：线性终点 均匀性：数据类型相同。有序性：不可交换次序。 内存地址：Loc(i)+L0+i×m（m：每个元素所占用的存储单元个数） 线性表的顺序存储结构及算法特点、优缺点 特点 数据连续存放、随机存取设备。 逻辑上和物理上相邻。 存储结构简单、易实现。 插入、删除操作不便。 存储密度大，空间利用率高。 优点 无需为表示表中元素之间的逻辑关系而增加存储空间。 可以快速取出表中的任一元素。 缺点 插入删除操作需要移动大量元素。 当线性表长度变化较大时难以确定空间容量。 ，需要预先分配空间，且容易造成存储空间的“碎片”。 适用：表中元素变动较少的情况，且拥有连续的存储空间。 插入算法思路1、判断插入位置是否合法。2、将第n-1至第i个元素后移一个存储位置。3、将要插入的x元素插入到ai-1之后。4、表长度+1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ public static class SequenceList&lt;E&gt;{ //用数组存储顺序表 private Object[] seqList; //顺序表的元素个数 private int size =0; //初始化顺序表 public SequenceList(){ seqList= new Object[1000]; } /** 定义：在顺序表中末尾添加元素函数 add(E element) * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(E element) { seqList[size] = element; ++size; return true; } /** 定义在顺序表某位置插入函数add(int index, E element) * @param index 插入位置 * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(int index, E element) { // 1. 判断插入是否合法 rangeCheckForAdd(index); // 2. 将存储在size-1位置至index位置的元素依次后移一个位置 for (int i = size; i &gt; index; --i) { seqList[i] = seqList[i - 1]; } // 3. 将x插入到index位置 seqList[index] = element; // 4. 表的长度+1 ++size; return true; } /** 定义插入位置是否合法函数 rangeCheckForAdd(int index) * @param index 插入位置*/ private void rangeCheckForAdd (int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(&quot;插入位置不合法！&quot;); } /** 定义打印顺序表函数 print ( ) * 打印顺序表*/ public void print( ) { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); for (int i = 0; i &lt; size; ++i) System.out.print(seqList[i] + &quot; &quot;); System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList=new SequenceList&lt;Integer&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.add(2); seqList.print( ); // 在1位置插入元素7 seqList.add(1, 7); seqList.print( ); } 时间复杂度在有n个元素的顺序表中，插入的位置有n+1个，并且是等可能的。O(n) 删除算法思路1、判别指定的位置是否合法2、若合法，则将位置i+1至n上的元素前移一个存储位置3、表的长度 -1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ /** 同上 **/ public static class SequenceList&lt;E&gt;{ private Object[] seqList; private int size =0; public SequenceList(){ seqList= new Object[1000]; } /** 定义删除指定位置的元素函数 remove(int index) * @param index 删除位置 */ public void remove(int index) { // 1. 判别指定的位置是否合法 rangeCheckForRemove(index); // 2. 将位置index+1 至 size-1 位置上的元素前移一个位置 for (int i = index+1; i &lt;= size - 1; ++i) { seqList[i-1] = seqList[i]; } // 3. 表的长度-1 --size; } /** 定义删除位置是否合法函数 rangeCheckForRemove(int index) * @param index 删除位置 */ private void rangeCheckForRemove (int index) { if (index &gt;= size || index &lt; 0) throw new IndexOutOfBoundsException (&quot;删除位置不合法！&quot;); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList = new SequenceList&lt;&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.print(); // 在1位置插入元素7 seqList.add(1, 7); seqList.print(); // 删除1位置元素 seqList.remove(1); seqList.print(); } 时间复杂度在有n个元素的顺序表中，可以删除的元素有n个，并且是等可能的。O(n)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"我和碧蓝航线","slug":"碧蓝航线1000天纪念","date":"2020-02-27T08:00:00.000Z","updated":"2020-03-07T13:26:01.797Z","comments":true,"path":"2020/02/27/碧蓝航线1000天纪念/","link":"","permalink":"/2020/02/27/碧蓝航线1000天纪念/","excerpt":"","text":"关于1000天当天那天相当震憾，有必要提一下。 不知道是疫情影响，还是因为正值毛子活动维护，当天就创了上线人数新高，所以这群在群里嘴上说冲的人一开服就把这游戏的服务器冲爆了，本来是下午3点开服，结果拖到了8点才基本解决问题，相当震憾。（人多可以理解，而且炸服补偿到位也就不说什么了） 一些想法其实如果不是这次惊喜和小加加在官博发文，都不知道这游戏已经1000天了，现在碧蓝航线在我taptap上的在线时间是最多的，1200多个小时，虽然大部分也只是在看后勤，打日常，但确实这游戏是我不舍得弃坑的游戏。 其实我实在舰b开服后两三天里在b站上的广告得知的，当时我对这游戏知之甚少，但是对于一名wows玩家，对二战的海军还是挺感兴趣的，并且看到游戏宣传里企业、拉菲和欧根的立绘，尤其是欧根亲王，就感觉这游戏的游戏资源有点东西胸有大痣，就想着下载来玩一下，就玩到今天了。 当时不知道为什么会对这三个角色有特别的偏好，直到现在业界有科学理论来证实这一现象了：“All Chinese love white hair” 因为我对于手游的态度一向是比较佛系的，而且当时我已步入准高三，所以当时并没有花太多时间在碧蓝航线上，即使我经历过第一次夏活，也对舰b并没有太多感受。所以即使游戏当时的口碑爆炸，我也没有什么亲身体会。 我当时脑子抽了，把装备回收箱和情人节礼物给用了，f**k（简洁有力的维多利亚方言） 开始认真对待这游戏的时候已经是高三寒假和下学期了（高三有什么寒假，别问为什么高三还有时间玩游戏），然后才意识到舰b在当时的手游范围内算是比较良心的了，而且碧蓝航线对自己的定位相当准确，高质量的皮肤，较低的抽卡成本，容易获得的高强度角色让人欲罢不能。她就像一个精打细算的商人，让自己赚钱的同时，让我们花钱的同时获得尽可能大的回报。 这live2d皮肤不香吗 碧蓝航线把“All Chinese love white hair”这一（伪）科学理论表现得淋漓尽致，从每年的人气投票就可以看出，这个梗在圈里过于有名，以至于传到了国外，这也可以看出碧蓝航线确实很懂得自己的定位。其实我对哪种立绘的偏爱是在碧蓝航线中才逐渐了解的，也让我真正对“画师”有了浅显的理解。就是喜欢黑兔的立绘 这游戏愿意肝也可以肝，愿意养老也可以，氪金和不氪金的玩家、肝帝和咸鱼玩家、研究党和娱乐党都可以玩的很高兴。 这游戏到后期本质就是一个聊天软件，一群人大多数时间在公屏里讨论除了碧蓝航线的各种话题，据说通过公屏还成了几对。每个人都可以在碧蓝航线里找到自己的老婆。（雾） 个人感觉，在碧蓝圈子里大多数人都是很和谐的，大家在群里吹吹水也十分和谐，这是我这些年来一直在玩碧蓝的原因之一，也让我认识到对海军感兴趣的大多数人是一群精苏玩家。除了第一次夏活难度的不合理，饺子的开火限制解除，某些皮肤过于xx而被举报外并没有什么大的节奏问题，也许这也正是成就碧蓝航线的原因之一。 对于皮肤，我觉得大多数的玩家反而希望这种皮肤越多与好，你还能对一个曾经适龄年龄13岁，之后提到了18+岁的游戏说什么吗。 结尾转眼间，这游戏已经1000天了，再过几个月就要三周年了，虽然因为各种原因国服难以与日服在本子那边的热度难以相比，但依然希望碧蓝在国内能够继续运营下去，毕竟这游戏确实不错。 最后，大舰队什么的。。。 国服玩家只能看本子的生放送获取最新消息，看美服玩家1周年在衣阿华战列舰上开127mm高平炮。 某些图不方便发，p站上搜一大堆。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"《数据结构》笔记（1）——绪论","slug":"数据结构笔记1","date":"2020-02-25T01:45:00.000Z","updated":"2020-03-08T09:02:51.362Z","comments":true,"path":"2020/02/25/数据结构笔记1/","link":"","permalink":"/2020/02/25/数据结构笔记1/","excerpt":"","text":"认识数据结构数值计算：利用数学方程。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;步骤：具体问题→数学模型→算法→编程、调试→得到答案 非数值计算：利用数据结构。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;步骤：问题→抽象出问题的模型→求模型的解&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;类型：线性结构（一对一）；非线性结构【树形结构（一对多）、图形结构（多对多）】&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（注：判断是否为线性结构优先画图，更直观。） 基本概念数据：对信息的一种符号表示。数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。数据项是数据的不可分割的最小单位。数据类型：性质相同的数据元素的组合。（注：数据由数据元素构成，数据元素由数据项构成。数据＞数据元素＞数据项） 数据结构：1、数学概念：S=（D，R）数据和关系的集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、内容概念：逻辑结构+存储结构+算法。（数据逻辑结构独立于计算机，存储结构依赖于计算机，运算定义依赖于逻辑结构，实现依赖于存储结构。） ADT——抽象数据类型，数据↔操作，ADT=（R,S,T）&ensp;&ensp;&ensp;&ensp;定义：1、使用视图：逻辑结构+操作集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、设计视图：存储结构+算法设计&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3、实现视图：成员变量+成员函数 逻辑结构 集合 线性结构 线性表 栈 队列 串级数组 非线性结构 树形结构 图形结构 存储结构 顺序存储方式：存储空间连续。 链式储存方式：存储空间不连续。 索引存储方式：索引表。 散列存储方式：哈希函数。 算法程序=算法+数据结构 定义：有穷规则的集合，规则确定一个解决某一特定类型问题的操作序列。 特征：输入、输出、确定性、有穷性、可行性。 原则：正确性、可读性、健壮性（容错处理）、效率与存储量的需求。 方式：自然语言、流程图、伪代码。 算法评价：时间复杂度——定性描述该算法的运行时间。常用大O符号表述，不包括这个函数的低阶项和首项系数。 程序设计实质：数据的表示和处理。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《决战中途岛》观后感","slug":"决战中途岛观后感","date":"2020-02-20T05:33:00.000Z","updated":"2020-03-09T01:01:18.116Z","comments":true,"path":"2020/02/20/决战中途岛观后感/","link":"","permalink":"/2020/02/20/决战中途岛观后感/","excerpt":"","text":"作为一个稍微对二战历史感兴趣的，并且入坑了舰c、舰b、wows、舰r（虽然在入坑舰c后退坑了）的人，有一部以二战时期的太平洋战场为背景的电影，无论电影好坏都是要看的，现在二战题材的电影又少之又少（毕竟市场小，不赚钱）。之前上映的时候找不到同圈子的人去看，趁着b站上映就去看了。对于自己来说，这是一部不错的电影。 剧情简介《决战中途岛》是由罗兰·艾默里奇执导由伍迪·哈里森、卢克·伊万斯、帕特里克·威尔森、曼迪·摩尔、艾德·斯克林、浅野忠信等主演的电影。 该片于2019年11月8日北美、中国内地同步上映。中途岛战役于1942年——日本偷袭美国珍珠港事件半年之后在南太平洋爆发，美国海军在中途岛环礁成功击退日本帝国海军舰队的攻击，获得了太平洋战区的主动权，这场战役被历史学家视为战争的转折点。 影片改编自1942年6月的中途岛战役，是整个太平洋战争的关键转折点，扭转了自珍珠港事件之后反法西斯盟军节节败退的局面。同时，这也是世界历史上著名“以小搏大”的战役之一，在海空军力大幅弱于日本的情况下，美军以沉没一艘航空母舰为代价，一举击沉日本主力航空母舰四艘、巡洋舰一艘。此次战役的胜利，彻底改变了反法西斯战争的格局，为二战胜利打下坚实的基础。 （摘自“百度百科”） 观后感这部分观后感极具主观色彩，且偏向肯定方向，在此说明。 bug作为一个有点了解那个时期历史的人，最喜欢的就是找bug。印象最深的就是联合舰队有5条大和。。 灭 国 舰 队 / 未 曾 设 想 的 道 路 / 震 撼 美 帝 / wows 10 级 房 现 状 其实还有其他的bug，比如珊瑚海代替太太（列克星敦）沉的是约克城。 约克城你好惨啊，在一部剧里沉了两次。 又或是主炮是鱼雷的驱逐舰。 但印象最深的还是麦克拉斯基发现本子舰队的名场面，这个梗估计这一年我都忘不了。 5艘大和你能把我秒了？ 毕竟经费有限可以理解，而且无伤大雅，所以就在这里调侃一番为止。 优点1、与《珍珠港》相比，这部电影里面没有谈恋爱！没有谈恋爱！没有谈恋爱！所有角色为剧情服务。 男人要看就看大舰巨炮，辣鸡三角恋。 2、难得的全景式、多方位记录一场二战的战争的电影，剧情流水账，主要场景在企业上，偏向于战争纪录片，估计没个5、6年是看不到下一部了，且看且珍惜。 3、国外二战电影中难得有中国内容的电影——空袭东京后，中国军民协助撤离杜立特编队成员，并且当时也因为掩护他们而牺牲了许多人。也可能是因为中国投资方投资比例最大。 不要在意那个微软黑体的牌坊。 4、电影中有些情节能使得对历史有一定了解的人感到亲切，比如美帝的铁棍雷，以及本子海军传统艺能——最大的敌人是陆军，还有企业上的牛排，等。 全剧唯二笑的地方就是美帝的铁棍雷，另一个就是五艘大和。 5、演员基本贴合史实，没有强加政治正确元素。 看到剧中的飞龙舰长山口多闻总感觉他们在打外星人。 6、作为中心的中途岛战役该表现的情节基本上表现到了，看得既惊险又刺激，比如vt8鱼雷编队的惨烈，贝斯特俯冲轰炸一发入魂赤诚的情节。 缺点1、由于主要讲述的是中途岛战役，要在两个小时左右既要展现主题，又要讲清前因后果是比较困难的，尤其在经费不足的情况下从珍珠港开始，所以在中途岛之前剧情跳转迅速，比如珊瑚海中列克星敦转眼就沉了，如果不是对历史有点认识的话可能会一脸懵b。好在中途岛之中表现不错。 2、同样是因为经费有限，在中途岛之前的特效有明显的不自然的情况，无法与其他大多数知名战争片相比。 3、由于是全景式、多方位的电影，部分角色的人物形象不太深刻。有些本应该是重要的剧情和人物也没有体现出来，比如中途岛一战成名的美方指挥官斯普鲁恩斯，在电影中只有最后的一个过场；“AF可能缺乏淡水”在中途岛战役中的著名电报，在电影中一笔带过。 其他1、剧中在企业上爬上飞机打偏本子神风的猛男——布鲁诺·盖多，在一天干翻两艘航母的俯冲轰炸的猛男——理查德·迪克·贝斯特，在中途岛拍纪录片，后来得了奥斯卡的的导演——约翰·福特，等，都是史实，比抗日神剧的剧情好的太多。 2、电影否定了“命运五分钟”的说法，还进行了调侃。 现在是令和，不是昭和了，大人，时代变了。 3、由于要增加观众的观看体验，电影中加强了本子的防空火力，历史中本子拉不出那样的防空火力网。 轮射的96神炮，昭和防空。 4、电影的剧本其实很早就基本完成，结果在美国没有投资人感兴趣，直到中方进行投资。（那可是你们父辈的荣光啊） 5、这部电影注定不会有高票房，资方亏钱情理之中，谁叫这个市场小呢。 总结对于对历史感兴趣的人来说，个人建议必看，其他的话也许需要稍微了解一下珍珠港、珊瑚海的相关情况，不然开始的一个小时可能会有点懵。不过对于想了解那一段历史，或者是因为感兴趣，或者单纯是要看“Lucky E”的人来说，都是一部个人推荐的，值得去看的电影。 顺便剧透一下：美帝赢了，本子输了。 为电影的工作人员点赞。 电影之外的东西1、我想起初中的时候自己还年少不懂事，认为本子当年就很傻，没事就偷袭美帝，既把德国拉下水，又给自己找了个爹。现在想起来真是惭愧不如。 2、中途岛都安排了，什么时候安排一下莱特湾？一战的日德兰也可以。 （但莱特湾估计不太可能，毕竟美帝方面指挥有失误。以塔菲三号为中心的倒有可能。） 3、还有，美帝战后把企业拆了，果然敌在国会山。（和“老女士”厌战一样，工党误国） 企业：我为国家流过血！我要见总统！ 之后企业当核航妈去了，厌战当死库水（潜艇）去了","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"电影","slug":"电影","permalink":"/tags/电影/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"关于方舟近况的看法","slug":"关于方舟近况的看法","date":"2020-01-22T11:42:00.000Z","updated":"2020-03-10T07:24:26.432Z","comments":true,"path":"2020/01/22/关于方舟近况的看法/","link":"","permalink":"/2020/01/22/关于方舟近况的看法/","excerpt":"","text":"新年池里我90发年和阿我都没出，稍微缓和情绪并且在看到网上的一些情况后，有感而发。比较严肃，所以没有图。 正文月卡党；是大学生，属于有点闲钱，也有点时间，真想要什么东西的时候也愿意氪金的开服玩家，属于氪金量少于一万的“白嫖玩家”。 其实对于大多数手游，我一向不会报以太大的期望，一是主要玩的还是pc，手游填补不方便玩pc的空档。二是环境如此，有多少创作者愿意以及能够与当前市面上的一些寡头厂商竞争呢，而那些在市面上的厂商所做的那些游戏质量有多好呢，毕竟手游精品化嘛。 不得不说，方舟出现在了一个十分好的时间点上。开服之前的周边和同人为游戏积攒了不小数量的玩家，为其他游戏的上线验证了一条新路，即使经过三测的经历，大多数玩家也愿意在一个月后继续玩，因为玩家看到了一个愿意听取玩家意见，并对游戏进行优化的yj。这对于不愿意再受到某些厂商“割韭菜”式的行为的我来说这个游戏是值得尝试的，更别提我还喜欢这游戏的玩法和立绘、ui的（毕竟塔防游戏我玩过的只有王城保卫战觉得还可以），三测后我也“失忆”了。而开服后游戏的口碑也可以证明大多数玩家对游戏是充满了期待的。 但yj毕竟不是其他的某些厂商，生产力的不足始终是一个缺陷，也是其他大多数问题的根源，如果不解决的话，随着刚开服时的热情的递减，是必定会在某一个时间点爆发的，尤其是对于一个唯一一款游戏就能拿下许多成就的新公司来说。树大招风，不知有多少其他厂商眼红和嫉妒。 诚然，游戏一开始存在许多问题，但之后的发展让玩家看到了改进的趋势，包括危机合约让玩家看到了新机制的可能，文案的改善也让玩家愿意耐心下来看剧情（如只出来两章的霜星的牺牲对玩家的震撼之大，当然方舟剧情挖坑多填坑少也是一个问题）。但生产力依然是个问题，长草期过长（都被调侃成植树节了），正逐渐消磨玩家的耐心。就像2019年手游收入一样，方舟的国内收入逐月下降，当然，对于一个氪金量曾超过农药的手游来说，这是正常现象，即使收入下降，但基本的依然很多。 “文案抄袭”（我觉得有人故意扩大问题），“立绘抄袭”（虽然感觉不算），“只过洋节”（这帽子扣的有点大）并没有对游戏整体口碑造成什么影响，这一方面是玩家整体对游戏是有好感的，二是对大多数玩家利益可能有损害（虽然有些现实，但大多数人毕竟不愿意自己喜爱玩的游戏厂商受到这些影响，进而影响到自己的游戏体验），即使是碎石上限开放，也只有一部分玩家抱怨。但一旦遇到影响大多数玩家利益的问题，就没有人愿意站出来维护游戏了（一部分人除外，那不是维护游戏声誉，那是给游戏招黑）。这次限定up就存在这个问题，排除跟风的大多数没抽到的人除了怪自己的运气不好之外，更愿意保持中立，吃瓜看戏，毕竟自己身上也有损失，抽到的人许多也不愿意出来发声，海豹的下场在任何游戏中都已体现，而且现在已经形成对立。所以和之前的问题爆发比起来，这次尤为严重，一旦有任何一个问题爆发，许多其他没有摆在明面上的问题同样也会爆发，游戏口碑也会受到影响。 我不清楚是不是要冲业绩；不知道也不想知道某些厂商是否有水军暗中操作；不知道策划是不是经验不足；不清楚是不是在试探玩家底线（个人更愿意相信最后一种，毕竟我还是挺喜欢这游戏的）。对于yj这种新兴公司来说，玩家口碑更为重要，而从玩家整体口碑来看，去年似乎运行的还不错，即使说不上很好，但也比大多数其他的好。（这就是个比烂的时代） 这次的问题也许有对现实妥协的因素，其实更让我关注的是之后的发展趋势，产能不足的问题看起来还得持续一段时间（毕竟春节活动就这样看着是有点凄凉，但是我还是乐观的相信是因为一些不可抗力），是否还会出这一类操作不得而知，玩家的好感经不起消磨，之后只能希望少一些操作，拿了个最佳游戏不算什么，国内游戏环境如此。 嘴臭部分我90发限定池子出的两了六星，一个小火龙一个陈晖洁，就出了一次新的五星，你说我六星9％的概率撞上了我也没的说，但我已经碎了石头和充了钱抽这池子，抽成这样我还敢再继续充钱吗 。我可没有太多的钱砸在这游戏里面，我也不只玩这游戏，有这钱我还不如去舰b买皮肤，人可不能在一棵树上吊死。三个新的皮肤也买了，之前很想要陈晖洁我也充了98买礼包，除此以外每个月买月卡的石头也存着买皮肤了，之前没抽到反正在池子里面不会跑。出限定的我也没有意见，要吃饭的可以理解，但具体体现在这样的池子上就有问题了，这也不能怪玩家有怨言。 无论是有多么正当的原因，也许是因为之前送的石头比较多影响了氪金量，即使本意不是“割韭菜”，这种池子给人感觉就是在“割韭菜”，为什么要把限定和非限定放在一起。其他游戏也许也有这样的，但别人要么抽卡成本低，要么是有资本，要么脸厚。刚开始我看到消息还以为自己看错了，如果方舟走最后一条路的话，开服时玩家越有好感，越有期待，之后黑起来越狠，尤其对于方舟有这么大的玩家数量。你说我脸黑我也认，抽不到自己想要的玩家或多或少都有怨言，但为何这次大多数人表示不满。 我之前也玩过千年战争，要不是那游戏太肝了我也不会弃坑。方舟只是国内市场缺乏塔防游戏，版号寒冬之后，世界观和立绘讨喜的情况下，非常适宜地推出的，拿个最佳游戏正常，毕竟TapTap上其他某些游戏玩家就是看不惯，而有的游戏也没有方舟这样被大多数玩家所知道，收入榜第一也没有什么，只是这游戏玩家觉得确实不错，也愿意氪金守护喜爱的游戏，这些还不算什么。国内环境就是这样，有什么办法，这就是所谓的游戏精品化。 林子大了什么鸟都有，有的玩家就是这样，有就赞美，没有就喷，这次的问题不正中了那些为黑而黑的人的下怀吗。也不能怪更多吃瓜看戏的人，毕竟这些人也有没抽到的，同样也有损失，只是在键盘上敲一敲是不可能改变与自己观点相背的人的观点的。之前还希望评分上9，现在只能期望不下8。 所以说有些人不知道哪出了点问题，什么“白嫖玩家是养活游戏厂商的关键人群”这种话也说得出来。在？脑子是个好东西，你也应该有一个。 还有些人不知道是生下来只玩过这一款游戏，还是集体有一个群，一起恰烂钱，不知道这是给游戏招黑吗。我也不知道为什么能在少前冬活前的直播的弹幕中看到吹方舟的，也不知道为什么舰b出个红色婚纱就说抄袭陈晖洁的旗袍的。你们就喜欢看方舟与其他游戏对立是吗。对于这些人我说一个在网上看到的比喻。 消费的人在商场里讨价还价很常见，也可以理解。有的商家愿意卖给他们，但经常让他们不要和其他人说，显而易见，其他人一听说了这件事也想搭顺风车，商家亏本卖东西还不如不卖。但有一天突然有一个对着讨价还价的人说:“你怎么能这样呢，人家商家不吃饭的？” 这种人要么精神不正常，要么他是店家的孙子（各种意义上的）。 算了，玩个游戏这么累干嘛，你们线下pvp高兴就好，我在里面找乐子不也挺好。 其他一点小小的建议，我并不像那些微博上的那些人要求的那样指望官方道歉，毕竟“承认的错误才是错误”，而且我更愿意相信有一些不可抗力的。希望根据玩家的一些反馈进行总结，不管是公司内部，又或是发展方向上进行一下调整，解决主要问题（我记着不是赚得挺多的吗，我知道流水和收入不是一个东西，但收入依然不小吧，找不到人，生产力提不上去？还是忙着弄国际服的事情，那也不能忘了国服吧），并在游戏内容及其之后的活动中让玩家感受到类似于剧情文案方面的比较明显的改善，又或者是危机合约gkd，我要让红刀哥、红锤哥和我比看谁死在切城废墟。我认为大多数玩家还是愿意继续玩下去的，但玩家的耐心是有限的。（也许根本轮不到我提建议） 感谢你能看到这里，无论是支持的，想喷我的，又或是找乐子，无所谓的，这只是一个还比较喜欢玩方舟的玩家的个人极其片面想法，只是提供一个角度而已。如果想法和意见与你的不同，并且觉得我说的话没有道理，请务必坚持自己的看法，我算什么，我还没有本事让你必须接受我的观点。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"谨此纪念霜星","slug":"谨此纪念霜星","date":"2019-12-25T01:58:00.000Z","updated":"2020-02-28T16:00:21.132Z","comments":true,"path":"2019/12/25/谨此纪念霜星/","link":"","permalink":"/2019/12/25/谨此纪念霜星/","excerpt":"","text":"“…等我们自由了，我们会放声大哭，在荒野里在雪地里，在堆得满满的麦垛里放声大哭” 圣诞节的礼物？？想起其他的牺牲的干员（Ace、Scout）。。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"Hello World","slug":"Hello World","date":"2019-12-09T09:50:00.000Z","updated":"2020-01-31T13:33:03.773Z","comments":true,"path":"2019/12/09/Hello World/","link":"","permalink":"/2019/12/09/Hello World/","excerpt":"","text":"某种意义上的“First Post”，总结了建站时hexo自带的《Hello World》和主题Sakura的使用文档。 关于hexo关于hexo更多的信息可以查看官网的使用文档，使用中存在的问题可以在troubleshooting查找，或者在GitHub上提问。 创建$ hexo new &quot;My New Post&quot; More info: Writing 启动服务器$ hexo server More info: Server 生成文件$ hexo generate More info: Generating 发布$ hexo deploy More info: Deployment 清理清理本地文件，防止修改部分文件后出现错误。 $ hexo clean 本地调试$ hexo clean &amp;&amp; hexo s 上传服务器$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 关于Sakura主题hexo-theme-sakura主题基于WordPress主题Sakura修改成Hexo的主题。 详细使用方法查看使用文档。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}