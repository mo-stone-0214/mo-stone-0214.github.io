{"meta":{"title":"MoStone","subtitle":"我们，依旧在路上。","description":null,"author":"Mo_Stone","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-01-31T03:09:53.290Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[MoStone] 与&nbsp; MoStone&nbsp; （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-01-28T13:27:29.579Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-01-28T13:14:31.136Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"本主题基于Hexo主题Sakura修改,感谢作者hojun。Hexo版修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-08-28T14:06:15.196Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"other","date":"2019-02-10T13:32:48.000Z","updated":"2020-08-18T03:05:29.265Z","comments":false,"path":"other/index.html","permalink":"/other/index.html","excerpt":"","text":"","keywords":null},{"title":"","date":"2020-01-14T12:56:52.901Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/package.json","permalink":"/lib/reading_progress/package.json","excerpt":"","text":"{\"name\":\"theme-next-reading-progress\",\"version\":\"1.2.0\",\"description\":\"Reading Progress for NexT\",\"main\":\"reading_progress.js\",\"scripts\":{\"uglify\":\"uglifyjs --compress --mangle -o reading_progress.min.js -- reading_progress.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-reading-progress.git\"},\"author\":\"theme-next\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-reading-progress/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-reading-progress#readme\",\"dependencies\":{\"uglify-js\":\"^3.3.9\"}}"},{"title":"","date":"2020-01-14T12:56:52.905Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.min.js","permalink":"/lib/reading_progress/reading_progress.min.js","excerpt":"","text":"!function(){var e=$(\".reading-progress-bar\");if(e.length){var n=!1;try{var t=Object.defineProperty({},\"passive\",{get:function(){n=!0}});window.addEventListener(\"test\",$.noop,t),window.removeEventListener(\"test\",$.noop)}catch(e){}var i=$(window),o=$(document);o.ready(function(){window.addEventListener(\"scroll\",function(){var n=i.height(),t=o.height(),r=i.scrollTop()/(t-n)*100;r=r>100?100:r"},{"title":"","date":"2020-01-14T12:56:52.910Z","updated":"2019-12-13T04:47:50.084Z","comments":true,"path":"lib/reading_progress/renovate.json","permalink":"/lib/reading_progress/renovate.json","excerpt":"","text":"{\"extends\":[\"config:base\"]}"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-10-12T13:56:38.819Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"","date":"2020-01-14T12:56:52.903Z","updated":"2019-12-13T04:47:50.083Z","comments":true,"path":"lib/reading_progress/reading_progress.js","permalink":"/lib/reading_progress/reading_progress.js","excerpt":"","text":";(function() { var $bar = $('.reading-progress-bar') if (!$bar.length) return //no progress bar found var supportsPassive = false try { var opts = Object.defineProperty({}, 'passive', { get: function() { supportsPassive = true } }) window.addEventListener('test', $.noop, opts) window.removeEventListener('test', $.noop) } catch (e) {} var $w = $(window) var $d = $(document) $d.ready(function() { window.addEventListener( 'scroll', function() { var wh = $w.height() var dh = $d.height() var st = $w.scrollTop() var percent = (st / (dh - wh)) * 100 percent = percent > 100 ? 100 : percent < 0 ? 0 : percent $bar.css('width', percent + '%') }, supportsPassive ? { passive: true } : false ) }) })()"},{"title":"","date":"2020-01-14T12:56:52.907Z","updated":"2019-12-13T04:47:50.081Z","comments":true,"path":"lib/reading_progress/README.html","permalink":"/lib/reading_progress/README.html","excerpt":"","text":"Reading Progress for NexT Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: $ cd themes/next $ ls bower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: $ git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress Step 3 &rarr; Set it up Enable module in NexT _config.yml file: reading_progress: enable: true color: &quot;#37c6c0&quot; height: 2px And, if you wants to use the CDN, then need to set: vendors: ... reading_progress: //cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js Update $ cd themes/next/source/lib/reading_progress $ git pull"}],"posts":[{"title":"《数据结构》笔记（续）——尝试&Test代码","slug":"数据结构笔记12","date":"2020-06-26T01:45:00.000Z","updated":"2020-09-07T02:53:38.205Z","comments":true,"path":"2020/06/26/数据结构笔记12/","link":"","permalink":"/2020/06/26/数据结构笔记12/","excerpt":"","text":"这是数据结构课程的实验，里面会有会有很多不成熟的错误。 其实只是写了这么多找个地方存而已。 https://github.com/mo-stone-0214/blog_source/tree/master/Data%20%20Structure_Java 如果不介意中文的问题的话：https://cdn.jsdelivr.net/gh/mo-stone-0214/blog_source@1.1.1/Data%20%20Structure_Java 测试用 二叉排列树 双链表 中缀表达式转后缀表达式、中缀和后缀表达式的运算 哈夫曼树 单链表转置 队列 排序：直接插入、希尔、冒泡、快速、直接选择、堆、归并排序 矩阵乘法 顺序表 单链表 栈：用数组创建 栈：用链表创建 栈的应用：判断回文 用数组和链表创建二叉树 二叉树的先序、中序、后序递归遍历 二叉树的先序、中序、后序、层次非递归遍历 实验课 实验课：队列 实验课：单链表和顺序表的查找 实验课：直接插入、直接选择、冒泡排序 实验课：栈的操作、中缀表达式转后缀表达式以及计算 实验课：二叉树的先序、中序、后序递归遍历 实验课：二叉树的先序、中序、后序非递归遍历","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（11）——图","slug":"数据结构笔记11","date":"2020-06-12T01:45:00.000Z","updated":"2020-06-25T09:28:13.234Z","comments":true,"path":"2020/06/12/数据结构笔记11/","link":"","permalink":"/2020/06/12/数据结构笔记11/","excerpt":"","text":"概念 定义 图是一种较之线性表和树形结构更为复杂的非线性数据结构。图中各数据元素之间的关系可以是任意的，描述的是“多对多”的关系。 图是由顶点集合 (Vertex) 及顶点间的关系（边：Edge）集合组成的一种数据结构：Graph＝( V , E )其中 V 是顶点的有穷非空集合； E 是顶点之间关系的有穷集合，也叫做边(Edge)集合。 分类 无向图：图G中顶点的偶对是无向的，其偶对用（Vx，Vy）表示。有向图：图G中顶点的偶对是有向的。其偶对用 &lt;Vx,Vy&gt; 表示。 相关概念 顶点（Vertex）:图中的数据元素（结点）称为顶点。 邻接点无向图中，若边（Ｖx，Ｖy）∈ E， 则Ｖx、Ｖy互为邻接点。有向图中，若弧〈Ｖx，Ｖy〉 ∈ E， 则Ｖy是Ｖx的邻接点，反之，不是。 边（Edge）:顶点间的关系可描述为顶点的偶对，也称为顶点的边。记为:(Vx，Vy）。边是无序的，与(Vy，Vx）含义相同。 弧（Arc）:若顶点间的边是有方向性（有序）的，则称该偶对为弧。记为：〈Vx，Vy〉。弧是有序的，〈Vx，Vy〉表示从Vx到Vy。 弧头：弧的终点称为弧头（方向前方）。 弧尾：弧的起始点称为弧尾（方向后方）。 度：无向图中，顶点的度是以该顶点为一个端点的边的条数。有向图中，以某顶点为弧头的弧的数目称为该顶点的入度。以某顶点为弧尾的弧的数目称为该顶点的出度。该顶点的度=入度+出度。 路径：在图 G＝( V,E ) 中, 若存在一个顶点序列 v p1,v p2 , …,v pm ，使得(vi,v p1)、(v p1,v p2)、…、(v pm,vj)均属于 E， 则称顶点 vi 到 vj 存在一条路径。若一条路径上除了 vi 和 vj 可以相同外，其余顶点均不相同，则称此路径为一条简单路径。起点和终点相同的路径称为回路或环。 完全图：在无向图中任何两个顶点都存在一条边。n个顶点的完全无向图拥有 [n(n+1)]/2 条边，有向图为 n(n+1) 。 连通顶点：在无向图中,顶点A和顶点B间存在一条路径,则称顶点A和顶点B为连通顶点。 连通图：在无向图中，若每一对顶点间都有路径，称此图是连通图。 连通单元：将无向图分成多个分离的子图后,原图形的连通点仍在同一个子图中。 根据连通分量的定义，可知任何连通图的连通分量是其自身，非连通的无向图有多个连通分量。 强连通图：在有向图中，若每对顶点Vx到Vy间都存在Vx到Vy，及从Vy到Vx的路径，则称此图是强连通图。 强连通单元：将有向图分为多个分离的子图后,原图形的连通顶点仍在同一个子图中。 强连通图的唯一强连通分量是其自身，而非强连通的有向图有多个强连单元。 有n个顶点的连通无向图最多有[n(n-1)]/2条边，最少有 n-1 条边，可构成一棵树。有n个顶点的强连通图最多有 n(n-1)条边，最少有 n 条边，可构成一个环。 权：若图的边或弧带有与之相关的数，称此数为该边或弧的权。权通常用来表示从一个顶点到另一个顶点的距离或费用。 网：带权的图称为网。 存储 特点 邻接矩阵存储：第i个矩阵中结点数目为顶点i的度。无向图中，所有矩阵中结点数目的一半为图中边数。 邻接表存储：第i个链表中结点数目为顶点i的出度。有向图中，所有链表中结点数目为图中弧数。 优点 邻接矩阵存储：优点：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。缺点：n个顶点需要n*n个单元存储边(弧);空间效率为O(n^2)。对稀疏图而言尤其浪费空间。 邻接表存储：优点：空间效率高；容易寻找顶点的邻接点；缺点 ：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。 邻接矩阵存储有向图、无向图定义： 有向图邻接矩阵 设图G=（V，E）是有n（n ≥ 1）个顶点的图，则G的邻接矩阵是具有下述性质的 n x n 的方阵，元素为： 无向图邻接矩阵 与有向图邻接矩阵类似。 例子 有向图的邻接矩阵结论： 矩阵不一定是对称的。 第 i 行中1的个数为顶点 i 的出度。 第 i 列中1的个数为顶点 i 的入度。 矩阵中1的个数为图中弧的数目。 很容易判断顶点 i 和顶点 j 是否有弧相连。 无向图的邻接矩阵结论： 矩阵是对称的，可压缩存储（上/下三角）。 第 i 行或第 i 列中1的个数为顶点 i 的度。 矩阵中1的个数的一半为图中边的数目。 很容易判断顶点 i 和顶点 j 之间是否有边相连(看矩阵中i行j列值是否为1)。 网 邻接表存储无向图： 有向图： 网： 遍历从图中指定顶点出发访问图中每一个顶点，且使每个顶点只被访问一次，该过程为图的遍历。 深度优先搜索法DFS（Depth First Search） 从图中某个顶点V0出发，并访问此顶点； 从V0出发，访问与V0邻接的顶点V1后，再从V1出发，访问与V1邻接且未被访问过的顶点V2。重复上述过程，直到不存在未访问过的邻接点为止。 如果是连通图，从任一顶点V0出发，就可以遍历所有相邻接的顶点；如果是非连通图，则再选择一个未被访问过的顶点作为出发点，重复step1、step2，直到全部被访问过的邻接点都被访问为止。 简单来说，DFS一条路走到底，走到底之后逐步回退至未走的另一条路的分叉结点，走另一条路，直至最终返回起点，并且所有节点都已遍历。 深度优先搜索法类似于树的先根遍历法。 例： 链接表例：（叉表示已遍历的结点） 广度优先搜索法BFS（Breadth First Search） 从图中某个顶点V1出发，并访问此顶点。 从V1出发，访问V1的各个未曾访问的邻接点V2，V3，…,Vk;然后,依此从V2,V3,…,Vk出发访问各自未被访问的邻接点。 重复step2，直到全部顶点都被访问为止。 广度优先搜索法类似于树的层次遍历法。 例： 链接表例：此处仅将链表有数据的第一行遍历完毕的情景，此后按照队列的“先进先出”的特点，取出并查找V2的链接表，此处V1已遍历，跳过并将之后的V4，V5按顺序加入队列，V2结点遍历结束，取出并查找V3的链接表，以此类推，直至所有节点都已遍历。 应用最小生成树定义连通图G的一个子图如果是一棵包含G的所有顶点的树，则该子图称为G的生成树。生成树各边的权值总和称为生成树的权。权最小的生成树称为最小生成树。 生成树是连通图的极小连通子图。所谓极小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。 该问题是构造连通图的最小代价生成树问题。一棵生成树的代价就是树上各边（弧）的代价之和。 实现方法普里姆（Prim）算法思想：假设N=（V，E）是连通图，TE是N上最小生成树中边的集合。 从U={u0} （u0∈V），TE=空 开始。 重复执行：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0,v0）并入TE，同时u0 并入U，直到U=V为止； 此时TE中必有n-1条边，则T=（V，TE）为N的最小生成树。 个人理解：将已连接的结点看成一个整体，选取该整体与其他散的结点权值最小的路径连接。 例： 鲁斯卡尔（Kruskal）算法思想：假设N=（V，E）是连通图 取图中每个顶点自成一个连通分量。 在{ E }中选择代价最小的边，若该边所依附的顶点落在T中不同的连通分量上，则将此边加入生成树T中；否则，舍去此边，再选择下一条代价最小的边。 重复上述步，直到T中所有顶点都在同一连通分量上为止。 个人理解：始终找最短路径，除非该路径能使树形成回路。 例： 最短路径单源最短路径（Dijkstra算法）思路： 首先求出长度最短的一条路径； 再参照它求出长度次短的一条路径； 依次类推，直到从顶点v到其它顶点的最短路径全部求出为止。 例子： 每对顶点间的最短路径（Floyd算法）转：Floyd算法(三)之 Java详解 拓扑排序方法步骤： 在有向图中选一个没有前驱的顶点并输出; 从图中删除该顶点和所有以它为尾的弧; 重复前2步,直到全部顶点均输出为止。 输出序列即为拓扑排序序列。 拓扑排序序列不唯一。 转：拓扑排序详解与实现","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（10）——查找","slug":"数据结构笔记10","date":"2020-05-30T01:45:00.000Z","updated":"2020-07-06T04:03:19.918Z","comments":true,"path":"2020/05/30/数据结构笔记10/","link":"","permalink":"/2020/05/30/数据结构笔记10/","excerpt":"","text":"基本概念 关键码 数据元素或纪录中的某个数据项的值，用它可以标识一个数据元素或纪录。 查找 在一个给定的数据结构中，根据给定的条件查找满足条件的结点。 查找方法 静态查找：顺序查找、折半查找、分块查找、费氏查找、插补查找动态查找：散列查找、树型查找 查找方法评价 查找速度占用存储空间算法本身复杂程度平均查找长度ASL(Average Search Length)：为确定记录在表中的位置，需和给定值进行比较的关键字的个数的期望值叫查找算法的ASL。 静态查找部分静态查找算法比较 顺序查找查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较。 参考代码注：只能返回首个与指定关键字相符的关键字位置。 /** * 在顺序表中查找指定元素 * * @param list 给定顺序表 * @param key 查找关键字 * @return 查找成功返回指定位置，否则返回 -1 */ public static int seqSearch(int[] list, int key) { for (int i = 0; i &lt; list.length; ++i) { if (list[i] == key) { return i; } } return -1; } ` 算法分析ASL： 优点：算法简单，无需排序，采用顺序和链式存储均可。 缺点：平均查找长度较大，更加费时。 折半查找（二分查找）算法思想和前提 算法思想 先确定待查找记录所在的范围，然后逐步缩小范围，直到找到或确认找不到该记录为止。 前提 必须在具有顺序存储结构的有序表中进行。 算法演示分三种情况： 若中间项的值等于x,则说明已查到。 若x小于中间项的值，则在线性表的前半部分查找。 若x大于中间项的值，则在线性表的后半部分查找。 成功找到的例子： 未成功找到的例子： 参考代码注：只能返回首个与指定关键字相符的关键字位置。 /* * @param list 已经排序好的顺序表 * @param key 查找关键字 * @return 查找成功返回指定位置，否则返回 -1 */ public static int binarySearch(int[] list, int key) { int begin = 0, end = list.length - 1, mid; while (begin &lt;= end) { mid = (begin + end) / 2;//mid向下取整 if (list[mid] == key) { return mid; }else if (key &lt; list[mid]) { end = mid-1 ; }else { begin = mid+1 ; } } return -1; } ` 算法分析如果把当前查找位置上的结点作为根，左子表和右子表的结点分别作为根的左子树和右子树，由此得到的二叉树称为描述折半查找的判定树。 借助于判定树很容易求得折半查找的平均查找长度。 设结点总数为n，其高度为k，那么 2^(k-1)-1 &lt; n ≤ 2^k -1 折半查找的算法复杂度为：log2 nASL = 各个结点层数的平均数（以图中为例：(ASL = （1+2×2+3×4+4×4）/11=3 ） 即在最坏情况下，折半查找方法查找成功的比较次数不超过判定树的高度。 虽然折半查找的效率较高，但它要求被查找序列事先按关键字排好序，而排序本身是一种很费时的运算；另外，折半查找只适用于顺序存储结构。 因此，折半查找特别适用于那种一经建立就很少改动、而又需要经常查找的线性表。 分块查找算法思想首先，查找索引表，因为索引表是有序表，故可采用二分查找，也可以采用线性查找，以确定待查的结点在哪一块；然后在以确定的那一块中顺序查找。 适用条件分块有序表 算法演示 参考代码默认给定顺序表、索引表、块地址表。 /** * @param indexTable 索引表 * @param seqList 已经分好块的顺序表 * @param addressTable 块地址表 * @param key 查找关键字 * @return 查找成功返回指定位置，否则返回 -1 */ public static int blkSearch(int[] indexTable, int[] seqList, int[] addressTable, int key) { // 首先通过折半查找找到所在块的起始地址 int begin = 0, end = indexTable.length - 1, mid; while (begin &lt;= end) { mid = (begin + end) / 2; if (key &lt;= indexTable[mid]) { end = mid - 1; } else { begin = mid + 1; } } // 查找完毕，begin为所在块，然后进行顺序查找 int seqSearchEnd; // 如果所在块为最后一块 if (begin == indexTable.length - 1) { seqSearchEnd = seqList.length; } else { seqSearchEnd = addressTable[begin + 1]; } for (int i = addressTable[begin]; i &lt; seqSearchEnd; ++i) { if (key == seqList[i]) { return i; } } return -1; } `` 算法评价若将表长为 n 的表平均分成 b 块，每块含有 s 个记录，设表中每个记录的查找概率相等，则： 动态查找——散列查找基本思想和目标基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。 目标：提高查找效率，即缩短查表和填表的时间。 相关概念散列函数在记录的关键字与记录的存储地址之间建立的一种对应关系叫散列函数。 散列函数是一种映象，是从关键字空间到存储地址空间的一种映象，可写成：addr(ai)=H(ki) ➢ ai是表中的一个元素➢ addr(ai)是ai的存储地址➢ ki是ai的关键字 例子： 冲突和同义词散列函数只是一种映象，所以散列函数的设定很灵活，只要使任何关键字的散列函数值都落在表长允许的范围之内即可 冲突：key1 ≠ key2，但H(key1) = H(key2)的现象叫冲突。 同义词：具有相同函数值的两个关键字，叫该散列函数的同义词。 散列函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；同时，冲突发生后，应该有处理冲突的方法。 散列函数的构造方法散列法查找必须解决如下两个问题： 选择一个计算简单且冲突尽量少的“均匀的”散列函数。确定一个解决冲突的方法，即寻求一种方法存储产生冲突的的同义词。 包括：除留余数法、数值抽出法、平方取中法、折叠法、旋转法、伪随机数法 数值抽出法 将数据的关键值中的某几位数值取出后，作为数据存储的位置。 例：数据的关键值为一组6位数的号码。我们假设关键值中的第1位、第2位、第5位作为数据位置的索引值，则：136781=&gt;138215484=&gt;218021157=&gt;025 平方取中法 将数据的关键值中的前几位数取出后平方产生一个新的数值，再从新产生的数值中取出中间的某几位作为数据存储的位置。 例：决定以数据的关键值的前3位，平方后产生一个新的数值，再从新的数值中取第2位到第4位作为数据位置的索引值。325483=&gt;325×325=105625=&gt;056213457=&gt;213×213=045369=&gt;453654875=&gt;654×654=427716=&gt;277 折叠法 将数据的关键值中分为多层，然后相加后取其结果作为数据存储的位置。 例:关键值为123456789，将关键值分成三层后，运算后的结果如下：&nbsp;&nbsp;123&nbsp;&nbsp;456+789——1368最后，我们取368为数据存储的位置。 处理冲突的方法开放定址法线性探测法 思想 将散列表看成是一个环形表。若地址为d（即H(key)=d）的单元发生冲突，则依次探查下述地址单元：d+1，d+2，……，m-1，0，1，……，d-1直到找到一个空单元或查找到关键字为key的结点为止。当然，若沿着该探查序列查找一遍之后，又回到了地址d，则无论是做插入操作还是做查找操作，都意味着失败。 例子 表长为11的哈希表中已填有关键字为17，60，29的纪录，H(key)=key MOD 11,现有第4个记录，其关键字为38，按线性探测法，将它填入表中。 二次方探索法 思想 当散列函数产生的数据地址已有数据存在时，以现在的数据地址加上冲突次数的平方，当数据地址超出数组大小时，则让数据地址采用循环的方式处理。 例子 假设第一次发生散列冲突的位置在1，数组的大小为80，其运作方式为： 双哈希函数法 思想 这个方法使用两个散列函数 H1 和 H2 ，若 H1 (key)=d 时发生冲突，则再计算 H2 (key)，得到的探查序列为：(d+H2 (key))%m，(d+2 H2 (key))%m ，(d+3 H2 (key))%m ，… 例子 已知一组关键字(19,14,23,1,68,20,84)。哈希函数H(key)=key MOD 13, 哈希表长为 m=16，ReH(key)=int(key+3)MOD 7，用双哈希函数处理冲突。 差值解决法 思想 当发生杂凑碰撞时，以现在的数据地址加上一个固定的差值，当数据地址超出数组大小时，则让数据地址采用循环的方式处理。 例子 假设现有数据（23 57 65 63 67 33），采用除留余数法hash(k)=k%10，数组大小为10，差值为3。试插入这些数据。产生冲突数据以33为例：33%10 = 3（已插入23），（33+3）%10 = 6（已插入63），（33+6）%10 = 9 链地址法 思想 将同义词结点拉成一个链表，将各链表的投指针按杂凑函数计算出来的地址顺序组织在相应的指针数组中。 例子 关键字(19,14,23,1,68,20,84,27,55,11,10,79)，通过链表解决方法，将其插入对应的位置。 分桶杂凑法 思想 建立两个表：一个基本表，每个单元只能存放一个元素；另一个是溢出表，将产生冲突的值放入该表。 动态查找——树型查找二叉排列树，B树","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（9）——排序","slug":"数据结构笔记9","date":"2020-05-19T01:45:00.000Z","updated":"2020-06-16T11:41:48.122Z","comments":true,"path":"2020/05/19/数据结构笔记9/","link":"","permalink":"/2020/05/19/数据结构笔记9/","excerpt":"","text":"在学习过程中，断断续续写了一个月。 基本概念 排序 将一组杂乱无章的数据按一定的规律排列起来（递增或递减）。 排序的分类(按待排序涉及的存储器不同) 内排序：待排序记录存放在内存外排序：排序过程中需对外存进行访问。 排序的分类(按排序依据的原则) 插入排序：直接插入排序、希尔排序。交换排序：冒泡排序、快速排序。选择排序：直接选择排序、堆排序。归并排序：2-路归并排序。基数排序。 排序的特性 关键字相同的记录在排序过程中是否保持前后次序不变。注：以下例子中数据“2”没有任何区别，只是在此对其先后顺序进行标记。关于判别是否是稳定排序的方法：如果算法中关键字是依次比较的，那么几乎可以确定这个排序是稳定的。 排序的基本操作 1、比较两个关键字大小2、将记录从一个位置移动到另一个位置 排序的时间开销 是衡量算法好坏的最重要的标志。通常用算法执行中的关键字比较次数和关键字移动次数来衡量。 选取排序方法时需要考虑的因素 待排序的记录数目 记录本身信息量的大小 关键字的结构及其分布情况 对排序稳定性的要求 语言工具的条件、辅助空间的大小 排序算法均以升序为例。 插入排序每步将一个待排序的对象，按其关键字大小，插入到前面已经排好序的一组对象适当位置上，直到对象全部插入为止。 直接插入排序此方法为稳定排序。 思想插入第i个对象时，前面的V[0],V[1], …,V[i-1]已排好序，此时，用v[i]的关键字与V[i-1], V[i-2],…的关键字顺序进行比较，找到插入位置即将V[i]插入，原来位置上对象向后顺移。 示例 希尔排序(缩小增量排序)此方法为不稳定排序。 思想先取一个正整数 d1 &lt; n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2 &lt; d1，重复上述分组和排序操作；直至di=1，即将所有记录放进一个组中排序为止。 当d = 1 是与直接插入排序相同，但由于之前关键字较小的记录已跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序，所以能够节省运算时间。 示例 参考代码/** * 直接插入算法（升序） * @param arr 需要排序的int数组 * @return 排好序的int数组 */ public static int[] insertSort(int[] arr){ //如果数组中没有或只有一个元素，无需排序，直接返回。 if (arr.length == 0 || arr.length == 1) return arr; int j; //从数组中位置为1的数据开始，循环至最后一个 for (int i = 1 ; i&lt;arr.length ; i++){ //储存当前所选数据 int theNum = arr[i]; //从当前数据往前读取，依次向后移动并判断，直至循环完毕或遇到比其更小的数据，储存当前位置j for (j = i-1 ; j&gt;=0 ; j--){ arr[j+1] = arr[j]; if (arr[j]&lt;theNum)break; } //将数据输入至j位置 arr[j+1] = theNum; } //返回已排好序的数组 return arr; } /** * 希尔算法（升序） * @param arr 需要排序的int数组 * @return 排好序的int数组 */ public static int[] shellSort(int[] arr){ //如果数组中没有或只有一个元素，无需排序，直接返回。 if (arr.length == 0 || arr.length == 1) return arr; int n; //将步长n取为当前数组长度一半，向下取整，之后依次循环/2，直至n=1 for(n = (int)(Math.floor(arr.length / 2));n&gt;=1;n = (int)(Math.floor(n / 2))){ //与直接插入排序类似，只是步长从1改为n for(int i = n ; i &lt; arr.length ; i+=n){ int theNum = arr[i]; int j; for (j = i-n ; j &gt;= 0 ; j-=n){ arr[j+n] = arr[j]; if (theNum&gt;arr[j]) break; } arr[j+n]= theNum; } } //返回已排好序的数组 return arr; } /** * 输出用 * @param arr int数组 */ public static void print(int[] arr) { // TODO Auto-generated method stub if(arr == null)System.out.println(&quot;列表为null&quot;); System.out.print(&quot;[&quot;); for (int i = 0 ; i &lt; arr.length ; i++){ if(i == arr.length -1 ) { System.out.println(arr[i]+&quot;]&quot;); break; } System.out.print(arr[i]+&quot;,&quot;); } } ` 测试主函数public static void main(String[] args){ int[] arr = {1,3,6,4,2,5,0,7}; System.out.print(&quot;排序前：&quot;); print(arr); System.out.println(&quot;排序后：&quot;); print(insertSort(arr)); print(shellSort(arr)); } `` 结果排序前：[1,3,6,4,2,5,0,7] 排序后： [0,1,2,3,4,5,6,7] [0,1,2,3,4,5,6,7] ` 复杂度分析一、空间复杂度： 只需要一个记录的辅助空间。 二、时间复杂度： 直接插入排序 希尔排序 平均比较次数和对象平均移动次数在 n^1.25 与 1.6*n^1.25 之间。 交换排序两两比较待排序的对象的关键字，如果发生逆序，则交换之，直到全部对象都排好序为止。 冒泡排序此方法为稳定排序。 思想 将第一个记录的关键字与第二个记录的关键字进行比较，若为逆序r[1].key&gt;r[2].key，则交换；然后比较第二个记录与第三个记录；依次类推，直至第n-1个记录和第n个记录比较为止。此时为第一趟冒泡排序，结果关键字最大的记录被安置在最后一个记录上。 对前n-1个记录进行第二趟冒泡排序，结果使关键字次大的记录被安置在第n-1个记录位置。 重复上述过程，直到“在一趟排序过程中没有进行过交换记录的操作”为止。 示例 快速排序此方法为不稳定排序。 若基准值比重复的关键字大的时候，后面的数据会移动到前面，因而该排序方法不稳定。 思想通过一趟排序将待排序列分成两部分，使其中一部分记录的关键字均比另一部分小，再分别对这两部分排序，以达到整个序列有序。 示例 参考代码/** * 冒泡排序，升序 * @param arr 需排列的int数组 * @return 已排列的int数组 */ public static int[] bubbleSort(int[] arr){ if (arr.length == 0 || arr.length == 1) return arr; int j,midNum; //添加一个判定是否交换的标志，如果在循环过程中某一次循环的所有元素没有交换，则说明已经排好序，并且可以提前结束循环 boolean isExchange; for (int i = 0 ; i&lt;arr.length-1 ; i++){ isExchange=false; for ( j=0 ; j &lt; arr.length-1-i; j++){ if (arr[j]&gt;arr[j+1]){ midNum = arr[j+1]; arr[j+1] = arr [j]; arr[j] = midNum; isExchange = true; } } if(!isExchange) break; } midNum = -1; return arr; } /** * 快速排序，递归，升序 * @param arr 所需排序的数组(需保证输入符合规范) * @param start 开始位置 * @param end 结束位置 * @return 已部分或完全排好序的数组 */ public static int[] quickSort(int[] arr , int start , int end){ //如果起始位置和终止位置相同，直接返回 if(start == end) return arr ; //如果满足开始位置和结束位置在0~数组长度-1的返回内，并且开始位置小于结束位置时 if(start&lt;end &amp;&amp; start&gt;=0 &amp;&amp; start&lt;=arr.length-1 &amp;&amp; end&gt;=0 &amp;&amp; end&lt;=arr.length-1){ //创建首尾指针 int i = start; int j = end; //取出基准值 int theNum = arr[i]; //循环至首尾指针相等 while(i!=j){ //首指针不动，尾指针循环从右往左寻找比基准值小的数据，并将尾指针所指数据赋予首指针所指位置 while(i&lt;j &amp;&amp; arr[j]&gt;=theNum) j-=1; if(i&lt;j) {arr[i]=arr[j];i+=1;} //尾指针不动，首指针循环从左往右寻找比基准值大的数据，并将首指针所指数据赋予尾指针所指位置 while(i&lt;j &amp;&amp; arr[i]&lt;=theNum) i+=1; if(i&lt;j) {arr[j]=arr[i];j-=1;} } //此时首尾指针相等，将基准值赋予该位置 arr[i] = theNum; //递归运算 quickSort(arr,start,i-1); quickSort(arr,i+1,end); } //返回部分或完全已排序好的数组 return arr; } ``` 复杂度分析 冒泡排序 总共要进行 n-1 趟，对 i 个记录的表进行一趟冒泡需要 i-1 次关键码比较，所以： 快速排序 时间复杂度： 最好情况（每次总是选到中间值作枢轴）:T(n)=O(nlog2n) 最坏情况（每次总是选到最小或最大元素作枢轴）:T(n)=O(n²) 空间复杂度： 最坏情况：S(n)=O(n) 一般情况：S(n)=O(log2n) 选择排序将待排序的结点分为已排序(初始为空)和为未排序两组，依次将未排序的结点中值最小的结点插入已排序的组中。 直接选择排序此方法为不稳定排序。 若第二个重复关键字之后存在比其小的关键字，那么在排序中第一个重复关键字会与后面更小的关键字交换，从而导致该算法不稳定。 比如：49 50 49* 13 思想 通过 n-1 次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换。 再通过 n-2 ，n-3 ，…… 次共 n-1 次排序后，排序结束。 示例 堆排序此方法为不稳定排序。 思想先将无序序列建成一个堆，得到关键字最小（或最大）的记录；输出堆顶的最小（大）值后，使剩余的n-1个元素重又建成一个堆，则可得到n个元素的次小值；重复执行，得到一个有序序列。 整个排序过程可分为以下三步： 将一个无序序列建成一个堆。 输出堆顶元素。 调整剩余元素，使之成为一个新的堆。 重复2、3步骤，直至输出完毕。 示例以将{49 38 65 97 76 13 27 50}按升序排列为例。 将该序列建成一个最小堆。 输出堆顶元素，并调整剩余元素，使之成为一个新的最小堆。 同理，重复上一步，直至清空堆。 参考代码需要注意的是：在堆排序算法中构建的堆优先用顺序储存；若升序排列则需要构建最大堆，降序排列需构建最小堆，可降低空间复杂度。 /** * 直接选择排序，升序 * @param arr 需要排序的int数组 * @return 排好序的int数组 */ public static int[] straight_selectSort(int[] arr){ //如果数组长度为0或1，直接返回 if(arr.length == 0 || arr.length == 1) return arr; int midNum; //循环（数组长度-2）次排序 for (int i = 0 ; i&lt;arr.length-1 ; i++){ //创建未排序部分最小数据位置 int min_index = i; //循环寻找未排序部分的最小数据 for (int j = i+1 ; j&lt;arr.length ; j++){ if(arr[j]&lt;arr[min_index]) min_index = j; } //未排序部分的最前端数据与最小数据调换，并并入已排序部分 midNum = arr[i]; arr[i] = arr[min_index]; arr[min_index] = midNum; } //返回已排好序的数组 return arr; } /** * 堆排序，升序 * @param arr 需排列的int数组 * @return 已排好列的int数组 */ public static int[] heapSort(int[] arr){ //将拥有n个数据的数组创建为最大堆 //注：在循环过程中始终保证根结点为arr[i]的堆为最大堆，下方同理 for(int i = arr.length/2-1 ; i&gt;=0 ; i--){ to_maxheap(arr,i,arr.length-1); } int midNum; //每次将n个数据的最大堆的最大值（根结点，第0位置）与数组最后一个数调换，并将前n-1个重新排为最大堆。 //依次类推，共循环n次 for(int i = arr.length-1 ; i&gt;=1 ; i--){ midNum = arr[i]; arr[i] = arr[0]; arr[0] = midNum; to_maxheap(arr,0,i-1); } //数据初始化并返回 midNum = 0; return arr; } /** * 创建最大堆 * @param arr int数组 * @param root 堆的根结点 * @param end 范围 */ private static void to_maxheap(int[] arr,int root,int end) { // TODO Auto-generated method stub //寻找根结点最大子结点，初始化为左子结点 int max_child = root * 2 + 1; int maxNum; //当最大子结点在root~end范围内时循环 while(max_child&lt;=end){ //如果根结点右子结点比左子结点大，最大子变更为右子结点 if(max_child&lt;end &amp;&amp; arr[max_child]&lt;arr[max_child+1]/*如果需要为降序，此处为&gt;符号*/) max_child+=1; //如果子结点数据比根结点数据大，结点数据交换，并将root、max_child指针向下层移动 if(arr[root]&lt;arr[max_child]/*如果需要为降序，此处为&gt;符号*/){ maxNum = arr[root]; arr[root] = arr[max_child]; arr[max_child] = maxNum; root = max_child; max_child = 2*root+1; //否则，跳出循环 }else{ break; } } //数据初始化 maxNum = 0; } ``` 复杂度分析 直接选择排序： 时间复杂度： 移动次数：最好情况：0最坏情况：3(n-1) 比较次数： 堆排序: 时间复杂度：O(n log2(n)) 空间复杂度：O(1) 归并排序此方法为稳定排序。 思想设有两个有序表A和B，对象个数分别为al 和 bl ，变量i和j分别是两表的当前指针。 设表C是归并后的新有序表，变量k是它的当前指针。 i和j对A和B遍历时，依次将关键字小的对象放到C中，当A或B遍历结束时，将另一个表的剩余部分照抄到新表中。 示例以将{8 4 5 6 3 2 9 7}按升序排列为例。 参考代码需要注意的是：此参考代码与思想有一定出入。 但能成功排序。。 /** * 归并排序，数组中的一段 * @param arr 数组 * @param start1 第1开始位置 * @param start2 第2开始位置 * @param n 需排序的数组总长度 * @return 已排序的数组 */ private static int[] mergeSort_1(int[] arr,int start1,int start2,int n){ //创建过渡数组 int[] arr2 =new int[n]; //将数组看成两个部分，并创建指针 int p = start1,q = start2; int k = 0; //循环至p，q指针其中一个指到各部分末尾 while(p&lt;start2 &amp;&amp; q&lt;start1+n){ //取指针所指数据大的添加入过渡数组中，并取出数据的指针向后移动 if(arr[p]&lt;arr[q]){ arr2[k++]=arr[p++]; }else{ arr2[k++]=arr[q++]; } } //如果各部分还有未添加入过渡数组的数据，直接按顺序加入 if(p!=start2){ for (int i = p ; i&lt;start2 ; i++) arr2[k++] = arr[i]; } if(q!=start1+n){ for (int i = q ; i&lt;start1+n ; i++) arr2[k++] = arr[i]; } //将过渡数组中已排好序的数据添加回原来需排序数组的位置 p = start1; for(int i = 0 ; i&lt;n ; i++) arr[start1++]=arr2[i]; //返回已部分排好序的数组 return arr; } /** * 归并排序，升序 * @param arr 需排列的int序列 * @return 已排列的int序列 */ public static int[] mergeSort(int[] arr){ //如果长度为0或1，直接返回输出 if(arr.length==0 || arr.length==1) return arr; //将需排序的序列分为元素数为n的子序列，i为子序列开始位置 int n = 1,i = 0; //循环至子序列元素数n大于需排序序列 while(n&lt;arr.length){ //依次取两个子序列进行归并，结束后取之后的两个子序列 for(i = 0; i&lt;arr.length ; i+=2*n) { //若第一个子序列能取n个元素，而第二个不能取，则这两个长度不等的子序列进行归并 if(n&lt;(arr.length-i) &amp;&amp; 2*n&gt;(arr.length-i)){ mergeSort_1(arr,i,i+n,arr.length%(2*n)); //若两个子序列均完整有n个数据，则直接归并 }else if(i+2*n&lt;=arr.length){ mergeSort_1(arr,i,i+n,2*n); } //若第一个子序列无法取完整的n个元素，则跳过 } //子序列元素数×2 n*=2; } //返回已排好序的序列 return arr; } ` 复杂度分析归并排序在第 i 趟归并后，有序子序列长度为 2i 。对于具有 n 个记录的序列来说，必须做 log2(n) 趟归并，每趟归并所花的时间为 O(n)。 所以，二路归并排序算法的时间复杂度为 O(n log2(n))，空间复杂度为 O(n)。 基数排序 基本原理 采用“分配”和“收集”的办法，用对多关键字进行排序的思想实现对单关键字进行排序的方法。 多关键字排序原理 以扑克牌为例 每张扑克牌有两个“关键字”：花色和面值，它们之间有次序的优先。 对以上排序，可以先对花色排序，或先对面值排序，之后再对另一个关键字排序。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记(8.4.2)——二叉树的应用：二叉排列树，线索二叉树","slug":"数据结构笔记8.4.2","date":"2020-05-12T01:45:00.000Z","updated":"2020-06-16T11:41:44.603Z","comments":true,"path":"2020/05/12/数据结构笔记8.4.2/","link":"","permalink":"/2020/05/12/数据结构笔记8.4.2/","excerpt":"","text":"二叉排序树概念在二叉排序树中，若按中序遍历就可以得到由小到大的有序序列，即{ 2，3，3，7，8，10，12，18 } 构造将添加的数据若小于根结点的数据，则放在根结点的左子树中；若大于等于根结点的数据，则放在右子树中。 构造参考算法核心//结点 static class Node{ int data; Node left; Node right; public Node(int data){ this.data = data; } } //二叉排列树 static class Tree{ /** * 添加数据 * @param root 根结点 * @param data 添加数据 * @return 根结点 */ private Node add(Node root , int data){ //如果根为null，直接添加 if (root == null) { return new Node(data); //当数据小于根结点的数据时，添加至左子树中，反之则添加至右子树中 //相等时结点位于右子树 } else if (data &lt; root.data) { root.left = add(root.left, data); } else { root.right = add(root.right, data); } return root; } } `` 输出用直接采用之前的文章的参考代码。 import java.util.ArrayList; import java.util.Stack; /** * 中序 * @param root 树的根结点 * @return 中序遍历序列数组 */ public static ArrayList&lt;Object&gt; inOrder(Node root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); //创建中序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向根结点 Node p = root; //循环至p指针为null，以及栈为空。 while(p!=null || !stack.isEmpty() ){ //依次将左子树结点入栈，直至为null while(p!=null){ stack.add(p); p = p.left; } /* * 如果指针p和栈均为空，则遍历完成 * 如果栈不为空，弹出的栈顶结点，数据入组，p指针指向该节点右子节点 */ if(!stack.isEmpty()){ p = stack.pop(); list.add(p.data); p = p.right; } } //返回中序遍历序列数组 return list; } 主函数测试//主函数测试 public static void main(String[] args){ Node root = new Node(1); int[] datas = {3,2,4,6,5}; Tree BSTree = new Tree(); for(int i = 0 ; i&lt;datas.length ; i++){ BSTree.add(root,datas[i]); } ArrayList&lt;Object&gt; list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.print(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } } ` 结果中序遍历序列为：[1,2,3,4,5,6] 二叉排序树的查找算法此处参考代码只判断二叉排列树中是否有该数据。 核心(此处应加在上文class Tree中) /** * 查找指定值的结点 * @param root 父节点 * @param data 查找值 * @return true代表找到 */ private boolean search(Node root, int data) { //如果为空树，返回false if (root == null) {return false;} //如果查找到，返回true if (data == root.data) {return true; } //如果未找到，并且结点数据大于查找的数据，进入左子树 else if (data &lt; root.data) {return search(root.lchild, data); } //未找到，并且结点数据小于等于查找数据，进入右子树 else {return search(root.rchild, data); } } ` 主函数测试//主函数测试 public static void main(String[] args){ Node root = new Node(1); int[] datas = {3,2,4,6,5}; Tree BSTree = new Tree(); for(int i = 0 ; i&lt;datas.length ; i++){ BSTree.add(root,datas[i]); } ArrayList&lt;Object&gt; list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.println(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } //查找 int find = 2; if (BSTree.search(root, find)) { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，找到&quot;+find+&quot;元素&quot;); } else { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，未找到&quot;+find+&quot;元素&quot;); } int find1 = 10; if (BSTree.search(root, find1)) { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，找到&quot;+find1+&quot;元素&quot;); } else { System.out.println(&quot;在以&quot;+root.data+&quot;为根结点的二叉排列树中，未找到&quot;+find1+&quot;元素&quot;); } } `` 结果中序遍历序列为：[1,2,3,4,5,6] 在以1为根结点的二叉排列树中，找到2元素 在以1为根结点的二叉排列树中，未找到10元素 `` 二叉排序树的删除原则：删除某结点以后，依旧是一棵二叉排序树。 删除二叉排序树中的p结点，分三种情况。 p为叶子结点。只需修改p双亲f的指针。 p只有左子树或右子树。用p的左孩子或右孩子代替p。 p左、右子树均非空。 沿p左子树的根C的右子树分支找到S，S的右子树为空，将S的左子树成为S的双亲Q的右子树，用S取代p。 若C无右子树，用C取代p。 核心//二叉排列树 static class Tree{ /** * 删除指定结点 * @param root 根结点 * @param data 删除的数据（若二叉树中存在重复数据，优先删除靠近左子树根结点的结点） */ private Node remove(Node root , int data){ //查找指定结点 Node theNode = search_Node(root,data); //若没找到，不进行操作 if (theNode == null) { System.out.println(&quot;未找到&quot;+data+&quot;结点，不进行操作&quot;); return root; } int thedata = theNode.data; //找到父母结点 Node parNode = search_parentNode(root,theNode); //若该结点为叶子节点，直接删除，并删除并将父母结点的指向删除 if(theNode.left == null &amp;&amp; theNode.right == null){ //若为根结点，删除唯一的结点root if(parNode == null){ root = null; //若在左子树，父母结点的左子结点删除 }else if(parNode.left == theNode){ parNode.left = null; //若在右子树，父母结点的右子结点删除 }else{ parNode.right = null; } //指针清空 theNode = null; //输出结果并返回根结点 System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; } //若该结点没有左子树或右子树，直接删除该结点，并将其父母节点的指向变为其右子树或左子树根结点 if(theNode.left == null || theNode.right == null){ //如果该结点没有左子树 if (theNode.left == null){ //如果是根结点，新根结点变为根结点的右子结点 if(parNode == null){ root = theNode.right; //如果是其父母结点的左子结点，左子结点变更为该结点的右子节点 }else if(parNode.left == theNode){ parNode.left = theNode.right; //如果是其父母结点的右子节点，右子结点变更为该结点的右子节点 }else{ parNode.right = theNode.right; } //清空指针 theNode = null; //输出结果并返回根结点 System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; //如果该结点没有右子树，其余与上者类似 }else{ if(parNode == null){ root = theNode.left; }else if(parNode.left == theNode){ parNode.left = theNode.left; }else{ parNode.right = theNode.left; } theNode = null; System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; } } //若该结点右左右子树，找到左子树中最大值代替，并将原最大值的结点位置由其左子树根结点代替 if(theNode.left != null &amp;&amp; theNode.right != null){ //找到该结点左子树中最大的节点，作为代替的结点 Node reNode = search_MaxNode(theNode); //代替结点的父母结点的右子树变更为其左子树 search_parentNode(root,reNode).right = reNode.left; //如果该结点为根结点，新根结点变更为代替结点 if(parNode == null){ root = reNode; } //如果该结点不是根结点，即拥有父母结点，并且是其父母结点的左子结点 //该结点的父母结点的左子结点变为代替结点 else if(parNode.left == theNode){ parNode.left = reNode; //如果该结点不是根结点，即拥有父母结点，并且是其父母结点的右子结点 //该结点的父母结点的右子结点变为代替结点 }else{ parNode.left = reNode; } //如果代替结点不是该结点的左子结点，代替结点的左子结点变更为该结点的左子结点 //此时代替结点应在该结点位置 if(theNode.left != reNode){ reNode.left = theNode.left; } //代替结点的右子节点变更为该结点的右子节点 reNode.right = theNode.right; //清空指针 theNode = null; //输出结果并返回根结点 System.out.println(&quot;结点&quot;+thedata+&quot;已删除&quot;); return root; } throw new RuntimeException(&quot;删除错误&quot;); } /** * 寻找父母结点 * @param root 根结点 * @param theNode 需要找的结点 * @return 父母结点（如果没有则为null） */ private Node search_parentNode(Node root,Node theNode) { if (root.data == theNode.data){return null;} while(root.left != theNode &amp;&amp; root.right != theNode){ if (root.data &lt;= theNode.data) {root = root.right;} else {root = root.left;} } return root; } /** * 查找到指定数值的结点，并返回 * @param root 根结点 * @param data 指定数值 * @return 拥有指定数值的结点 */ private Node search_Node(Node root , int data){ if (root == null) {return null;} if (data == root.data) {return root;} else if (data &lt; root.data) { return search_Node(root.left, data);} else { return search_Node(root.right, data);} } /** * 查找指定节点的左子树中最大值的结点 * @param root 指定节点 * @return 最大数值的结点 */ private Node search_MaxNode(Node root){ Node p = root.left; while(p.right != null){ p = p.right; } return p; } } ```` 主函数测试此处包含二叉排列树的构造和添加的代码。 //主函数测试 public static void main(String[] args){ Node root = new Node(80); int[] datas = {50,120,60,110,55,70,53}; Tree BSTree = new Tree(); for(int i = 0 ; i&lt;datas.length ; i++){ BSTree.add(root,datas[i]); } ArrayList&lt;Object&gt; list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.println(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } list = preOrder2(root); //删除 root = BSTree.remove(root,53); root = BSTree.remove(root,50); root = BSTree.remove(root,120); root = BSTree.remove(root,80); root = BSTree.remove(root,80); list = inOrder(root); System.out.print(&quot;中序遍历序列为：[&quot;); for (int i = 0 ; i&lt;list.size() ; i++){ if(i == list.size()-1) {System.out.println(list.get(i)+&quot;]&quot;);break;} System.out.print(list.get(i)+&quot;,&quot;); } } ` 结果中序遍历序列为：[50,53,55,60,70,80,110,120] 结点53已删除 结点50已删除 结点120已删除 结点80已删除 未找到80结点，不进行操作 中序遍历序列为：[55,60,70,110] `` 线索二叉树概念线索：指向前驱或后继结点的指针。 线索二叉树：加上线索的二叉链表表示的二叉树。 前驱与后继：在二叉树的先序、中序或后序遍历序列中两个相邻的结点。 线索化：对二叉树按某种遍历次序使其变为线索二叉树的过程。 优点：⚪利用线索二叉树进行中序遍历时，不必采用栈处理，其速度较一般二叉树的遍历速度快，并且节约存储空间。⚪任意一个结点都能直接找到它的前驱和后继结点。 构造在线索二叉树的结点中需增加两个标志域 ltag：若 ltag=0, lchild 域指向左孩子；若 ltag=1, lchild域指向其前驱 rtag：若 rtag =0, rchild 域指向右孩子；若 rtag=1, rchild域指向其后继。 线索二叉树中的结点所包含的区域：lchild（左子结点） ltag（左标志） data（数据） rtag（有标志） rchild（右子节点） 示例","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"方舟一周年","slug":"方舟一周年","date":"2020-05-01T08:00:00.000Z","updated":"2020-06-10T03:54:19.834Z","comments":true,"path":"2020/05/01/方舟一周年/","link":"","permalink":"/2020/05/01/方舟一周年/","excerpt":"","text":"凯尔希，原谅我有可能在头图中没有把你的脸露出来。。 最近微博上的一些事周年直播整活的鹰小姐。老板大气，老板身体健康。 哦，我亲爱的傲娇鹰小姐，自从之前你微博发错号的时候，你的傲娇御姐人设已经崩塌了，想不到你原来是在电脑前啪嗒啪嗒拍键盘的兔兔。从此之后，有了个外在高冷御姐内在却是可爱萌妹的诡异人设。 鹰小姐这人设太生艹了，运营你这样弄不会把自己弄成人格分裂吗？ 以上图均来自微博。 微博里个个都是人才，说话又好听，超喜欢在里面的。 博客专供周年直播中yj表达出的正在努力的态度是很重要的信息，即使是一个商业游戏，是要赚钱的，但能感受得出来yj对自家游戏的喜爱，期间在不停告诉玩家他们正努力制作新内容。 为什么喜欢方舟的剧情？不仅仅是因为它并非像其他许多二次元游戏中软萌的形象，它更多反映的的是阴暗的一面，表面看似平静，实则暗流涌动。 （以下地名均来自方舟世界观，请不要与现实对应，均基于档案和自我推测） 方舟最大的坑，在卡兹戴尔发生的特雷西娅和摄政王特雷西斯的王位争夺战中，特雷西斯的斩首行动为何会如此奇怪的获得成功；特雷西娅是否与博士之间有什么不可告人的计划；罗德岛前身巴别塔在解体之前博士究竟策划了什么；作为目前的唯一正统的特雷西斯强腕下统一的卡兹戴尔会走向何方。 乌萨斯是否会借整合之手乘机夺取龙门；整合运动对乌萨斯的渗透究竟到了哪一地步；帝国的高压统治和内部的腐朽，最终是否会导致爆发革命，而罗德岛在其中会扮演什么角色。 在维多利亚发生的感染者事件始末如何；皇室成员之一的王维娜为何流落街头；皇位为何空缺，使得卡兹戴尔摄政王特雷西斯乘虚而入。 谢拉格军阀、喀兰贸易公司董事长、三大家族之一的希瓦艾什家族现任族长银灰与罗德岛合作目的为何；谢拉格爆发的雪山事变的过程和结果如何，罗德岛是否参与其中。 西西里女士用了什么手段将曾经的黑手党家族赶出叙拉古。 哥伦比亚的莱茵生命在军方的投资下究竟在一些实验上走了多远；炎魔事件是否揭露了莱茵生命真正实验的冰山一角。 政局混乱的玻利瓦尔，三方混战的局面什么时候会被打破。 曾经的龙门和乌萨斯之间爆发的战争起因、过程如何；在表面“自由、博爱”的龙门背后是否还有残杀感染者等类似事件，是否是魏延武的无奈之举；魏延武和炎国高层之间有什么关系，又和柯西切发生过什么矛盾。 陈sir和塔露拉之间发生了什么；塔露拉在“那个村子”里发生了什么，为何拥有“两个影子”；前妻凯尔希的身上还有多少谜团，她对博士的不信任来源于何处；阿米娅是否接手了特雷西娅的理想，而最终是否会带领罗德岛带给泰拉大陆一线光明；加入罗德岛的W，被软禁的赫德雷，可能未牺牲的“信使”伊内丝，脱离特雷西斯控制的萨卡兹雇佣兵最终会带给依旧在迷雾中的卡兹戴尔什么变数；博士之前为何会沉睡，这是否是计划的一环。 支线剧情中：莫斯提马为何会射杀能天使的姐姐，而且最终获得了拉特兰的宽大处理；未来玻利瓦尔大行军中殿后的精英干员米格鲁为何称之为“她的最后考验”——我更愿意相信这是她在玻利瓦尔最后的任务，之后会返回罗德岛继续完成其他任务；拉狗子在家族中发生了什么，又和萨科塔之间发生过什么；以及个人私货，德克萨斯家族为何会覆灭，在以前德狗子和拉狗子在叙拉古有什么交往（虽然我是卑微的德空党）。 绝了，这样梳理下来方舟的坑还不少，而且因为我一般是满好感精二之后再看干员档案，所以可能存在许多还不知道的坑。 对于我来说，没了剧情，方舟乐趣至少少了一半，而且制作组还喜欢往里面加谜题虽然我大多看不懂，只有看看埃及研和up分析。就像埃及人海猫采访时说的那样，想改变二次元手游的固有印象，在某种程度上说确实做到了。 当然，方舟的剧情并不会单方面的表达负面情绪和思想，先给你丰满一个人物，然后在之后剧情中让他/她牺牲。依然会在残酷的泰拉大陆带来一线光明上——“即使付出代价，也总要追寻什么”（W），一次相遇、一个契机可能就会改变人一生轨迹（霜星），即使是在残酷的世界中，也存在宁可赴死，也要坚守自己意志和信念的人（爱国者）。就如同日剧一样，不会跟你说社会是美好的，未来是光明的，告诉自己这社会是现实的、残酷的、黑暗的，但又会教你如何在这样的社会中积极生活下去。这也算是比较喜欢方舟剧情的原因之一。 比如说像清流的晋升档案中写的“一定要注意那些在你面前大谈人生和理想的上级”，我怀疑文案在暗示某个人（笑） 最后，关于关卡难度的问题，表示：打突袭、超难本、危机合约时唯唯诺诺，问卷调查请继续加大力度。 方舟一周年快乐，凯尔希终于肯笑了。凯尔希现在的人设太戳我了，果然在一定深入了解后不可避免地会对凯尔希产生一些好感，剧情中愿意笑就好了。。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"《数据结构》笔记(8.4.1)——二叉树的应用：哈夫曼树","slug":"数据结构笔记8.4.1","date":"2020-04-24T01:45:00.000Z","updated":"2020-06-16T11:41:39.674Z","comments":true,"path":"2020/04/24/数据结构笔记8.4.1/","link":"","permalink":"/2020/04/24/数据结构笔记8.4.1/","excerpt":"","text":"基本术语路径：在一棵树中，从一个结点往下可以达到的孩子或子孙结点之间的通路。 路径长度：通路中分支的数目。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 结点的权：若将树中结点赋给一个有着某种含义的数值，这个数值称为该结点的权。 带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。 树的带权路径长度：所有叶子结点的带权路径长度之和，记为WPL。 哈夫曼树(Huffman tree)定义：在一棵二叉树中，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。 特点 哈夫曼树中不存在度为1的结点。 哈夫曼树中权值越大的叶子结点越靠近根结点。 哈夫曼树中根结点的值等于所有叶子结点的权值之和 n个叶节点的哈夫曼树共有2n-1个结点 哈夫曼树的构造假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1 ,w2 ,…,wn , 则哈夫曼树的构造规则为： 将 w1 ,w2 ,…,wn 看成是有n棵树的森林(每棵树仅有一个结点) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和 从森林中删除选取的两棵树，并将新树加入森林 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为我们所求得的哈夫曼树 n 个权值构造哈夫曼树需n-1次合并，每次合并，森林中的树数目减1，最后森林中只剩下一棵树，即为我们求得的哈夫曼树。 示例假设给定的4个叶子结点的权分别为1,5,7,3。 初始森林 第一次合并 第二次合并 第三次合并 哈夫曼树构造算法仅供参考。 /* * 创建结点 * 结点包含：权重，父级，左子级和右子级结点 */ static class Node&lt;E&gt;{ Node&lt;E&gt; parent,left,right; int weight; public Node(int weight,Node&lt;E&gt; parent,Node&lt;E&gt; left,Node&lt;E&gt; right){ this.weight = weight; this.parent = parent; this.left = left; this.right = right; } public Node(int weight){ this(weight,null,null,null); } } /** * 创建哈夫曼树 * @param weights 叶子节点的权重集合的数组 * @return 哈夫曼树根结点 */ public static Node&lt;?&gt; BuildHTree(int[] weights){ //判断是否为空 if(weights == null) throw new RuntimeException(&quot;叶子节点为空&quot;); //创建结点数组 Node&lt;Integer&gt;[] HTree = new Node[weights.length]; //将各个权重当成一棵树，加入到森林数组中 for (int i = 0 ; i&lt;weights.length ; i++){ Node&lt;Integer&gt; theNode = new Node&lt;Integer&gt;(weights[i]); HTree[i] = theNode; } //如果只有一个节点，直接返回 if(weights.length == 1) return HTree[0]; //创建指针，当前最小的两个权重值及其位置 Node&lt;Integer&gt; p = null , q = null; int x1 = 0,x2 = 0; int index1 = 0 , index2 = 0; //循环（叶子节点个数-1）次 for (int i = 0 ; i&lt;weights.length-1;i++){ //x1，x2取最大值 x1 = Integer.MAX_VALUE; x2 = Integer.MAX_VALUE; //循环找出最小的两个权重及其位置，并将其移出森林 for (int j = 0 ; j&lt;HTree.length ; j++){ if (HTree[j] == null) continue; if (HTree[j].weight &lt;= x1){ p = HTree[j]; x1 = HTree[j].weight; index1 = j; } } HTree[index1] = null; for (int j = 0 ; j&lt;HTree.length ; j++){ if (HTree[j] == null) continue; if (HTree[j].weight &lt;= x2){ q = HTree[j]; x2 = HTree[j].weight; index2 = j; } } HTree[index2] = null; //创建新的结点，并构建新的树 Node&lt;Integer&gt; newNode = new Node&lt;&gt;(p.weight+q.weight); newNode.left = p; newNode.right = q; p.parent = newNode; q.parent = newNode; //将树加入到森林中 HTree[index1] = newNode; } //找到最后一颗树的位置 for (int i = 0 ; i&lt;weights.length ; i++){ if (HTree[i] != null) {x1 = i ; break;} } //输出根结点 return HTree[x1]; } `` 测试时所需的非必要方法直接使用的二叉树遍历的递归算法。 /** * 二叉树的遍历（使用的之前的递归遍历） */ public static class TreeTraver{ //先序 public static void preOrder(Node&lt;?&gt; root){ if(root == null) return; System.out.print(root.weight + &quot; &quot;); preOrder(root.left); preOrder(root.right); } //中序 private static void inOrder(Node&lt;?&gt; root){ if (root == null) return; inOrder(root.left); System.out.print(root.weight + &quot; &quot;); inOrder(root.right); } //后序 private static void postOrder(Node&lt;?&gt; root){ if (root == null) return; postOrder(root.left); postOrder(root.right); System.out.print(root.weight + &quot; &quot;); } } 主函数测试//主函数测试 public static void main(String[] args){ int[] weights = {1,3,5,7,6}; Node&lt;?&gt; BTree = BuildHTree(weights); System.out.print(&quot;先序遍历序列：&quot;); TreeTraver.preOrder(BTree); System.out.println(); System.out.print(&quot;中序遍历序列：&quot;); TreeTraver.inOrder(BTree); System.out.println(); System.out.print(&quot;后序遍历序列：&quot;); TreeTraver.postOrder(BTree); System.out.println(); } ` 结果先序遍历序列：22 9 4 1 3 5 13 6 7 中序遍历序列：1 4 3 9 5 22 6 13 7 后序遍历序列：1 3 4 5 9 6 7 13 22 ` 哈夫曼树的应用之一：数据编码定长编码在特定条件下的通讯中，要将待传字符转换成二进制组成的字符串。 例： 设要传输的字符为：ACDBADDDDD 采用定长编码方式：A——00；B——01；C——10；D——11 传输时编码为：00101101110011111111（20位） 可看出此方法缺陷：字符A和D出现频率比B、C高，而它们占用了相同空间，导致一定空间的浪费。 变长编码单个编码的长度不一致，可以根据整体出现频率来调节，出现频率越高，编码长度越短。 变长编码优于定长编码的是，变长编码可以将短编码赋予平均出现频率较高的字符，同一消息的编码长度小于定长编码。 既可节约空间，又可节约传输时间。 例： 设要传送的字符为:ACDBADDDDD 频次：A:2；B:1；C:1；D:6 采用二叉树设计二进制前缀编码。 假设：左分支为“1”，右分支为“0”。 由此得到字符的前缀码为：A——01B——001C——000D——1 最终传输时编码为：0100010010111111（16位）","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.3）——二叉树的非递归遍历算法","slug":"数据结构笔记8.3","date":"2020-04-21T01:45:00.000Z","updated":"2020-06-16T11:41:16.947Z","comments":true,"path":"2020/04/21/数据结构笔记8.3/","link":"","permalink":"/2020/04/21/数据结构笔记8.3/","excerpt":"","text":"二叉树遍历递归算法 导入的包，树、队列的构建其实完全可以不用导入动态数组ArrayList包的，这只是我比较倾向于用而已。 import java.util.ArrayList; import java.util.Stack; `` 栈在先序、中序、后序遍历中使用。队列在层次遍历中使用。（其实这是直接搬用的前面用数组构建循环队列的方法，懒得再写一遍而已） /** * 创建结点，包含数据，左右子结点地址 */ static class Node&lt;E&gt;{ E data; Node&lt;E&gt; right; Node&lt;E&gt; left; //相关数据的添加 public Node(E data , Node&lt;E&gt; right , Node&lt;E&gt; left){ this.left = left; this.right = right; this.data = data; } //初始化 public Node(E data){ this(data,null,null); } } /** * 创建树 */ public static class LinkedTree&lt;E&gt;{ //根结点 Node&lt;E&gt; root; //初始化树 public LinkedTree(E data){ root = new Node&lt;&gt;(data); } /** * 添加结点 * @param data 添加的数据 * @param father 父级结点地址 * @param isLeft 是否为父级结点的左子结点 * @return 添加的结点 */ public Node&lt;E&gt; add(E data , Node&lt;E&gt; father , boolean isLeft){ if(father == null) throw new RuntimeException(&quot;无父级，拒绝添加&quot;); Node&lt;E&gt; theNode = new Node&lt;&gt;(data); if(isLeft){ father.left = theNode; }else{ father.right = theNode; } return theNode; } } /** * 循环队列 */ static class QueueArray&lt;E&gt;{ //设定队列，队的容量，前端和后端，元素数量。 //前端为队头元素位置，后端下标为队尾元素后一个位置。 private int size = 20 ; private Object[] que_arr ; private int front ; private int rear ; private int count ; //初始化队列 public QueueArray(){ que_arr =new Object [size] ; this.front = 0 ; this.rear = 0 ; this.count = 0; } /** * 入队 * @param data */ public void In(E data){ //判断是否队满 if (count == size){ throw new RuntimeException(&quot;队满&quot;); } //添加数据，元素总数+1 que_arr[rear] = data ; ++count; //队尾标号的增加 if (rear+1 &gt;= size){ rear = 0; }else{ ++rear; } } /** * 出队 * @return 队头元素 */ public Object Out(){ if (count == 0){ throw new RuntimeException(&quot;队空&quot;); } Object data = que_arr[front]; que_arr[front] = null ; --count; if (front+1 &gt;= size){ front = 0; }else{ ++front; } return data; } } /** * 输出 * @param list 需输出的数组 */ public static void print(ArrayList&lt;Object&gt; list){ for (int i = 0 ; i&lt;list.size() ; i++) System.out.print(list.get(i)+&quot; &quot;); System.out.println(); } ` 先序遍历思想1循环控制： 1、入栈前，指向本结点；2、先左子树一次入栈并输出（入栈前先指向该结点），直到没有左子树的结点为止；3、出栈顶元素，然后找到右子树，继续1、2操作，直到栈为空且结点为空。 举例 指针指向根结点，将左子树结点1、2、3循环依次入栈并输出，直至没有左子树结点，指针为null。 栈中元素：1 2 3 输出元素：1 2 3 栈顶结点3出栈，无右子结点，之后栈顶结点2出栈，指针指向结点2的右子结点5，继续重复一步骤：将结点5的左子树结点循环入栈并输出，当然此处5为叶子结点，无左子节点。 栈中元素：1 5 输出元素：1 2 3 5 结点5出栈，无右子结点，之后栈顶结点1出栈，指针指向结点1的右子结点4，同上。 栈中元素：4 输出元素：1 2 3 5 4 结点4出栈，无右子结点，此时栈为空，指针指向结点4的左子结点null，遍历结束。 栈中元素： 输出元素：1 2 3 5 4 参考代码/** * 先序1 * @param root 树的根结点 * @return 先序遍历序列数组 */ public static ArrayList&lt;Object&gt; preOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建暂时存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建先序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向root Node&lt;Object&gt; p = root; //循环至栈空 while(p!=null || !stack.isEmpty() ){ /* * 循环将p结点和左子结点入栈入组，直至p为null */ while(p!=null){ stack.add(p); list.add(p.data); p = p.left; } /* * 如果p为null，栈为空，表明遍历结束 * 如果栈不为空，弹出栈顶结点，p指针指向该节点的右子节点（有可能为null） * 继续循环将p的左子节点入栈入组 */ if(!stack.isEmpty()){ p = stack.pop(); p = p.right; } } //返回后序遍历序列数组 return list; } 思想2使用一个栈，首先将根结点入栈，开始循环： 从栈中退出当前结点p，先访问它，然后将其右孩子入栈，再将其左孩子入栈，如此直到栈为空。（因为对左孩子的访问先序遍历先于右孩子，后入栈的先访问） 举例 结点1入栈。 栈中元素：1 输出元素： 栈顶结点1出栈，输出结点1，并将结点1的右子结点4先入栈，左子结点2后入栈。 栈中元素：4 2 输出元素：1 栈顶结点2出栈，输出结点2，同样将结点2的右子结点5先入栈，左子结点3后入栈。 栈中元素：4 5 3 输出元素：1 2 栈顶结点3出栈，输出结点3，因结点3为叶子结点，无入栈。栈顶结点5出栈，输出结点5 栈中元素：4 输出元素：1 2 3 5 栈顶结点4出栈，输出结点4，栈空，遍历结束。 栈中元素： 输出元素：1 2 3 5 4 参考代码/** * 先序2 * @param root 树的根结点 * @return 先序遍历序列数组 */ public static ArrayList&lt;Object&gt; preOrder2(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建先序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p; //将根结点入栈 stack.push(root); //循环至栈空 while(!stack.isEmpty()){ /* * 依据先序遍历的特点：p结点→左子节点→右子结点 */ //p指针指向弹出栈顶的结点 p = stack.pop(); //p结点的数据入组 list.add(p.data); //如果有右结点，入栈 if( p.right != null) stack.push(p.right); //如果有左节点，入栈并p指针指向左子节点 if( p.left != null) { stack.push(p.left); p=p.left; } } //返回先序遍历序列数组 return list; } ` 中序遍历思想与先序的循环控制类似： 1、入栈前，先指向本结点；2、先左子树一次入栈（入栈前先指向该结点），直到没有左子树的结点为止；3、出栈顶元素并输出，若有右子树，找到右子树，继续1、2操作，直到栈为空且结点为空。 举例 指针指向根结点，将左子树结点1、2、3循环依次入栈，直至没有左子树结点，指针为null。 栈中元素：1 2 3 输出元素： 栈顶结点3出栈并输出，无右子结点，之后栈顶结点2出栈并输出，指针指向结点2的右子结点5，继续重复一步骤：将结点5的左子树结点循环入栈，当然此处5为叶子结点，无左子节点。 栈中元素：1 5 输出元素：3 2 结点5出栈并输出，无右子结点，之后栈顶结点1出栈并输出，指针指向结点1的右子结点4，同上。 栈中元素：4 输出元素：3 2 5 1 结点4出栈并输出，无右子结点，此时栈为空，指针指向结点4的左子结点null，遍历结束。 栈中元素： 输出元素：3 2 5 1 4 参考代码/** * 中序 * @param root 树的根结点 * @return 中序遍历序列数组 */ public static ArrayList&lt;Object&gt; inOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建存储结点的栈 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); //创建中序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针，并指向根结点 Node&lt;Object&gt; p = root; //循环至p指针为null，以及栈为空。 while(p!=null || !stack.isEmpty() ){ //依次将左子树结点入栈，直至为null while(p!=null){ stack.add(p); p = p.left; } /* * 如果指针p和栈均为空，则遍历完成 * 如果栈不为空，弹出的栈顶结点，数据入组，p指针指向该节点右子节点 */ if(!stack.isEmpty()){ p = stack.pop(); list.add(p.data); p = p.right; } } //返回中序遍历序列数组 return list; } ` 后序遍历思想1——双栈实际上我觉得这个方法很神奇。实际上它做的是一个反向的预排序遍历。 由于后序序列的顺序是：左子结点→右子结点→根结点，所以入栈1的顺序是正常顺序，入栈2的顺序是：根结点→右子结点→左子结点，之后再将栈2的结点依次出栈输出。 举例 先将根结点入栈1，在循环中将栈1的栈顶结点1出栈，指针指向结点1，并将其入栈2，将指针所指的结点1的左、右子结点2、4按顺序依次入栈1. 栈1元素：2 4 栈2元素：1 栈1的栈顶结点4出栈，指针指向结点4，并入栈2，由于结点4为叶子结点，跳过。 栈1元素：2 栈2元素：1 4 同循环里的步骤1，栈1的栈顶结点2出栈，指针指向结点2，并入栈2，将指针所指的结点2的左、右子结点3、5依次入栈1。 同步骤2栈1的栈顶结点5出栈入栈2，由于结点5是叶子节点，跳过。结点3同理。 栈1元素：3 5 栈2元素：1 4 2 ↓ 栈1元素： 栈2元素：1 4 2 5 3 ` 栈1空，遍历完毕，将栈2元素依次出栈输出即可。 输出元素：3 5 2 4 1 参考代码/** * 后序 双栈 * @param root 树的根结点 * @return 后序遍历序列数组 */ public static ArrayList&lt;Object&gt; postOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建暂时存储结点的栈1，以及存储结点倒序的栈2 Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); Stack&lt;Object&gt; stack2 = new Stack&lt;&gt;(); //创建后序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p; //将根结点入栈1 stack.push(root); //循环至栈1为空，即栈1结点数据均入栈2 while(!stack.isEmpty()){ /* * 始终依据后序遍历的特点：左子节点→右子结点→p结点 * 由于栈是先入后出，入栈顺序，p结点→右子结点→左子节点 */ //弹出栈1顶端结点 p = stack.pop(); //根据是否存在左右子节点，按照p→右→左的顺序入栈2 stack2.push(p.data); if( p.left != null) stack.push(p.left); if( p.right != null) stack.push(p.right); } //将栈2里的元素依次输入至数组 while (!stack2.isEmpty()){ list.add(stack2.pop()); } //返回后序遍历序列数组 return list; } `` 思想2——标记因后序遍历：左子树→后右子树→根结点，则需要判断上次访问的结点是位于左子树，还是右子树。 若是位于左子树，则需跳过根结点，先进入右子树；若是位于右子树，则直接输出根结点。 因此，可通过设置标志位，标明上次访问的结点是位于左子树，还是右子树。 举例 指针指向根结点，将左子树结点1、2、3循环依次入结点栈，标记栈中入“左”的标记，直至没有左子树结点，指针为null。 结点栈元素：1 2 3 标记栈元素：左 左 左 输出元素： 查看结点栈的栈顶结点3，查看栈栈顶标记，标记为“左”，指针指向结点3的右子结点（为null），标记栈入“右”标记。 结点栈元素：1 2 3 标记栈元素：左 左 右 输出元素： 由于指针为null，跳过循环，查看标记栈栈顶标记，标记为“右”，结点栈栈顶结点3出栈并输出，标记栈栈顶标记出栈。 结点栈元素：1 2 标记栈元素：左 左 输出元素：3 查看结点栈的栈顶结点2，查看栈栈顶标记，标记为“左”，指针指向结点2的右子结点5，标记栈入“右”标记。 结点栈元素：1 2 标记栈元素：左 右 输出元素：3 指针不为null，将结点5入结点栈，“左”标记入标记栈。 结点栈元素：1 2 5 标记栈元素：左 右 左 输出元素：3 同理，查看结点栈的栈顶结点5，查看栈栈顶标记，标记为“左”，指针指向结点3的右子结点（为null），标记栈入“右”标记。 结点栈元素：1 2 5 标记栈元素：左 右 右 输出元素：3 同理，由于指针为null，跳过循环，查看标记栈栈顶标记，标记为“右”，结点栈栈顶结点5出栈并输出，标记栈栈顶标记出栈。之后同上 结点栈元素：1 2 标记栈元素：左 右 输出元素：3 5 ↓ 结点栈元素：1 标记栈元素：左 输出元素：3 5 2 ↓ 结点栈元素：1 4 标记栈元素：右 左 输出元素：3 5 2 ↓ 结点栈元素：1 4 标记栈元素：右 右 输出元素：3 5 2 ↓ 结点栈元素：1 标记栈元素：右 输出元素：3 5 2 4 ↓ 结点栈元素： 标记栈元素： 输出元素：3 5 2 4 1 参考代码/** * 后序 标记 * @param root 树的根结点 * @return 后序遍历序列数组 */ public static ArrayList&lt;Object&gt; postOrder2(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建储存结点和左右子树的标记的栈，此处左子树记为-1，右为1. Stack&lt;Node&lt;Object&gt;&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); //创建后序遍历序列储存的列表 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //创建指针 Node&lt;Object&gt; p = root; //循环直至结点栈为空和指针为null while( p != null || !stack.isEmpty()){ //若指针不为null，将结点入栈，并标记为左子树（-1），循环至p指向null while (p!=null){ stack.push(p); stack2.push(-1); p = p.left; } //若p指针为null,栈中为空，则已遍历完成，跳出循环。 if(stack.isEmpty()) break; /* * 指针上一个指向的结点，即结点栈顶端的结点若在右子树， * 则该节点左右结点结点均已遍历（当然也有可能为空），弹出右标记，并将该结点入表 */ if(stack2.peek() == 1){ stack2.pop(); list.add(stack.pop().data); } /* * 指针上一个指向的结点，即结点栈顶端的结点若在左子树， * 则弹出左标记，指针指向该节点的右结点，并标记为右子树（1）。 * * 这里需要注意，指向右结点后有可能该节点存在左子树， * 所以需要再次利用前方添加左节点的循环， * 所以需要在循环最后。 */ else if(stack2.peek() == -1){ stack2.pop(); p = stack.peek().right; stack2.push(1); } } //循环结束，返回后序遍历序列数组 return list; } ` 层次遍历（从上向下）思路层次遍历：从上往下，从左往右。 先将根结点入队，指针指向队首，将根结点的左、右子结点依次入队，如果没有就跳过。之后指针向后移动，队首结点出队输出，再次重复将指针所指结点的左、右子结点依次入队。直至队空。 举例 先将根结点入队，指针指向根结点，之后将指针所指结点1的左、右子结点2、4依次入队。 队列元素：1 2 4 输出元素： 指针向后移动，队首结点出队输出，再将指针所指结点2的左、右子结点3、5依次入队。 队列元素：2 4 3 5 输出元素：1 指针向后移动，队首结点出队输出，指针所指结点4为叶子结点，跳过。 队列元素：4 3 5 输出元素：1 2 之后同理，直至队列元素为空。 队列元素： 输出元素：1 2 4 3 5 ` 参考代码/** * 层次 */ @SuppressWarnings(&quot;unchecked&quot;) public static ArrayList&lt;Object&gt; levelOrder(Node&lt;Object&gt; root){ //判断以root为根的树是否为空 if(root==null) return null; //创建储存结点的队列 QueueArray&lt;Node&lt;Object&gt;&gt; quearr = new QueueArray&lt;&gt;(); //创建后序遍历序列储存的数组 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //将根结点入队 quearr.In(root); //创建当前结点和指针,指针指向队首结点 int flag = 0; Node&lt;Object&gt; p = (Node&lt;Object&gt;) quearr.que_arr[flag]; //循环至队列为空 while (quearr.count != 0){ /* * 指针从队首依次向后移动，依次将该节点的左右子节点入队 * 若指针向后移动，之前的结点出队 */ if(p.left!=null) quearr.In(p.left); if(p.right!=null) quearr.In(p.right); //出队入组 list.add(((Node&lt;Object&gt;)quearr.Out()).data); //flag标号的增加 if (flag+1 &gt;= quearr.size){ flag = 0; }else{ ++flag; } //指针向后移动 p = (Node&lt;Object&gt;) quearr.que_arr[flag]; } //返回层次遍历序列数组 return list; } ` 所有方法的主函数测试 public static void main(String[] args){ LinkedTree&lt;Object&gt; tree = new LinkedTree&lt;&gt;(&quot;A&quot;); Node&lt;Object&gt; A = tree.root; Node&lt;Object&gt; B = tree.add(&#39;B&#39;, A, true); Node&lt;Object&gt; C = tree.add(&#39;C&#39;, A, false); Node&lt;Object&gt; D = tree.add(&#39;D&#39;, B, true); Node&lt;Object&gt; E = tree.add(&#39;E&#39;, B, false); Node&lt;Object&gt; F = tree.add(&#39;F&#39;, C, false); Node&lt;Object&gt; G = tree.add(&#39;G&#39;, D, true); Node&lt;Object&gt; H = tree.add(&#39;H&#39;, E, true); Node&lt;Object&gt; I = tree.add(&#39;I&#39;, E, false); Node&lt;Object&gt; J = tree.add(&#39;J&#39;, I, false); System.out.print(&quot;先序遍历序列，法一：&quot;); print(preOrder(A)); System.out.print(&quot;先序遍历序列，法二：&quot;); print(preOrder2(A)); System.out.print(&quot;中序遍历序列：&quot;); print(inOrder(A)); System.out.print(&quot;后序遍历序列，双栈：&quot;); print(postOrder(A)); System.out.print(&quot;后序遍历序列，标记：&quot;); print(postOrder2(A)); System.out.print(&quot;层次遍历序列：&quot;); print(levelOrder(A)); } 结果先序遍历序列，法一：A B D G E H I J C F 先序遍历序列，法二：A B D G E H I J C F 中序遍历序列 ：G D B H E I J A C F 后序遍历序列，双栈：G D H J I E B F C A 后序遍历序列，标记：G D H J I E B F C A 层次遍历序列：A B C D E F G H I J `","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.2）——二叉树的遍历","slug":"数据结构笔记8.2","date":"2020-04-14T01:45:00.000Z","updated":"2020-06-16T11:41:12.286Z","comments":true,"path":"2020/04/14/数据结构笔记8.2/","link":"","permalink":"/2020/04/14/数据结构笔记8.2/","excerpt":"","text":"二叉树的遍历遍历（Traversing）是树形结构的一种重要运算，即按一定的次序系统地访问结构中的所有结点，使每个结点只被访问一次。 常用方法：先序法；中序法；后序法；层次法。 先序法（PreOrder）从根结点a开始访问，接着访问左子结点b，最后访问右子结点c。即：根结点 → 左子树 → 右子树 中序法（InOrder）从左子结点b开始访问，接着访问根结点a，最后访问右子结点c。即：左子树 → 根结点 → 右子树 偷懒的简单转换方法： 后序法（PostOrder）从左子结点b开始访问，接着访问右子结点c，最后访问根结点a。即：左子树 → 右子树 → 根结点 层次法从上往下，从左往右依次读出结点。 依据序列构建二叉树若仅已知先序序列、中序序列、后序序列其中任意一个，无法唯一确定二叉树。 若知先序和后序序列，同样无法唯一确定二叉树。 特殊情况 前序遍历与中序遍历相同的二叉树。 空二叉树、只有根结点的二叉树、只有左子树的二叉树 中序遍历与后序遍历相同的二叉树。 空二叉树、只有根结点的二叉树、只有右子树的二叉树 前序遍历与后序遍历相同的二叉树。 空二叉树、只有根结点的二叉树 先序、中序序列例：若已知某二叉树的先序序列 [ ABHFDECKG ] 和中序序列 [ HBDFAEKCG ] ，构建该二叉树。 对于先序序列，根结点在第一个位置。对于中序序列，根结点大多数情况在中序序列的中间某一位置（也可能存在位于首尾的情况），左边部分是根结点的左子树的中序遍历序列，右边部分是根结点的右子树的中序遍历序列。 先序：A BHFD ECKG 中序：HBDF A EKCG 结论：A是根结点，HBDF结点在左侧，ECKG结点在右侧。 先序：B H FD 中序：H B DF 结论：B是左子树根结点，H结点在左侧，FD结点在右侧。 根据先序和中序的特点，F位于D的上一层，且D在以F为根结点的子树的左子树中，F无右子树。 先序：E CKG 中序：E KCG 结论：E是右子树根结点，左侧无结点，CKG结点在右侧。 先序：C KG 中序：K C G 同样的，根据先序和中序的特点，C位于KG的上一层，且K在以C为根结点的子树的左子树中，G在右子树中。 中序、后序序列实际上，已知中序、后序序列来构建二叉树与已知先序、中序来构建方法类似，均是利用遍历序列特性。 例：若已知某二叉树的后序序列 [ DGEBFCA ] 和中序序列 [ DBGEACF ] ，构建该二叉树。 对于后序序列，根结点在最后一个位置。中序序列同上 后序：DGEB FC A 中序：DBGE A CF 结论：A是根结点，DBGE结点在左侧，CF结点在右侧。 后序：D GE B 中序：D B GE 结论：B是左子树根结点，D结点在左侧，GE结点在右侧。 根据后序和中序的特点，E位于G的上一层，且G在以E为根结点的子树的左子树中，E无右子树。 同理，右子树中，C位于F的上一层，且F在以C为根结点的子树的右子树中，C无左子树。 二叉树递归遍历算法二叉树以用链表构建的为例，每个结点中包含：该节点的数据，左、右子结点的地址。 实际上个人觉得二叉树遍历的递归算法虽容易理解，但写出来对于我来说可能会有点困难，因为找到进入和跳出的点可能对于我来说有些困难，所以个人的倾向还是使用非递归的算法。 结点和树的创建及递归遍历/** * 创建结点，包含数据，左右子结点地址 */ static class Node&lt;E&gt;{ E data; Node&lt;E&gt; right; Node&lt;E&gt; left; //相关数据的添加 public Node(E data , Node&lt;E&gt; right , Node&lt;E&gt; left){ this.left = left; this.right = right; this.data = data; } //初始化 public Node(E data){ this(data,null,null); } } /** * 创建树 */ static class LinkedTree&lt;E&gt;{ //根结点 Node&lt;E&gt; root; //初始化树 public LinkedTree(E data){ root = new Node&lt;&gt;(data); } /** * 添加结点 * @param data 添加的数据 * @param father 父级结点地址 * @param isLeft 是否为父级结点的左子结点 * @return 添加的结点 */ public Node&lt;E&gt; add(E data , Node&lt;E&gt; father , boolean isLeft){ if(father == null) throw new RuntimeException(&quot;无父级，拒绝添加&quot;); Node&lt;E&gt; theNode = new Node&lt;&gt;(data); if(isLeft){ father.left = theNode; }else{ father.right = theNode; } return theNode; } //先序 private void preOrder(Node&lt;E&gt; root){ if(root == null) return; System.out.print(root.data + &quot; &quot;); preOrder(root.left); preOrder(root.right); } //中序 private void inOrder(Node&lt;E&gt; root){ if (root == null) return; inOrder(root.left); System.out.print(root.data + &quot; &quot;); inOrder(root.right); } //后序 private void postOrder(Node&lt;E&gt; root){ if (root == null) return; postOrder(root.left); postOrder(root.right); System.out.print(root.data + &quot; &quot;); } int lives_count = 0; int count=0; //计算叶子结点和总结点，递归 private void count(Node&lt;E&gt; root){ if (root == null) return; if (root.right == null &amp;&amp; root.left == null) lives_count +=1 ; count(root.left); count(root.right); count+=1; } } ` 主函数测试@SuppressWarnings(&quot;unused&quot;) public static void main(String[] args){ LinkedTree&lt;Object&gt; tree = new LinkedTree&lt;&gt;(&quot;A&quot;); Node&lt;Object&gt; A = tree.root; Node&lt;Object&gt; B = tree.add(&#39;B&#39;, A, true); Node&lt;Object&gt; C = tree.add(&#39;C&#39;, A, false); Node&lt;Object&gt; D = tree.add(&#39;D&#39;, B, true); Node&lt;Object&gt; F = tree.add(&#39;F&#39;, C, true); Node&lt;Object&gt; G = tree.add(&#39;G&#39;, C, false); System.out.print(&quot;先序遍历序列：&quot;); tree.preOrder(A); System.out.println(); System.out.print(&quot;中序遍历序列：&quot;); tree.inOrder(A); System.out.println(); System.out.print(&quot;后序遍历序列：&quot;); tree.postOrder(A); System.out.println(); tree.count(A); System.out.print(&quot;总结点数：&quot;); System.out.println(tree.count); System.out.print(&quot;叶子结点数：&quot;); System.out.println(tree.lives_count); } 结果先序遍历序列：A B D C F G 中序遍历序列：D B A F C G 后序遍历序列：D B F G C A 总结点数：6 叶子结点数：3 `","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（8.1）——树的定义和存储结构","slug":"数据结构笔记8.1","date":"2020-04-10T01:45:00.000Z","updated":"2020-06-16T11:41:08.054Z","comments":true,"path":"2020/04/10/数据结构笔记8.1/","link":"","permalink":"/2020/04/10/数据结构笔记8.1/","excerpt":"","text":"定义由零个、一个或多个结点组成的有限集合。仅有一个根结点，结点间有明显的层次结构关系。 从逻辑结构看：1）树中只有根结点没有前趋；2）除根外，其余结点都有且仅一个前趋；3）树的结点，可以有零个或多个后继；4）除根外的其他结点，都存在唯一条从根到该结点的路径；树是一种分枝结构（除了一个称为根的结点外）每个元素都有且仅有一个直接前趋，有且仅有零个或多个直接后继。 表示方法树形表示、图形表示、凹入表表示、嵌套集合表示 二叉树定义：二叉树是n(n≥0)个结点的有限集。它或为空树(n=0)，或由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树构成。 特点：1、每个结点至多有二棵子树(即不存在度大于2的结点)。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、二叉树的子树有左、右之分，且其次序不能任意颠倒。 基本形态：空二叉树，只有根结点，右子树为空，左子树为空，左、右子树均非空。 性质： 在二叉树的第 i 层上至多有 2^(i-1) 个结点 ( i ≥ 1 ) 。 高度为 k 的二叉树至多有 2^k -1 个结点 (k ≥ 1) 。 对任何一棵二叉树T，如果其叶结点数为n0 ，度为2的结点数为n2 ，则n0 = n2 + 1 。 具有 n 个结点的完全二叉树的高度为 (log2 n) + 1 。 如果对一棵有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i(1≤i≤n)，有： 如果 i=1 ，则结点 i 是二叉树的根，无双亲。 如果 i&gt;1 ，则其双亲是 i/2 。 如果 2i&gt;n ，则结点 i 无左孩子；如果 2i≤n ，则其左孩子是 2i 。 如果 2i+1&gt;n ，则结点 i 无右孩子；如果 2i+1≤n ，则其右孩子是 2i+1 。 特殊形式的二叉树满二叉树定义：一棵高度为 k 且有 2^k - 1 个结点的二叉树称为满二叉树。 特点，每一层上的结点数都是最大结点数。 完全二叉树定义：高度为 k ，有 n 个结点的二叉树，当且仅当其每一个结点都与高度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时，称为完全二叉树。 特点：1、叶子结点只可能在层次最大的两层上出现。2、对任一结点，若其右分支下子孙的最大层次为 L，则其左分支下子孙的最大层次必为 L 或 L+1 。 判断方法：1、根据特点2，若存在一个 k 层的完全二叉树，那么从 1 到 k-1 层必为满二叉树。2、根据定义，在完全二叉树第 k 层，从左往右必定依次与满二叉树的第 k 层一一对应，允许 k 层右端连续空缺，但不允许左端中途空缺。 二叉树的储存方法顺序存储思路：若存在两个数据，分别为树的父级和子级，位置为 i 和 j ，若子级位于左侧，其位置关系为：j = i × 2 ；若位于右侧，为： j = i × 2 + 1 方法参考代码public static class ArrayTree&lt;E&gt;{ //初始化数组 private final int totall = 3 * 3 - 1 ; //(height^2-1) private Object[] arraytree ; public ArrayTree(){ this.arraytree = new Object[totall]; } /** * 向树里添加第一个数据 * @param data 添加的数据 */ public void add(E data){ arraytree[1] = data ; } /** * 向树里添加数据 * @param data 添加的数据 * @param index 添加数据的父级的位置 * @param isLeft 是否在左侧 */ public void add(E data , int index , boolean isLeft){ //判断插入位置是否合法 if ( arraytree[index] == null ){ throw new RuntimeException(&quot;插入位置没有父级，不合法。&quot;); } //根据isLeft值赋予x值 int x ; if ( isLeft ){ x = 0; } else { x = 1 ; } //判断是否超出数组范围 if(2 * index + x &gt;= totall){ throw new RuntimeException(&quot;插入位置超出数组范围&quot;); } //在相应位置添加数据 arraytree[ 2 * index + x ] = data ; } /** * 输出 */ public void print(){ System.out.print(&quot;[&quot;); for ( int i = 0 ; i &lt; totall ; i++ ){ if ( i == totall - 1){ System.out.print(arraytree[i]+&quot;]&quot;); }else{ System.out.print(arraytree[i]+&quot;,&quot;); } } System.out.println(); } } ` 主函数测试public static void main(String[] args){ ArrayTree&lt;Integer&gt; arrtr = new ArrayTree&lt;&gt;(); arrtr.add(1); //arrtr.add(4, 2, true); arrtr.add(2, 1, true); arrtr.add(3, 1, false); arrtr.print(); arrtr.add(4, 2, true); arrtr.add(5, 2, false); arrtr.add(6, 3, true); arrtr.add(7, 3, false); arrtr.print(); //arrtr.add(8, 4, true); } 结果[null,1,2,3,null,null,null,null] [null,1,2,3,4,5,6,7] ` 优缺点优点:1、找双亲结点、子结点和兄弟结点容易。2、每个结点的存储空间不大。 缺点：当二叉树的高度和结点比例偏高时，内存利用率偏低，即可能存在大量空内存。 适用于静态数组，并且结点个数已知的完全二叉树或接近完全二叉树的二叉树。 链式存储个人最初的想法结点拥有三个部分：数据域，三个指向父级和左右子级的地址域。 参考方法代码//定义结点 public static class Node&lt;E&gt;{ private E data; private Node&lt;E&gt; fath; private Node&lt;E&gt; sonLeft ; private Node&lt;E&gt; sonRight ; //创建结点 public Node(E data , Node&lt;E&gt; fath , Node&lt;E&gt; sonLeft , Node&lt;E&gt; sonRight){ this.data = data ; this.fath = fath ; this.sonLeft = sonLeft ; this.sonRight = sonRight ; } //初始化结点 public Node(E data){ this(data,null,null,null); } } //用链表创建二叉树 public static class LinkedTree2&lt;E&gt;{ //创建并初始化头结点 private class Header{ private Node&lt;E&gt; next; public Header(Node&lt;E&gt; next){ this.next = next ; } } //创建二叉树 private Header header ; public LinkedTree2(){ header = new Header(null); } /** * 新增或更改第一个结点 * @param firNode 结点 */ public void addfir(Node&lt;E&gt; firNode){ //新增第一个结点 if(header.next == null){ header.next = firNode; //更改第一个结点 }else{ header.next.data = firNode.data ; } } /** * 添加结点 * @param node 添加的结点 * @param fath 父级结点 * @param isLeft 是否在左侧 */ public void add(Node&lt;E&gt; node , Node&lt;E&gt; fath , boolean isLeft){ node.fath = fath ; if(isLeft){ fath.sonLeft = node ; }else{ fath.sonRight = node ; } } } /** * 输出结点 * @param Node 需输出的结点 */ public static void printNode(Node&lt;Integer&gt; Node){ System.out.print(&quot;结点数据&quot;+Node.data); if (Node.fath != null) System.out.print(&quot;,父级为&quot;+Node.fath.data); if (Node.sonLeft != null) System.out.print(&quot;,左子级为&quot;+Node.sonLeft.data); if (Node.sonRight != null) System.out.print(&quot;,右子级为&quot;+Node.sonRight.data); System.out.println(); } ` 主函数测试public static void main(String[] args){ LinkedTree2&lt;Integer&gt; litree = new LinkedTree2&lt;&gt;(); Node&lt;Integer&gt; A = new Node&lt;&gt;(1); litree.addfir(A); printNode(A); Node&lt;Integer&gt; A1 = new Node&lt;&gt;(10); litree.addfir(A1); printNode(A1); Node&lt;Integer&gt; B = new Node&lt;&gt;(2); litree.add(B, A, true); Node&lt;Integer&gt; C = new Node&lt;&gt;(3); litree.add(C, A, false); printNode(A); printNode(B); printNode(C); Node&lt;Integer&gt; D = new Node&lt;&gt;(4); litree.add(D, B, true); Node&lt;Integer&gt; E = new Node&lt;&gt;(5); litree.add(E, B, false); printNode(D); Node&lt;Integer&gt; G = new Node&lt;&gt;(7); litree.add(G, C, false); printNode(C); } 结果结点数据1 结点数据10 结点数据10,左子级为2,右子级为3 结点数据2,父级为10 结点数据3,父级为10 结点数据4,父级为2 结点数据3,父级为10,右子级为7 参考方法代码//定义结点 public static class BTNode&lt;E&gt;{ private E data; private BTNode&lt;E&gt; sonLeft ; private BTNode&lt;E&gt; sonRight ; //创建结点 public BTNode(E data , BTNode&lt;E&gt; sonLeft , BTNode&lt;E&gt; sonRight){ this.data = data ; this.sonLeft = sonLeft ; this.sonRight = sonRight ; } //初始化结点 public BTNode(E data){ this(data,null,null); } } //二叉树的链表实现 public static class LinkedBTree&lt;E&gt; { //根结点 BTNode&lt;E&gt; root; public LinkedBTree(E data) { root = new BTNode&lt;E&gt;(data); } /** * 为指定结点添加子结点 * @param parent 需要添加节点的双亲结点的索引值 * @param data 新结点数据 * @param isLeft 是否添加左孩子 * @return 新增结点 */ public BTNode&lt;E&gt; add(BTNode&lt;E&gt; parent, E data, boolean isLeft) { if(parent == null) throw new RuntimeException(parent+&quot;结点为空，不能添加子结点!&quot;); BTNode&lt;E&gt; newNode = new BTNode&lt;&gt;(data); if (isLeft) { parent.sonLeft = newNode; } else { parent.sonRight = newNode; } return newNode; } public void printChild(BTNode&lt;E&gt; parent) { System.out.println(&quot;结点&quot; + getString(parent) + &quot;的孩子结点为：&quot; + getString(parent.sonLeft) + &quot;和&quot; + getString(parent.sonRight)); } private Object getString(BTNode&lt;E&gt; node) { if (node == null) { return &quot;空&quot;; } else { return node.data; } } } ` 主函数测试public static void main(String[] args){ LinkedBTree&lt;Character&gt; linkedBTree = new LinkedBTree&lt;&gt;(&#39;A&#39;); BTNode&lt;Character&gt; nodeB = linkedBTree.add(linkedBTree.root, &#39;B&#39;,true); BTNode&lt;Character&gt; nodeC = linkedBTree.add(linkedBTree.root, &#39;C&#39;,false); BTNode&lt;Character&gt; nodeD = linkedBTree.add(nodeB, &#39;D&#39;, true); BTNode&lt;Character&gt; nodeE = linkedBTree.add(nodeB, &#39;E&#39;, false); BTNode&lt;Character&gt; nodeF = linkedBTree.add(nodeC, &#39;F&#39;, false); BTNode&lt;Character&gt; nodeG = linkedBTree.add(nodeE, &#39;G&#39;, true); // 测试，输出某个结点的孩子结点 linkedBTree.printChild(nodeF); } ` 结果结点F的孩子结点为：空和空 特点找儿子容易,找双亲结点难。（可用三叉列表） 一般来说，适用于任何的二叉树。 5.12日补充。 树、森林与二叉树的关系树、森林与二叉树的转换由于二叉树简单，并且其构造等方法成熟，所以在非二叉树和森林中，往往会先将其转化为二叉树。 树转换成二叉树以该树为例。 步骤1：加线——在兄弟结点之间加一连线。 步骤2：抹线——对每个结点，除了保留其第一个孩子的连线外，去除其与其余孩子之间的连线。 步骤3：旋转——以树的根结点为轴心，将整树顺时针转45°。 特点：用该方法将树转换成的二叉树其右子树一定为空。 森林转换成二叉树 将各棵树分别转换成二叉树。 将每棵树的根结点用线相连。 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构。 以图示例。 二叉树转换成树 1、加线。 若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，……沿分支找到的所有右孩子，都与p的双亲用线连起来。 2、抹线。 抹掉原二叉树中双亲与右孩子之间的连线。 3、调整。 将结点按层次排列，形成树结构。 以图示例。 树的遍历 遍历 按一定规律走遍树的各个顶点，且使每一顶点仅被访问一次，即找一个完整而有规律的走法，以得到树中所有结点的一个线性排列。 常用方法 ⚪先根遍历 先访问树的根结点，然后依次先根遍历根的每棵子树。 ⚪后根遍历 先依次后根遍历每棵子树，然后访问根结点。 ⚪层次遍历 先访问第一层上的结点，然后依次遍历第二层，……第n层的结点。 以图中的树为例： 先根遍历: A B E F I G C D H J K L N O M 后根遍历: E I F G B C J K N O L M H D A 层次遍历: A B C D E F G H I J K L M N O","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（7）——数组","slug":"数据结构笔记7","date":"2020-04-03T01:45:00.000Z","updated":"2020-06-16T11:41:04.452Z","comments":true,"path":"2020/04/03/数据结构笔记7/","link":"","permalink":"/2020/04/03/数据结构笔记7/","excerpt":"","text":"定义数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 特点数组是相同类型数据元素的有限集合。数组中的各个分量称为数组元素。每个数组元素值可以用数组名和一个下标值唯一的确定。 由于数组中各元素具有统一的类型，并且数组元素的下标一般具有固定的上界和下界，因此，数组的处理比其它复杂的结构更为简单。多维数组是向量的推广。 数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。 数组的顺序存储结构数组元素是连续存放的，因此采用顺序存储结构。无论几维数组,在计算机中都是按一维数组来存放。 假定存在一个二维数组A m×n （m行n列） ，L是每个元素所占的存储单元。按行优先顺序存储结构：LOC(a ij)=LOC(a 00)+(i×n+j)×L按列优先顺序存储结构：LOC(a ij)=LOC(a 00)+(j×m+i)×L 假定存在一个三维数组A m×n×p （m页n行p列），L是每个元素所占的存储单元。 数组的压缩存储相同值的多个元素占用一个存储单元，零元素不分配存储单元。以下例子的每个元素存储大小为1。 对称矩阵按行优先顺序存放对称矩阵的存储 示例矩阵 在计算机中存储形式 每个元素存储位置 三角矩阵以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵的下三角(不包括主对角线)中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。大多数情况下，常数为0。 下三角矩阵按行优先顺序存放下三角矩阵的存储。 示例矩阵 在计算机中存储形式 每个元素存储位置 上三角矩阵按行优先顺序存放上三角矩阵的存储 示例矩阵 在计算机中存储形式 每个元素存储位置 带状矩阵对角矩阵中，所有的非零元素集中在以主对角线为中心的带状区域中，即除了主对角线和主对角线相邻两侧的若干条对角线上的元素之外，其余元素皆为零。 按行优先顺序存放带状矩阵的存储。 示例矩阵 在 a ij 之前有 i 行，共有 （3×i-1）个非零元素，在第 i 行，有（j-i+1）个非零元素。这样，非零元素 a ij 的地址为： k=3×i-1+(j-i+1)=2i+j 稀疏矩阵稀疏矩阵中有s个非零元素，且s远远小于矩阵元素的总数（即s≦m×n）。 示例矩阵 在计算机中存储形式","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（6）——队列","slug":"数据结构笔记6","date":"2020-03-31T01:45:00.000Z","updated":"2020-06-16T11:40:59.158Z","comments":true,"path":"2020/03/31/数据结构笔记6/","link":"","permalink":"/2020/03/31/数据结构笔记6/","excerpt":"","text":"概念、特性队列是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。 允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。 特性：先进先出。 关于队列满、空的三种判断方法由于用数组创建的非循环队列会出现“假溢出”的问题——即一方面队列为空，另一方面出现溢出，所以之后以循环队列为例。 判断空和满的举例仅作参考。毕竟参考代码用的是最简单的计数。 使用计数器记录队列中的元素个数。 判断满：count&gt;0 &amp;&amp; rear==front 判断空：count==0 假设标志，出队时置为0，入队时置为1，则可识别当前front=rear属于何种情况 判断满：tag==1 &amp;&amp; rear==front 判断空：tag==0 &amp;&amp; rear==front 少用一个存储单元 判断满：front==(rear+1)%size 判断空：rear==front 用数组创建队列参考代码以循环队列为例。 方法参考代码//用数组创建队列 public static class QueueArray&lt;E&gt;{ //设定队列，队的容量，前端和后端，元素数量。 //前端为队头元素位置，后端下标为队尾元素后一个位置。 private int size = 5 ; private Object[] que_arr ; private int front ; private int rear ; private int count ; //初始化队列 public QueueArray(){ que_arr =new Object [size] ; this.front = 0 ; this.rear = 0 ; this.count = 0; } /** * 入队 * @param data */ public void In(E data){ //判断是否队满 if (count == size){ throw new RuntimeException(&quot;队满&quot;); } //添加数据，元素总数+1 que_arr[rear] = data ; ++count; //队尾标号的后移 if (rear+1 &gt;= size){ rear = 0; }else{ ++rear; } } /** * 出队 * @return 队头的元素 */ public Object Out(){ //判断是否队空 if (count == 0){ throw new RuntimeException(&quot;队空&quot;); } //数据的输出和清空 Object data = que_arr[front]; que_arr[front] = null ; //元素总数-1 --count; //队首标号的后移 if (front+1 &gt;= size){ front = 0; }else{ ++front; } return data; } /** * 打印 */ public void print(){ System.out.print(&quot;[&quot;); for (int i = 0 ; i&lt;size ; i++){ if (i == size-1){ System.out.print(que_arr[size-1]+&quot;]&quot;); }else{ System.out.print(que_arr[i]+&quot;,&quot;); } } System.out.println(&quot;count:&quot;+count+&quot; front:&quot;+front+&quot; rear:&quot;+rear); } } 主函数测试 //主函数测试 public static void main(String[] args){ QueueArray&lt;Object&gt; queue = new QueueArray&lt;&gt;(); //queue.Out(); queue.In(1); queue.In(2); queue.In(3); queue.print(); queue.Out(); queue.print(); queue.In(4); queue.In(5); queue.In(6); //queue.In(7); queue.print(); queue.Out(); queue.Out(); queue.Out(); queue.print(); queue.In(7); queue.Out(); queue.Out(); queue.print(); } ` 输出结果 用链表创建队列参考代码以循环队列为例。 但目前还没有感觉到循环和不循环各有什么优势。 方法参考代码//用链表创建队列 public static class QueueLinked&lt;E&gt;{ private int size; private Node header; //创建指向链表末端结点的指针 Node p; //初始化链表 public QueueLinked(){ header = new Node(); size = 0 ; p = header; } //创建结点 public class Node{ //创建数据域和地址域 private E data; private Node next; //构建方法使结点元素的改变 public Node(E data,Node next){ this.data = data; this.next = next; } //初始化结点 public Node(){ this(null,null); } } /** * 入队 * @param data 需要入队的数据 */ public void In(E data){ //创建结点 Node newnode = new Node(); //赋予数据 newnode.data = data; //将结点添加到当前链表末端之后 p.next = newnode; //p指向新结点，其地址域指向队首 p = newnode; newnode.next = header.next; //结点数+1 ++size; } public E Out(){ //判断队列是否为空 if (size == 0){ throw new RuntimeException(&quot;队空&quot;); } //创建指针指向删除的结点 Node del = header.next; //队首数据输出 E data = del.data; //删除队首结点 //如果队列中只有一个结点，头结点地址域null if (size == 1){ header.next = null ; //否则头结点地址域指向第二个结点 }else{ header.next = del.next; } //队尾地址域指向新队首 p.next = header.next; //将删除的结点清空 del.data = null ; del.next = null ; //总数-1 --size; //返回队首数据 return data; } /** * 打印 */ public void print(){ Node q = header.next; for (int i = 0 ; i&lt;size ; i++){ if (i == size-1){ System.out.print(q.data); }else{ System.out.print(q.data+&quot;,&quot;); q = q.next; } } System.out.println(&quot;——size:&quot;+size+&quot; ; p.next:&quot;+p.next.data); } } 主函数测试//主函数测试 public static void main(String[] args){ QueueLinked&lt;Object&gt; queue2 = new QueueLinked&lt;&gt;(); //queue2.Out(); queue2.In(1); queue2.In(2); queue2.In(3); queue2.print(); queue2.Out(); queue2.Out(); queue2.print(); } ` 输出结果","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（5）——栈应用","slug":"数据结构笔记5","date":"2020-03-24T01:45:00.000Z","updated":"2020-06-16T11:40:54.546Z","comments":true,"path":"2020/03/24/数据结构笔记5/","link":"","permalink":"/2020/03/24/数据结构笔记5/","excerpt":"","text":"表达式括号匹配利用栈判断表达式中括号是否匹配，但这只能判断括号的数目正确，像是“1+(2+3(4/)5)”这类就无法判断。 其实这类问题可以不用栈，直接通过数左括号和右括号的数目来判断。 表达式求值这里有三种表达式：前缀表达式（波兰表达式）、中缀表达式、后缀表达式（逆波兰表达式）。 中缀表达式就是生活中常见的表达式，如：1+2*3 由于中缀表达式对于人能较好理解，但对于计算机来讲难以处理，而后缀表达式则容易处理。后缀表达式如：123*+ 前缀表达式相较于后缀来说，用得就少了些，如：+1*23 部分参考思路关于中缀转后缀表达式，以及后缀表达式的计算，这位大神的文章已经讲得很详细了。 链接在此 中缀转后缀表达式这里就只列出中缀转后缀的代码的参考，首先是因为似乎用的比较多，其次其他的转换可以根据此推出，毕竟转换的思路前辈们都已帮我们确定了下来。 关于java.util.Stack之前找到java有关于栈的类，所以参考代码就直接引用。 实际上这个类存在许多问题，毕竟这是Vector动态数组的子类，但用在这里是没什么大问题。 Stack类是Vector的一个子类，它实现了一个标准的后进先出的栈。 以下为参考函数中使用的类中带有的方法。 boolean empty()检测堆栈是否为空。 Object peek()查看堆栈顶部的对象，但不从堆栈中移除它。 Object pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 Object push(Object element)把项压入堆栈顶部。 参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 导入的类 import java.util.Stack; import java.util.ArrayList; //输入 import java.util.Arrays; import java.util.Scanner; ` 中缀转后缀表达式代码 /** * 中缀表达式转化为后缀表达式 * @param infix 中缀表达式列表 * @return 后缀表达式列表 */ public static ArrayList&lt;String&gt; InfixToSuffix(ArrayList&lt;String&gt; infix){ //创建后缀表达式表 ArrayList&lt;String&gt; suffix = new ArrayList&lt;String&gt;(); //创建符号栈 Stack&lt;String&gt; operator = new Stack&lt;&gt;(); //对原中缀表达式进行循环 for (int i = 0 ; i &lt; infix.size() ; i++){ String item = infix.get(i); //如果是数字，直接入表 if (isNum(item)){ suffix.add(item); //如果是括号 }else if (&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item)){ //如果为（，直接入栈 if (&quot;(&quot;.equals(item)){ operator.push(item); //如果是），从栈顶依次向下出栈入表，直到遇到（ }else{ while (true){ //遇到（，只出栈，并跳出循环 if(&quot;(&quot;.equals(operator.peek())){ operator.pop(); break; //遇到其他符号，出栈入表 }else{ suffix.add(operator.pop()); } } } //如果遇到操作符 }else{ //如果栈为空栈，或当前符号权重大于前一个，入栈 if(operator.isEmpty() || heavy(item) &gt; heavy(operator.peek())){ operator.push(item); //若当前符号权重小于前一个，循环元素出栈入表，直至空栈，或遇到权重更小的操作符或（ }else{ while (!operator.isEmpty() &amp;&amp; !&quot;(&quot;.equals(operator.peek())){ if(heavy(item) &lt;= heavy(operator.peek())){ suffix.add(operator.pop()); } } //当前操作符压栈 operator.push(item); } } } //如果最后一个是括号，会导致输出结果多出空的字符串 for (int i = 0 ; i&lt;suffix.size() ; i++){ if (&quot;&quot;.equals(suffix.get(i))){ suffix.remove(i); } } //循环完毕，若栈不为空，依次出栈入表。 while (!operator.isEmpty()){ suffix.add(operator.pop()); } return suffix; } /** * 符号权重 * @param item 符号 * @return 权重int */ private static int heavy(String item) { int heavy; if (&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item) ){ heavy = 0 ; }else if(&quot;+&quot;.equals(item) || &quot;-&quot;.equals(item)){ heavy = 1 ; }else if(&quot;*&quot;.equals(item) || &quot;/&quot;.equals(item)){ heavy = 2; }else{ throw new IndexOutOfBoundsException (&quot;存在没有设置权重的字符&quot;); } return heavy; } /** * 判断字符串是否为数字 * @param str 需判断的字符串 * @return true/false */ public static boolean isNum(String str){ for (int i = 0 ; i&lt;str.length() ; i++){ if (!Character.isDigit(str.charAt(0))){ return false; } } return true; } /** * 字符串转化为ArrayList * @param str 需转换的字符串 * @return ArrayList */ public static ArrayList&lt;String&gt; StringToList(String str){ //创建列表 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); String digit = &quot;&quot;; //对字符串进行循环 for (int i = 0 ; i &lt; str.length() ; i++){ //储存当前循环的字符 String item = String.valueOf(str.charAt(i)); //如果是数字或小数点，储存到digit中 if (isNum(item) || &quot;.&quot;.equals(item)){ digit+=String.valueOf(item); //如果是符号 }else if(&quot;(&quot;.equals(item) || &quot;)&quot;.equals(item) || &quot;+&quot;.equals(item) || &quot;-&quot;.equals(item) || &quot;*&quot;.equals(item) || &quot;/&quot;.equals(item)) { //如果是第一个，即（，直接入表 if (i==0){ list.add(String.valueOf(item)); //否则将前一个数字入表，随后符号入表 }else{ if (!&quot;&quot;.equals(digit)){ list.add(digit); digit = &quot;&quot;; } list.add(String.valueOf(item)); } }else{ throw new IndexOutOfBoundsException (&quot;非法字符&quot;); } } //循环完毕，若还有储存的数字，入表。 list.add(String.valueOf(digit)); return list; } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); ArrayList&lt;String&gt; suffix = InfixToSuffix(infix); System.out.print(&quot;中缀转化后缀为：&quot;); for (int i = 0 ; i &lt; suffix.size() ; i++){ if (i == suffix.size()-1){ System.out.print(suffix.get(i)); continue; } System.out.print(suffix.get(i)+&quot;,&quot;); } System.out.println(); } 后缀表达式计算参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 /** * 根据后缀表达式suffix计算结果 * @param suffix 后缀表达式列表 * @return 结果 */ private static Double calculate(ArrayList&lt;String&gt; suffix) { //创建数字栈 Stack&lt;String&gt; number = new Stack&lt;&gt;(); //对列表中元素进行循环 for(int i=0; i&lt;suffix.size(); i++){ String item = suffix.get(i); //如果是数字，入栈 if(isNum(item)){ number.push(item); //如果是符号，取栈顶两个元素，运算后入栈 }else { //String → double double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); double result = 0; if(item.equals(&quot;+&quot;)){ result = num1 + num2; }else if(item.equals(&quot;-&quot;)){ result = num1 - num2; }else if(item.equals(&quot;*&quot;)){ result = num1 * num2; }else if(item.equals(&quot;/&quot;)){ result = num1 / num2; }else { throw new RuntimeException(&quot;非法符号&quot;); } //double → String number.push(String.valueOf(result)); } } //返回计算结果 return Double.parseDouble(number.pop()); } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); ArrayList&lt;String&gt; suffix = InfixToSuffix(infix); System.out.print(&quot;最终结果：&quot;+orgexp+&quot;=&quot;+calculate(suffix)); } 中缀表达式计算参考代码注：参考代码虽支持正的小数和两位数，但其他可能依然存在问题。 /** * 两个数字之间的运算 * @param x1 数字1 * @param x2 数字2 * @param item 运算符号 * @return 结果 */ private static double calculate(double x1,double x2,String item){ //定义结果 double result ; //根据运算符对两个数字进行运算 if (item.equals(&quot;+&quot;)){ result = x1+x2; }else if (item.equals(&quot;-&quot;)){ result = x1-x2; }else if (item.equals(&quot;*&quot;)){ result = x1*x2; }else if (item.equals(&quot;/&quot;)){ result = x1/x2; }else{ throw new IndexOutOfBoundsException (&quot;表达式非法&quot;); } //返回 return result; } /** * 中缀表达式的运算 * @param infix 中缀表达式的列表 * @return 结果 */ public static double InFixOperation(ArrayList&lt;String&gt; infix){ //定义数字和操作符的栈 Stack&lt;String&gt; number = new Stack&lt;&gt;(); Stack&lt;String&gt; operator = new Stack&lt;&gt;(); //对中缀表达式进行循环 for (int i = 0 ; i&lt;infix.size() ; i++){ //当前循环的符号 String item = infix.get(i); //如果是数字，直接入数字栈 if (isNum(item)){ number.push(item); //否则就是操作符 }else{ //如果是），将前面的数字和符号依次从后往前运算，直至（，并将结果入数字栈 if (&quot;)&quot;.equals(item)){ while (!operator.peek().equals(&quot;(&quot;)){ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); } operator.pop(); //如果是（，或操作栈为空，或当前运算符权重大于前者，直接入操作符栈 }else if (&quot;(&quot;.equals(item) || operator.isEmpty() || heavy(item)&gt;heavy(operator.peek()) ){ operator.push(item); //否则，将前两个数字进行符号运算，结果入数字栈，操作符入操作栈 }else{ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); operator.push(item); } } } //循环完毕，若符号栈不为空，则从后往前运算，并将结果入数字栈 if (!operator.isEmpty()){ double num2 = Double.parseDouble(number.pop()); double num1 = Double.parseDouble(number.pop()); String oper = operator.pop(); number.push(String.valueOf(calculate(num1,num2,oper))); } //返回结果 return Double.parseDouble(number.pop()); } 主函数测试 public static void main(String[] args){ //输入 //Scanner sc = new Scanner(System.in); //String orgexp = sc.nextLine(); String orgexp=&quot;(0*1)+((2.5+3)*4.5)-50&quot;; ArrayList&lt;String&gt; infix = StringToList(orgexp); System.out.print(&quot;最终结果：&quot;+orgexp+&quot;=&quot;+InFixOperation(infix)); }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（3.5）——双向链表","slug":"数据结构笔记3.5","date":"2020-03-20T01:45:00.000Z","updated":"2020-06-16T11:40:37.220Z","comments":true,"path":"2020/03/20/数据结构笔记3.5/","link":"","permalink":"/2020/03/20/数据结构笔记3.5/","excerpt":"","text":"总体思路与单向链表类似，直接给出参考代码。 注：参考代码中各个算法均包含在类中. 单链表部分算法 链表定义//创建链表 public static class DouLinkedList&lt;E&gt; { //链表结点数据类型定义 public class Node{ //数据域，保存数据元素 public E data; //地址域，保存前后结点地址 public Node next; public Node pre; //构造结点，指定数据元素和后继结点 public Node(E data, Node next , Node pre){ this.data = data; this.next = next; this.pre = pre; } //初始化结点 public Node() { this(null,null,null); } } //链表大小 private int num = 0; //链表头结点 Node header; public DouLinkedList() { header = new Node(); } /**查找指定位置结点 * * @param n 位置 * @return 结点 */ private Node findNode(int n) { Node p = header; for (int i = 1; i &lt;= n; ++i) { p = p.next; } return p; } /** 代码6：打印顺序表 * **/ public void print() { System.out.print(&quot;顺序表长度为:&quot;+num+&quot;,内部元素为:&quot;); Node p = header; for (int i = 0; i &lt; num; i++){ p = p.next; System.out.print(p.data + &quot; &quot;); } System.out.println(); } } 插入算法 /**判断插入位置是否合法 * * @param n 插入位置 */ private void Check(int n) { if (n &lt;= 0 || n &gt; num+1) { throw new IndexOutOfBoundsException (&quot;插入位置不合法！&quot;); } } /**在链表头部插入 * * @param data 插入数据 */ public void addFirst(E data) { //如果是空表 if (num == 0){ addLast(data); return; } //创建一个新结点 Node newNode = new Node(); //将新结点和原结点的next和pre域指向相应结点 newNode.next = header.next; header.next.pre = newNode; header.next = newNode; //输入数据 newNode.data = data; //长度+1 ++num; } /**在链表尾部插入 * * @param data 插入数据 */ public void addLast(E data) { //创建一个新结点 Node newNode = new Node(); //找到最后一个结点p Node p = findNode(num); //各地址域指向相应结点 p.next = newNode; newNode.pre = p; //输入数据 newNode.data = data; //链表长度+1 ++num; } /** 在链表指定 n位置前插入结点 * * @param n 插入位置，从1计数 * @param data 插入元素 **/ public void add(int n, E data) { //判断插入位置是否合法 Check(n); if (n == 1) { addFirst(data); return; } if (n == num+1) { addLast(data); return; } //创建一个新结点 Node newNode = new Node(); //找到插入位置n前后的结点p,q Node p = findNode(n-1); Node q = findNode(n); //地址域指向相应 p.next = newNode; newNode.pre = p; newNode.next = q; q.pre = newNode; //输入数据 newNode.data = data; //链表长度+1 ++num; } 删除算法/** 删除链表第一个结点 * */ public void removeFirst() { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } //如果只有一个结点 if (num==1){ removeLast(); return; } //取得第一个结点p Node p = header.next; //相应地址域的改变 p.next.pre = null; header.next = p.next; p.next = null; p.pre = null; //链表长度-1 --num; } /**删除链表尾元素 * */ public void removeLast() { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空!&quot;); } //取得倒数第二个结点p,以及最后一个结点q Node p = findNode(num - 1); Node q = p.next; //相应地址域的改变 p.next = null; q.pre = null; //长度-1 --num; } /** 删除链表指定位置的结点 * * @param n 删除位置 **/ public void remove(int n) { //判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } //判断删除位置是否合法 CheckForRemove(n); if (n == 0) { removeFirst(); return; } if (n == num) { removeLast(); return; } //找到删除位置n前后的结点p、r，以及删除位置index的结点q Node p = findNode(n-1); Node q = p.next; Node r = q.next; //相应地址域改变 p.next = r; r.pre = p; q.next = null; q.pre = null; //链表长度-1 --num; } /** 判断删除位置是否合法 * * @param n 删除位置 **/ private void CheckForRemove(int n) { if (n &lt;= 0 || n &gt; num) { throw new IndexOutOfBoundsException(&quot;删除位置不合法！&quot;); } } 主函数测试public static void main(String[] args) { DouLinkedList&lt;Integer&gt; linkedList = new DouLinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); // 删除第一个元素 linkedList.removeFirst(); linkedList.print(); // 在链表中间删除元素 linkedList.remove(3); linkedList.print(); // 删除最后一个元素 linkedList.removeLast(); linkedList.print(); }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（4）——栈","slug":"数据结构笔记4","date":"2020-03-17T01:45:00.000Z","updated":"2020-06-16T11:40:47.524Z","comments":true,"path":"2020/03/17/数据结构笔记4/","link":"","permalink":"/2020/03/17/数据结构笔记4/","excerpt":"","text":"栈的相关概念➢栈：限定仅在表尾进行插入或删除操作的线性表。 ➢栈的特点：先进后出（FILO）或后进先出（LIFO）。 ➢栈的举例：子程序的嵌套、阶乘问题（递归问题）。 栈的操作注：参考代码中各个算法均包含在类中. 利用数组创建栈定义栈/**用数组创建栈 */ public static class Stack&lt;E&gt; { //初始化栈的最大容量为100 private static final int totall = 100; private Object[] datas; //n记录目前堆栈数据数量的变量 private int n; //初始化堆栈 public Stack() { this.n = 0; this.datas = new Object[totall]; } //打印链表 public void print(){ System.out.print(&quot;n=&quot;+n+&quot; 元素依次为：&quot;); for (int i = 0; i &lt;= n-1; i++){ System.out.print(datas[i]+&quot; &quot;); } System.out.println(); } } 入栈 /** 入栈 * @param data 入栈元素 **/ public void In(E data) { // 判断栈是否满 if (n == totall) { throw new RuntimeException(&quot;栈满，无法插入新元素!&quot;); } datas[n] = data; n++; } /**在栈底部增加 * * @param data 增加的数据 */ public void ButtonIn(E data){ //判断是否为空栈 if(this.n==0){ this.In(data); return; } // 判断栈是否满 if (this.n == totall) { throw new RuntimeException(&quot;栈满，无法插入新元素!&quot;); } //创建一个新过渡栈和过渡数据 Stack&lt;E&gt; stack1 =new Stack&lt;&gt;(); E data1; //取得增加前栈的数据数量 int n = this.n; //依次将原始栈中元素增加到过渡栈中 for(int i=0;i&lt;n;i++){ data1 = this.Out(); stack1.In(data1); } //此时原始栈为空，在原始栈增加data this.In(data); //将过渡栈中的数据增加到原始栈中 for(int i = 0; i&lt;n; i++){ data1 =(E) stack1.Out(); this.In(data1); } } ` 出栈/** 出栈 * * @return 返回栈顶元素 * **/ public E Out() { // 判断栈是否为空 if (n==0) { throw new RuntimeException(&quot;出栈顶失败，因为此时栈中没有元素！&quot;); } E topdata = (E) datas[n-1]; n--; return topdata; } /** 删除栈的底部元素 * */ public void ButtonOut(){ //判断是否为空栈 if(this.n==0){ throw new RuntimeException(&quot;出栈顶失败，因为此时栈中没有元素！&quot;); } // 判断栈是否只有一个元素 if (n == 1) { this.Out(); return; } //创建一个新过渡栈和过渡数据 Stack&lt;E&gt; stack1 =new Stack&lt;&gt;(); E data1; //取得减少前栈的数据数量 int n = this.n-1; //依次将原始栈中元素增加到过渡栈中 for(int i=0;i&lt;n;i++){ data1 = this.Out(); stack1.In(data1); } //此时原始栈只有一个元素，删除 this.Out(); //将过渡栈中的数据增加到原始栈中 for(int i = 0; i&lt;n; i++){ data1 =(E) stack1.Out(); this.In(data1); } } 主函数测试public static void main(String[] args){ Stack&lt;Integer&gt; stack =new Stack&lt;&gt;(); stack.In(4); stack.In(5); stack.In(6); stack.In(7); stack.In(8); stack.In(7); stack.In(6); stack.print(); Object x=stack.Out(); stack.print(); stack.ButtonIn(9); stack.print(); stack.ButtonOut(); stack.print(); } 利用链表创建栈定义栈//用链表创建栈 public static class Stuck&lt;E&gt;{ //创建结点 public class Node{ //创建结点的数据域和地址域 public E data; public E next; //添加方法修改结点 public Node(E data,E next){ this.data = data; this.next = next; } //初始化结点 public Node(){ this(null,null); } } //初始栈的大小 private final int totall = 100; //初始化当前栈占用的大小 private int num = 0; //创建头结点 Node header; //创建新栈 public Stuck(){ header = new Node(); } /** 查找指定位置的结点 * * @param n 查找位置 * @return 该位置结点 */ public Node FindNode(int n){ //创建新结点 Node thenode = header; //循环查找 for (int i = 0 ; i&lt;n ; i++){ thenode = (Stuck&lt;E&gt;.Node) thenode.next; } //返回 return thenode; } //打印 public void print(){ System.out.print(&quot;栈中数据数目num=&quot;+num+&quot; 分别为：&quot;); Node p = (Stuck&lt;E&gt;.Node) header.next; for (int i = 1 ; i &lt;= num ; i++){ System.out.print(p.data+&quot; &quot;); p = (Stuck&lt;E&gt;.Node) p.next; } System.out.println(); } } 入栈/** 在栈顶部添加数据 * * @param data 添加的数据 */ public void In(E data){ //检查是否栈满 if (num == totall-1){ throw new IndexOutOfBoundsException (&quot;栈满。&quot;); } //创建一个新结点 Node node = new Node(); //输入数据 node.data = data; //找到当前顶部结点 Node topnode = FindNode(num); //将顶部结点的next指向新结点 topnode.next = (E) node; //数目+1 ++num; } /** 在栈底部添加数据 * * @param data 添加的数据 */ public void InButtom(E data){ //检查是否栈满 if (num == totall-1){ throw new IndexOutOfBoundsException (&quot;栈满。&quot;); } //检查是否空栈 if (num == 0){ this.In(data); return; } //创建一个新结点 Node node = new Node(); //输入数据 node.data = data; //创建一个过渡栈 Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); //用循环将当前栈里元素移动到过渡栈中 int n = num; for (int i = 1 ; i&lt;=n ; i++){ stuck.In((Integer) this.Out()); } //此时原栈为空，增加新数据 this.In(data); //用循环将过渡栈里数据返回 for (int i = 1 ; i&lt;=n ; i++){ this.In((E) stuck.Out());; } } 出栈/**删除顶部数据 * * @return 顶部数据 */ public E Out(){ //判断是否为空 if (num == 0){ throw new IndexOutOfBoundsException (&quot;栈空。&quot;); } //找到顶端的两个结点 Node p = FindNode(num); Node q = FindNode(num-1); //将顶部的结点数据赋给其他变量，并删除 E data = p.data; p.data = null; //将第二顶端的结点地址域指向null q.next = null; //数目-1 --num; //返回删除数据 return data; } /** 在栈底部删除数据 * * @return 删除的数据 */ public E OutButtom(){ //检查是否空栈 if (num == 0){ throw new IndexOutOfBoundsException (&quot;栈空。&quot;); } //检查是否只有一个数据 if (num == 1){ return this.Out(); } //创建一个过渡栈 Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); //用循环将当前栈里元素移动到过渡栈中 int n = num-1; for (int i = 1 ; i&lt;=n ; i++){ stuck.In((Integer) this.Out()); } //此时原栈只有一个数据，删除数据 E data = this.Out(); //用循环将过渡栈里数据返回 for (int i = 1 ; i&lt;=n ; i++){ this.In((E) stuck.Out());; } //返回 return data; } 主函数测试public static void main(String[] args){ Stuck&lt;Integer&gt; stuck = new Stuck&lt;&gt;(); stuck.In(1); stuck.In(2); stuck.In(3); stuck.In(4); stuck.print(); stuck.Out(); stuck.print(); stuck.InButtom(0); stuck.print(); Object x = stuck.OutButtom(); System.out.println(x); stuck.print(); } 两栈共享对两栈共享情况来说，将两个栈底分别设在两端， 两个栈顶指针 top1 和 top2 相对中间位置动态移动，两个栈之间的分界线是不定的。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（3）——线性表链式储存结构","slug":"数据结构笔记3","date":"2020-03-10T01:45:00.000Z","updated":"2020-06-16T11:40:42.093Z","comments":true,"path":"2020/03/10/数据结构笔记3/","link":"","permalink":"/2020/03/10/数据结构笔记3/","excerpt":"","text":"相关概念结点：数据元素的存储映像。由数据域和地址域两部分组成。➢ 数据域：元素本身信息➢ 地址域：指示直接后继的存储位置 链表：n个结点由地址域组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。➢ 链表种类：单链表、双链表、多链表、循环链表。 有关头结点的作用：为了对链表进行操作时，可以对空表、非空表的情况以及对首元素节点进行统一处理，编程更方便。 特点1、用一组任意的存储单元存储线性表的数据元素，易插入和删除。2、利用指针实现了用不相邻的存储单元存放逻辑上相邻的元素。3、存储结构较复杂，每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息结点。4、不需要预先分配空间。 适用于：频繁需要插入、删除数据的线性表。 单链表算法注：参考代码中各个算法均包含在类中. 插入算法总体参考思路首先定义一个单链表，在单链表中定义结点，结点包括两个属性：数据和地址，再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义六个函数。 判断插入位置是否合法 rangeCheckForAdd(int index) 头部增加元素 addFirst(E data) 在指定位置增加元素 add(int index, E data) 尾部增加元素 addLast(E data) 查找指定位置前的元素 findNode(int index) 打印链表 print() 代码参考 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node header; public LinkedList() { header = new Node(); } //单链表结点数据类型定义 public class Node{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node next; //构造结点，指定数据元素和后继结点 public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(null,null); } } /** 代码3： 在链表中间指定 index 位置前插入结点 * @param index 插入位置，从0计数 * @param data 插入元素 **/ public void add(int index, E data) { // 1. 判断插入位置是否合法 rangeCheckForAdd(index); if (index == 0) { addFirst(data); return; } if (index == size) { addLast(data); return; } // 2. 创建一个新结点 Node newNode = new Node(); // 3. 找到插入位置index前的结点p Node p = findNode(index); // 4. 将新结点的next域指向p结点的next域 newNode.next = p.next; // 5. 将p结点的next域指向新结点 p.next = newNode; // 6. 输入数据 newNode.data = data; // 7. 链表长度+1 ++size; } /** 代码2： 在链表头部插入结点 * @param data 插入元素 **/ public void addFirst(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 将新结点的next域指向为header结点的next域 newNode.next = header.next; // 3. 将header结点指向新结点 header.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码4 在链表尾部插入结点 * @param data 插入元素 **/ public void addLast(E data) { // 1. 创建一个新结点 Node newNode = new Node(); // 2. 找到最后一个结点q Node q = findNode(size); // 3. 将q结点的next域指向新结点 q.next = newNode; // 4. 输入数据 newNode.data = data; // 5. 链表长度+1 ++size; } /** 代码1：判断插入位置是否合法 * @param index 插入位置 **/ private void rangeCheckForAdd(int index) { if (index &lt; 0 || index &gt; size) { throw new IndexOutOfBoundsException (&quot;插入位置不合法！&quot;); } } /** 代码5：找到指定位置index前的结点P * @param index 插入位置，从0计数 * @return 指定位置结点 **/ private Node findNode(int index) { Node p = header; for (int i = 0; i &lt; index; ++i) { p = p.next; } return p; } /** 代码6：打印顺序表 * @param index 插入位置，从0计数 * @return 指定位置结点 **/ public void print() { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); Node p = header; for (int i = 0; i &lt; size; i++){ p = p.next; System.out.print(p.data + &quot; &quot;); } System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); } 其他思路同样定义一个单链表，在单链表中定义结点，结点在存储数据的空间中专门拿出一部分储存地址信息，再在单链表类中定义与插入有关的各种方法。 以下给出创建类和内部类的方法，其他方法视情况修改。 //创建单链表 public class LinkedList&lt;E&gt; { //链表大小 private int size = 0; //链表头结点 Node&lt;E&gt; header; public LinkedList() { header = new Node&lt;&gt;(); } //单链表结点数据类型定义 public class Node&lt;E&gt;{ //数据域，保存数据元素 public E data; //地址域，保存后继结点地址 public Node&lt;E&gt; next; //构造结点，指定数据元素和后继结点 public Node(E data, Node&lt;E&gt; next){ this.data = data; this.next = next; } public Node() { this(null,null); } } } 删除算法总体参考思路与上文插入算法类似，只是再在单链表类中定义与插入有关的各种方法。 定义一个类 LinkedList&lt;E&gt; 以及一个内部类 Node。定义五个函数。 删除头部元素 removeFirst() 删除尾部元素 removeLast() 删除指定位置的元素 remove(int index) 判断删除位置是否合法 rangeCheckForRemove(int index) 打印链表 print() 代码参考 //定义类与上文相同 public class LinkedList&lt;E&gt; { private int size = 0; Node header; public LinkedList() { header = new Node(); } public class Node{ public E data; public Node next; public Node(E data, Node next){ this.data = data; this.next = next; } public Node() { this(0,null); } } /** 代码1 删除链表第一个结点 **/ public void removeFirst() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 取得第一个结点p Node p = header.next; // 3. 将 header 的 next 域指向p结点的 next域 header.next = p.next; // 4. 将p结点的 next 域设为 null ，回收p内存 p.next = null; // 5. 链表长度- -1 1 --size; } /** 代码2 ：删除链表尾元素 **/ public void removeLast() { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空!&quot;); } // 2. 取得倒数第二个结点p,以及最后一个结点q Node p = findNode(size - 1); Node q = p.next; // 3. 将p的next域指向q的next域 p.next = q.next; // 4. 链表长度-1 --size; } /** 代码3：删除链表指定位置的结点 * @param index 删除位置 **/ public void remove(int index) { // 1. 判断链表是否为空 if (header.next == null) { throw new RuntimeException(&quot;删除失败，因为链表为空！&quot;); } // 2. 判断删除位置是否合法 rangeCheckForRemove(index); // 3.判断特殊情况 if (index == 0) { removeFirst(); return; } if (index == size - 1) { removeLast(); return; } // 4. 找到删除位置index前的结点p，以及删除位置index的结点q Node p = findNode(index); Node q = p.next; // 5. 将p结点的next域指向q结点的next域 p.next = q.next; // 6. 将q结点的next域设为null，回收q内存 q.next = null; // 7. 链表长度-1 --size; } /** 代码4： 判断删除位置是否合法 * @param index 删除位置 **/ private void rangeCheckForRemove(int index) { if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;删除位置不合法！&quot;); } } /** 代码5：打印顺序表。（同上，略）*/ } 主代码测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); // 在链表头部插入元素 linkedList.addFirst(2); linkedList.addFirst(6); linkedList.addFirst(3); linkedList.print(); // 在链表中间插入元素 linkedList.add(2, 7); linkedList.print(); // 在链表尾部插入元素 linkedList.addLast(8); linkedList.print(); // 删除第一个元素 linkedList.removeFirst(); linkedList.print(); // 在链表中间删除元素 linkedList.remove(3); linkedList.print(); // 删除最后一个元素 linkedList.removeLast(); linkedList.print(); } 插入删除算法的时间复杂度单链表的插入删除算法由两部分构成，第一是查找到第index个结点，第二是插入和删除结点。所以，如果我们不知道第index个结点的具体位置，链式存储与顺序存储的插入、删除算法都是O（n）。 连接算法若现已存在两个链表，需将这两个链表连起来。其中一个算法是直接将其中一个链表的末端接到另一个的首段，不再赘述。 另一个算法为：若已知链表的数据元素按值非递减有序排列，将两表归并为一个新的线性表, 且其中的数据元素仍按值非递减排列。 整体参考思路搜索：需要两个指针搜索两个链表；比较：比较结点数据域中数据的大小；插入：将两个结点中数据，小的结点插入新链表。 参考代码//创建方法Connection public static LinkedList&lt;Integer&gt; Connection(LinkedList&lt;Integer&gt; a, LinkedList&lt;Integer&gt; b){ LinkedList&lt;Integer&gt; c = new LinkedList&lt;&gt;(); //创建指针，并指向第一个结点 LinkedList&lt;Integer&gt;.Node pa=a.header.next; LinkedList&lt;Integer&gt;.Node pb=b.header.next; //比较指针指向结点大小，依次填入单链表c中，直至其中一个单链表全部录完 while (pa != null &amp;&amp; pb != null){ if (pa.data &gt;= pb.data){ c.addLast(pb.data); pb = pb.next; }else { c.addLast(pa.data); pa = pa.next; } } //将录完单链表的另一个依次录入 if (pa==null){ while(pb!=null){ c.addLast(pb.data); pb=pb.next; } }else if(pb==null){ while(pa!=null){ c.addLast(pa.data); pa=pa.next; } } //返回 return c; } 主函数测试 public static void main(String[] args) { LinkedList&lt;Integer&gt; linkedListA =new LinkedList&lt;&gt;(); linkedListA.addLast(3); linkedListA.addLast(5); linkedListA.addLast(8); linkedListA.addLast(11); linkedListA.print(); LinkedList&lt;Integer&gt; linkedListB =new LinkedList&lt;&gt;(); linkedListB.addLast(2); linkedListB.addLast(6); linkedListB.addLast(8); linkedListB.addLast(9); linkedListB.addLast(11); linkedListB.print(); LinkedList&lt;Integer&gt; linkedListC = new LinkedList&lt;&gt;(); linkedListC=Connection(linkedListA,linkedListB); linkedListC.print(); } 单链表应用一元多项式运算 关于其他链表双链表部分算法 其他的链表与单链表类似，地址域有一定改变，其方法也同样有一定改变，这里不再赘述。（其实就是我懒。）","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《数据结构》笔记（2）——线性表及其顺序储存结构","slug":"数据结构笔记2","date":"2020-03-03T01:45:00.000Z","updated":"2020-06-16T11:40:30.076Z","comments":true,"path":"2020/03/03/数据结构笔记2/","link":"","permalink":"/2020/03/03/数据结构笔记2/","excerpt":"","text":"线性表的逻辑结构定义：数据元素之间的关系为一一对应的n个数据元素。 （a0，a1，…，ai-1，ai，ai+1，…，an-1）a0：线性起点ai-1：前趋ai+1：后继an-1：线性终点 均匀性：数据类型相同。有序性：不可交换次序。 内存地址：Loc(i)+L0+i×m（m：每个元素所占用的存储单元个数） 线性表的顺序存储结构及算法特点、优缺点 特点 数据连续存放、随机存取设备。 逻辑上和物理上相邻。 存储结构简单、易实现。 插入、删除操作不便。 存储密度大，空间利用率高。 优点 无需为表示表中元素之间的逻辑关系而增加存储空间。 可以快速取出表中的任一元素。 缺点 插入删除操作需要移动大量元素。 当线性表长度变化较大时难以确定空间容量。 ，需要预先分配空间，且容易造成存储空间的“碎片”。 适用：表中元素变动较少的情况，且拥有连续的存储空间。 插入算法注：参考代码中各个算法均包含在类中. 思路1、判断插入位置是否合法。2、将第n-1至第i个元素后移一个存储位置。3、将要插入的x元素插入到ai-1之后。4、表长度+1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ public static class SequenceList&lt;E&gt;{ //用数组存储顺序表 private Object[] seqList; //顺序表的元素个数 private int size =0; //初始化顺序表 public SequenceList(){ seqList= new Object[1000]; } /** 定义：在顺序表中末尾添加元素函数 add(E element) * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(E element) { seqList[size] = element; ++size; return true; } /** 定义在顺序表某位置插入函数add(int index, E element) * @param index 插入位置 * @param element 插入元素 * @return 如果插入成功返回true，否则返回false */ public boolean add(int index, E element) { // 1. 判断插入是否合法 rangeCheckForAdd(index); // 2. 将存储在size-1位置至index位置的元素依次后移一个位置 for (int i = size; i &gt; index; --i) { seqList[i] = seqList[i - 1]; } // 3. 将x插入到index位置 seqList[index] = element; // 4. 表的长度+1 ++size; return true; } /** 定义插入位置是否合法函数 rangeCheckForAdd(int index) * @param index 插入位置*/ private void rangeCheckForAdd (int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(&quot;插入位置不合法！&quot;); } /** 定义打印顺序表函数 print ( ) * 打印顺序表*/ public void print( ) { System.out.print(&quot;顺序表长度为:&quot;+size+&quot;,内部元素为:&quot;); for (int i = 0; i &lt; size; ++i) System.out.print(seqList[i] + &quot; &quot;); System.out.println(); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList=new SequenceList&lt;Integer&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.add(2); seqList.print( ); // 在1位置插入元素7 seqList.add(1, 7); seqList.print( ); } 时间复杂度在有n个元素的顺序表中，插入的位置有n+1个，并且是等可能的。O(n) 删除算法注：参考代码中各个算法均包含在类中. 思路1、判别指定的位置是否合法2、若合法，则将位置i+1至n上的元素前移一个存储位置3、表的长度 -1。 代码参考 /** 线性表：定义顺序表类 SequenceList**/ /** 同上 **/ public static class SequenceList&lt;E&gt;{ private Object[] seqList; private int size =0; public SequenceList(){ seqList= new Object[1000]; } /** 定义删除指定位置的元素函数 remove(int index) * @param index 删除位置 */ public void remove(int index) { // 1. 判别指定的位置是否合法 rangeCheckForRemove(index); // 2. 将位置index+1 至 size-1 位置上的元素前移一个位置 for (int i = index+1; i &lt;= size - 1; ++i) { seqList[i-1] = seqList[i]; } // 3. 表的长度-1 --size; } /** 定义删除位置是否合法函数 rangeCheckForRemove(int index) * @param index 删除位置 */ private void rangeCheckForRemove (int index) { if (index &gt;= size || index &lt; 0) throw new IndexOutOfBoundsException (&quot;删除位置不合法！&quot;); } } 主函数测试 /** 定义主函数 main()*/ public static void main(String[] args) { SequenceList&lt;Integer&gt; seqList = new SequenceList&lt;&gt;(); // 构造一个顺序表 seqList.add(1); seqList.add(5); seqList.add(2); seqList.add(12); seqList.print(); // 在1位置插入元素7 seqList.add(1, 7); seqList.print(); // 删除1位置元素 seqList.remove(1); seqList.print(); } 时间复杂度在有n个元素的顺序表中，可以删除的元素有n个，并且是等可能的。O(n)","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"我和碧蓝航线","slug":"碧蓝航线1000天纪念","date":"2020-02-27T08:00:00.000Z","updated":"2020-06-10T03:54:32.598Z","comments":true,"path":"2020/02/27/碧蓝航线1000天纪念/","link":"","permalink":"/2020/02/27/碧蓝航线1000天纪念/","excerpt":"","text":"关于1000天当天那天相当震憾，有必要提一下。 不知道是疫情影响，还是因为正值毛子活动维护，当天就创了上线人数新高，所以这群在群里嘴上说冲的人一开服就把这游戏的服务器冲爆了，本来是下午3点开服，结果拖到了8点才基本解决问题，相当震憾。（人多可以理解，而且炸服补偿到位也就不说什么了） 一些想法其实如果不是这次惊喜和小加加在官博发文，都不知道这游戏已经1000天了，现在碧蓝航线在我taptap上的在线时间是最多的，1200多个小时，虽然大部分也只是在看后勤，打日常，但确实这游戏是我不舍得弃坑的游戏。 其实我实在舰b开服后两三天里在b站上的广告得知的，当时我对这游戏知之甚少，但是对于一名wows玩家，对二战的海军还是挺感兴趣的，并且看到游戏宣传里企业、拉菲和欧根的立绘，尤其是欧根亲王，就感觉这游戏的游戏资源有点东西胸有大痣，就想着下载来玩一下，就玩到今天了。 当时不知道为什么会对这三个角色有特别的偏好，直到现在业界有科学理论来证实这一现象了：“All Chinese love white hair” 因为我对于手游的态度一向是比较佛系的，而且当时我已步入准高三，所以当时并没有花太多时间在碧蓝航线上，即使我经历过第一次夏活，也对舰b并没有太多感受。所以即使游戏当时的口碑爆炸，我也没有什么亲身体会。 我当时脑子抽了，把装备回收箱和情人节礼物给用了，f**k（简洁有力的维多利亚方言） 开始认真对待这游戏的时候已经是高三寒假和下学期了（高三有什么寒假，别问为什么高三还有时间玩游戏），然后才意识到舰b在当时的手游范围内算是比较良心的了，而且碧蓝航线对自己的定位相当准确，高质量的皮肤，较低的抽卡成本，容易获得的高强度角色让人欲罢不能。她就像一个精打细算的商人，让自己赚钱的同时，让我们花钱的同时获得尽可能大的回报。 这live2d皮肤不香吗 碧蓝航线把“All Chinese love white hair”这一（伪）科学理论表现得淋漓尽致，从每年的人气投票就可以看出，这个梗在圈里过于有名，以至于传到了国外，这也可以看出碧蓝航线确实很懂得自己的定位。其实我对哪种立绘的偏爱是在碧蓝航线中才逐渐了解的，也让我真正对“画师”有了浅显的理解。就是喜欢黑兔的立绘 这游戏愿意肝也可以肝，愿意养老也可以，氪金和不氪金的玩家、肝帝和咸鱼玩家、研究党和娱乐党都可以玩的很高兴。 这游戏到后期本质就是一个聊天软件，一群人大多数时间在公屏里讨论除了碧蓝航线的各种话题，据说通过公屏还成了几对。每个人都可以在碧蓝航线里找到自己的老婆。（雾） 个人感觉，在碧蓝圈子里大多数人都是很和谐的，大家在群里吹吹水也十分和谐，这是我这些年来一直在玩碧蓝的原因之一，也让我认识到对海军感兴趣的大多数人是一群精苏玩家。除了第一次夏活难度的不合理，饺子的开火限制解除，某些皮肤过于xx而被举报外并没有什么大的节奏问题，也许这也正是成就碧蓝航线的原因之一。 对于皮肤，我觉得大多数的玩家反而希望这种皮肤越多与好，你还能对一个曾经适龄年龄13岁，之后提到了18+岁的游戏说什么吗。 结尾转眼间，这游戏已经1000天了，再过几个月就要三周年了，虽然因为各种原因国服难以与日服在本子那边的热度难以相比，但依然希望碧蓝在国内能够继续运营下去，毕竟这游戏确实不错。 最后，大舰队什么的。。。 国服玩家只能看本子的生放送获取最新消息，看美服玩家1周年在衣阿华战列舰上开127mm高平炮。 某些图不方便发，p站上搜一大堆。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"《数据结构》笔记（1）——绪论","slug":"数据结构笔记1","date":"2020-02-25T01:45:00.000Z","updated":"2020-06-16T11:56:28.625Z","comments":true,"path":"2020/02/25/数据结构笔记1/","link":"","permalink":"/2020/02/25/数据结构笔记1/","excerpt":"","text":"认识数据结构 数值计算：利用数学方程。 步骤：具体问题→数学模型→算法→编程、调试→得到答案 非数值计算：利用数据结构。 步骤：问题→抽象出问题的模型→求模型的解 类型：线性结构（一对一）；非线性结构【树形结构（一对多）、图形结构（多对多）】 （注：判断是否为线性结构优先画图，更直观。） 基本概念数据：对信息的一种符号表示。数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。数据项是数据的不可分割的最小单位。数据类型：性质相同的数据元素的组合。（注：数据由数据元素构成，数据元素由数据项构成。数据＞数据元素＞数据项） 数据结构：1、数学概念：S=（D，R）数据和关系的集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、内容概念：逻辑结构+存储结构+算法。（数据逻辑结构独立于计算机，存储结构依赖于计算机，运算定义依赖于逻辑结构，实现依赖于存储结构。） ADT——抽象数据类型，数据↔操作，ADT=（R,S,T）&ensp;&ensp;&ensp;&ensp;定义：1、使用视图：逻辑结构+操作集合。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、设计视图：存储结构+算法设计&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3、实现视图：成员变量+成员函数 逻辑结构 集合 线性结构 线性表 栈 队列 串级数组 非线性结构 树形结构 图形结构 存储结构 顺序存储方式：存储空间连续。 链式储存方式：存储空间不连续。 索引存储方式：索引表。 散列存储方式：哈希函数。 算法程序=算法+数据结构 定义：有穷规则的集合，规则确定一个解决某一特定类型问题的操作序列。 特征：输入、输出、确定性、有穷性、可行性。 原则：正确性、可读性、健壮性（容错处理）、效率与存储量的需求。 方式：自然语言、流程图、伪代码。 算法评价：时间复杂度——定性描述该算法的运行时间。常用大O符号表述，不包括这个函数的低阶项和首项系数。 程序设计实质：数据的表示和处理。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"《决战中途岛》观后感","slug":"决战中途岛观后感","date":"2020-02-20T05:33:00.000Z","updated":"2020-06-10T03:52:24.498Z","comments":true,"path":"2020/02/20/决战中途岛观后感/","link":"","permalink":"/2020/02/20/决战中途岛观后感/","excerpt":"","text":"作为一个稍微对二战历史感兴趣的，并且入坑了舰c、舰b、wows、舰r（虽然在入坑舰c后退坑了）的人，有一部以二战时期的太平洋战场为背景的电影，无论电影好坏都是要看的，现在二战题材的电影又少之又少（毕竟市场小，不赚钱）。之前上映的时候找不到同圈子的人去看，趁着b站上映就去看了。对于自己来说，这是一部不错的电影。 剧情简介《决战中途岛》是由罗兰·艾默里奇执导由伍迪·哈里森、卢克·伊万斯、帕特里克·威尔森、曼迪·摩尔、艾德·斯克林、浅野忠信等主演的电影。 该片于2019年11月8日北美、中国内地同步上映。中途岛战役于1942年——日本偷袭美国珍珠港事件半年之后在南太平洋爆发，美国海军在中途岛环礁成功击退日本帝国海军舰队的攻击，获得了太平洋战区的主动权，这场战役被历史学家视为战争的转折点。 影片改编自1942年6月的中途岛战役，是整个太平洋战争的关键转折点，扭转了自珍珠港事件之后反法西斯盟军节节败退的局面。同时，这也是世界历史上著名“以小搏大”的战役之一，在海空军力大幅弱于日本的情况下，美军以沉没一艘航空母舰为代价，一举击沉日本主力航空母舰四艘、巡洋舰一艘。此次战役的胜利，彻底改变了反法西斯战争的格局，为二战胜利打下坚实的基础。 （摘自“百度百科”） 观后感这部分观后感极具主观色彩，且偏向肯定方向，在此说明。 bug作为一个有点了解那个时期历史的人，最喜欢的就是找bug。印象最深的就是联合舰队有5条大和。。 灭 国 舰 队 / 未 曾 设 想 的 道 路 / 震 撼 美 帝 / wows 10 级 房 现 状 其实还有其他的bug，比如珊瑚海代替太太（列克星敦）沉的是约克城。 约克城你好惨啊，在一部剧里沉了两次。 又或是主炮是鱼雷的驱逐舰。 但印象最深的还是麦克拉斯基发现本子舰队的名场面，这个梗估计这一年我都忘不了。 5艘大和你能把我秒了？ 毕竟经费有限可以理解，而且无伤大雅，所以就在这里调侃一番为止。 优点1、与《珍珠港》相比，这部电影里面没有谈恋爱！没有谈恋爱！没有谈恋爱！所有角色为剧情服务。 男人要看就看大舰巨炮，辣鸡三角恋。 2、难得的全景式、多方位记录一场二战的战争的电影，剧情流水账，主要场景在企业上，偏向于战争纪录片，估计没个5、6年是看不到下一部了，且看且珍惜。 3、国外二战电影中难得有中国内容的电影——空袭东京后，中国军民协助撤离杜立特编队成员，并且当时也因为掩护他们而牺牲了许多人。也可能是因为中国投资方投资比例最大。 不要在意那个微软字体的牌坊。 4、电影中有些情节能使得对历史有一定了解的人感到亲切，比如美帝的铁棍雷，以及本子海军传统艺能——最大的敌人是陆军，还有企业上的牛排，等。 全剧唯二笑的地方就是美帝的铁棍雷，另一个就是五艘大和。 5、演员基本贴合史实，没有强加政治正确元素。 看到剧中的飞龙舰长山口多闻总感觉他们在打外星人。 6、作为中心的中途岛战役该表现的情节基本上表现到了，看得既惊险又刺激，比如vt8鱼雷编队的惨烈，贝斯特俯冲轰炸一发入魂赤诚的情节。 缺点1、由于主要讲述的是中途岛战役，要在两个小时左右既要展现主题，又要讲清前因后果是比较困难的，尤其在经费不足的情况下从珍珠港开始，所以在中途岛之前剧情跳转迅速，比如珊瑚海中列克星敦转眼就沉了，如果不是对历史有点认识的话可能会一脸懵b。好在中途岛之中表现不错。 2、同样是因为经费有限，在中途岛之前的特效有明显的不自然的情况，无法与其他大多数知名战争片相比。 3、由于是全景式、多方位的电影，部分角色的人物形象不太深刻。有些本（感觉）应该是重要的剧情和人物也没有体现出来，比如中途岛一战成名的美方指挥官斯普鲁恩斯，在电影中只有过场；“AF可能缺乏淡水”在中途岛战役中的著名电报，在电影中并未着墨太多。 其他1、剧中在企业上爬上飞机打偏本子神风的猛男——布鲁诺·盖多，在一天干翻两艘航母的俯冲轰炸的猛男——理查德·迪克·贝斯特，在中途岛拍纪录片，后来得了奥斯卡的的导演——约翰·福特，等，都是史实，比抗日神剧的剧情好的太多。 2、电影否定了“命运五分钟”的说法，还进行了调侃。 现在不是昭和，大人，时代变了。 3、由于要增加观众的观看体验，电影中加强了本子的防空火力，历史中本子拉不出那样的防空火力网。 轮射的96神炮，昭和防空。 4、电影的剧本其实很早就基本完成，结果在美国没有投资人感兴趣，直到中方进行投资。（那可是你们父辈的荣光啊） 5、这部电影注定不会有高票房，资方亏钱情理之中，谁叫这个市场小呢。 总结对于对历史感兴趣的人来说，个人建议必看，其他的话也许需要稍微了解一下珍珠港、珊瑚海的相关情况，不然开始的一个小时可能会有点懵。不过对于想了解那一段历史，或者是因为感兴趣，或者单纯是要看“Lucky E”的人来说，都是一部个人推荐的，值得去看的电影。 顺便剧透一下：美帝赢了，本子输了。 大海铭记不朽。为电影的工作人员点赞。 电影之外的东西1、我想起初中的时候自己还年少不懂事，认为本子当年就很傻，没事就偷袭美帝，既把德国拉下水，又给自己找了个爹。现在想起来真是惭愧不如。 2、中途岛都安排了，什么时候安排一下莱特湾？ （但莱特湾估计不太可能，毕竟美帝方面指挥有失误。那以塔菲三号为中心也行。） 3、还有，美帝战后把企业拆了，果然敌在国会山。（和“老女士”厌战一样，工党误国） 企业：我为国家流过血！我要见总统！ 之后企业当核航妈去了，厌战当死库水（潜艇）去了","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"电影","slug":"电影","permalink":"/tags/电影/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"谨此纪念霜星","slug":"谨此纪念霜星","date":"2019-12-25T01:58:00.000Z","updated":"2020-06-10T03:54:43.032Z","comments":true,"path":"2019/12/25/谨此纪念霜星/","link":"","permalink":"/2019/12/25/谨此纪念霜星/","excerpt":"","text":"“…等我们自由了，我们会放声大哭，在荒野里在雪地里，在堆得满满的麦垛里放声大哭” 圣诞节的礼物？？想起其他的牺牲的干员了（Ace、Scout）。。","categories":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"},{"name":"游戏相关","slug":"游戏相关","permalink":"/tags/游戏相关/"}],"keywords":[{"name":"日常","slug":"日常","permalink":"/categories/日常/"}]},{"title":"Hello World","slug":"Hello World","date":"2019-12-09T09:50:00.000Z","updated":"2020-06-10T03:51:54.125Z","comments":true,"path":"2019/12/09/Hello World/","link":"","permalink":"/2019/12/09/Hello World/","excerpt":"","text":"某种意义上的“First Post”，总结了建站时hexo自带的《Hello World》和主题Sakura的使用文档。 关于hexo关于hexo更多的信息可以查看官网的使用文档，使用中存在的问题可以在troubleshooting查找，或者在GitHub上提问。 创建$ hexo new &quot;My New Post&quot; More info: Writing 启动服务器$ hexo server More info: Server 生成文件$ hexo generate More info: Generating 发布$ hexo deploy More info: Deployment 清理清理本地文件，防止修改部分文件后出现错误。 $ hexo clean 本地调试$ hexo clean &amp;&amp; hexo s 上传服务器$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 关于Sakura主题hexo-theme-sakura主题基于WordPress主题Sakura修改成Hexo的主题。 详细使用方法查看使用文档。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"/tags/收藏/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}